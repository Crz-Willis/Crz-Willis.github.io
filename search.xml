<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ICPC 2022 沈阳游记</title>
    <url>/2022/11/11/icpc-shenyang-2022/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本以为要退役了，没想到才刚刚开始</p>
<span id="more"></span>

<h1 id="inf-Days-before-Day-inf"><a href="#inf-Days-before-Day-inf" class="headerlink" title="inf Days before Day -inf"></a>inf Days before Day -inf</h1><p>由于我的算法竞赛中还没有一块金牌，所以决定这个学期再打两站（ICPC沈阳和CCPC广州），想再冲一冲。</p>
<h1 id="Day-inf"><a href="#Day-inf" class="headerlink" title="Day -inf"></a>Day -inf</h1><p>最后经过商讨，决定报ICPC沈阳，具体原因可以看下面对话</p>
<img src=5.jpg width="30%">

<h1 id="Day-inf-x2F-2"><a href="#Day-inf-x2F-2" class="headerlink" title="Day -inf&#x2F;2"></a>Day -inf&#x2F;2</h1><p>沈阳站名单出了，看到强度很小，于是有了如下的对话：</p>
<img src=1.jpg width="30%">

<img src=3.jpg width="30%">

<img src=4.jpg width="30%">

<p>全部名单出来后：</p>
<img src=6.jpg width="30%">

<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>练了一套上海市赛，感觉状态还可以，估计应该可以金</p>
<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>练了一套SEERC，直接寄了，感觉自己要铁牌了。</p>
<p>晚上出去吃了个麦，顺便制定了一下战术：我和zh把银牌尽量把银牌以下的题写完，wzx开一个nb题，然后就可以金了。</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>12:00开赛，10:00就到了现场，于是先去看了看威海站的情况，发现还可以。</p>
<p>吃完外卖已经11:30了，于是调试完了电脑就赶忙登陆了。</p>
<p>开始之后，发现有人瞬间过了D题，于是我就去看，发现是签到之后顺利通过，5min1A。</p>
<p>签完到后发现C有人过了，我把C题喂给了zh，zh很快有了做法并且顺利通过，20min1A。</p>
<p>之后zh和wzx发现G题好像和通道很像，于是丢给了wzx。</p>
<p>30min左右的时候zh发现L是简单题，于是上机去写，中间碰到了一点读题问题，于是我又回过头去读了个题，解决了题意问题，之后顺利通过，52min1A。</p>
<p>此时发现E和F都有人开出来了，于是wzx上机开始写G，我和zh从E和F中选一个开，最后选择了F。</p>
<p>想F的时候突然发现只要一行或者一列填好了，剩下的行或者列可以复制过去，我把这个发现和zh说之后就去想怎么去构造一行或者一列的情况，zh说可以用背包，我想了想有道理。于是zh上机，顺利通过，96min1A。</p>
<p>之后发现还有没读完的题，我去读了J，K和M，zh觉得J可以做，手玩过了样例1，此时wzx还在上机，zh去玩样例2，发现假了之后我和zh一起去想A。</p>
<p>想着想着wzx写完了，然后发现手造的样例挂了，于是开始调。过了一会，发现了bug并且调完了，手造样例过了之后交上去后就通过了，160min1A。</p>
<p>过G之后是rk4，觉得金牌没什么问题了。压力也就小了很多。</p>
<p>之后发现E先要跑一个边双，然后变成一个树上计数的问题，于是丢给了wzx。</p>
<p>中间我发现A可以拆成不交区间来算，然后可以统计两个不相交的区间的贡献。zh上机，我在造退化的数据。调过了之后交上去就AC了，196min1A。</p>
<p>A过了之后wzx说他会E了，让zh给他写一个边双，写完之后wzx写E，通过了样例后交上去WA了，我造了组样例发现了错误，然后发现缩点出了问题，于是改了之后就过了，255min2A。</p>
<p>过完之后我们觉得没有题做了，于是提前半个小时左右就下班了。</p>
<p>最后rk3，居然出线了，感谢zh和wzx把我带飞了（</p>
<p>晚上发现I可以做，H读错题了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>都超额完成了任务，我和zh双排打到了金中，wzx开了两个nb题。</p>
<p>不管怎么说，终于拿到了一次金牌，顺便还有了一次可能可以去埃及旅游的机会，看学校放不放人了（</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC 2021 昆明站游记</title>
    <url>/2022/04/16/kunming2021/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>拿到了人生的第一块“精神”金牌。</p>
<span id="more"></span>
<h1 id="inf-Days-before-Day-inf"><a href="#inf-Days-before-Day-inf" class="headerlink" title="inf Days before Day -inf"></a>inf Days before Day -inf</h1><p>lzc要去实习，zh和wzx说想为ec热手，于是就叫上了我和他们一起打昆明站。</p>
<h1 id="Day-inf"><a href="#Day-inf" class="headerlink" title="Day -inf"></a>Day -inf</h1><p>学校封校，去不了软件园校区，以为要被迫周烜双排了。</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>收到了昆明打星队伍可以远程打比赛的消息，于是赶紧和周烜协调了一下准备线上打昆明站。</p>
<h1 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h1><p>因为板子都在软件园，热身赛前三个小时紧急打了板子，-11.35</p>
<p>三人两机，远程参赛。晚上试了下场地，调了下环境就下线了。</p>
<p>主办方没提供热身赛题面，我还以为在大群里，折腾了半天最后才发现热身没有题面，只有正赛才有。</p>
<p>半夜12点半电脑突然响了，以为电脑出问题了，等了半个小时后发现是装更新？？？</p>
<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>早上9点半起床，发现志愿者已经在催核验身份了，于是光速起床洗漱，在宿舍调试好环境后准备开始比赛</p>
<p>拿到题面的过程还算顺利，决定我从头读，wzx从末尾读，zh在中间挑短的签到。</p>
<p>开比赛后我发现A题是一个大模拟，于是放到了一边转去读B。</p>
<p>B读完了之后发现B，G，K都有人过了，于是我给zh报了B的题意，wzx去想K，我去读了G。</p>
<p>wzx过了K以后，我给wzx讲了下我并没有什么思路的G，然后wzx秒了，过了一会就过了。</p>
<p>我：？？？？</p>
<p>此时D，E，F都有不少队过了，我读完F之后转化了下题意，发现$\frac{\sum\limits_{u\in V} b_u}{|V|}$这个东西不会求，于是找了wzx。</p>
<p>wzx：经典模型，然后等zh过了G之后就上去写了写。</p>
<p>写完交完发现wa了，于是下机想。最后发现分子上的东西可能能取到负的，最后wzx调了下之后就过了。</p>
<p>过了之后我觉得我已经无事可做了后开始写A，然后zh和wzx在另一边写B和D。在我写的过程中他们把D过了，然后开始调B。</p>
<p>我把A写完了之后不出意外出现了很多bug，而且还有tle的可能，于是我在枚举的时候加了个剪枝，本地测试极限数据跑了2秒后。</p>
<p>我：我写完A了，你们帮我交一下，要是没过我就下班了。</p>
<p>zh：好。</p>
<p>（30秒后）</p>
<p>zh：nb</p>
<p>我：过了？</p>
<p>zh：过了。</p>
<p>我：nb</p>
<p>然后我要了zh的B题代码之后没看几眼。</p>
<p>zh：我memset写错了。</p>
<p>然后他们就过了B。</p>
<p>然后最后对着C，E，L罚坐到了最后。</p>
<p>最后rk23，拿到了一块“金牌”。</p>
<p>说好不秃rk20，也恭喜他们拿到第一块金牌。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本身以为要0贡献了，结果写了个A还报了个F的做法，也算还行吧。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>破防了</title>
    <url>/2022/09/02/pofang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>保研破防</p>
<span id="more"></span>

<p>有点想说的，正好今天有空就写写吧。</p>
<p>自从高考失利，谈恋爱失败后，我就把绝大部分心思放在了学习上。但是我现在有些后悔。</p>
<p>2019年5月份的时候，我降级转专业到了数学学院，在数学院的三年时间里，我基本一心学习和音游。最后拿到了一个说得过去的绩点。虽然在某些考试之前有过没有睡着觉的经历，也有过心态爆炸的时候，但是我觉得都无伤大雅。</p>
<p>转眼就到了21年5月，各大学校开始了夏令营的招生。我当时想仗着四块ACM银牌的优势跨专业保研到AI或者CS之类的专业。投了fdu，ruc和pku。结果全寄了。</p>
<p>在全寄了之后，我就在想我到底哪个环节出了问题，后来感觉大家就业普遍减少，深造普遍变多，就导致研究生这条路更卷了。加上我是跨专业，就更加不占优势。所以经过一番考虑之后，我决定回到数学专业读运筹。</p>
<p>但是此时翻看学校是发现，大部分学校的运筹学专业之开设了直博这一条路，但是我认为我的科研水平几乎为0，加上大部分人说直博都不会很好过，考虑到我之前的心理状态，我比较抵触走直博这条路，因为谁也不知道我会不会读着读着心态就崩了然后去重开。但是考虑到直博中间读不下去的话还可以转硕士，这也是一个可以后退的道路吧。大不了先直博进去，读不动了再quit也是一个选择。</p>
<p>在此同时，家中的老人得了类风湿病一类的病，腿脚变得非常不方便，和家里人商量后，我们一致认为能在北京读研是最好的。</p>
<p>在下了这个决定之后，我就叫同学将复习所需要的书都寄回到了家中，开始了复习。期间我逐渐的变得熬夜和睡不着觉，有的时候12点钟躺在床上，翻来覆去，两点半还睡不着觉。有的时候躺下了，想着到时候面试的时候我答不上来的样子，然后就一下子睡意全无了。结果到8月中的时候，精神越来越差，就逐渐开始摆烂了。</p>
<p>与此同时，有些学校的预推免通知已经出来了，我就回到了济南准备材料。这之间还发生了不少事，不过都是后话了。但是清华的推荐信只要到了一封，剩下还有一封没有老师回我，但是31好就截止了，不知道能不能弄得上去。</p>
<p>有的时候感觉要是待材料学院就好了，或者想要是在数学院多摆摆烂，混个保研擦边的绩点，留sdu算了。</p>
<p>还有的时候想找个人倾诉倾诉，发泄一下情绪，又哪里找得到呢。</p>
<p>不过路已经走到这里了，又哪里有回头的机会呢。</p>
]]></content>
      <categories>
        <category>保研</category>
      </categories>
      <tags>
        <tag>保研</tag>
      </tags>
  </entry>
  <entry>
    <title>polya</title>
    <url>/2022/04/16/polya/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.luogu.com.cn/problem/P4980">传送门</a></p>
<span id="more"></span>


<p>题目描述：</p>
<p>给你$n$种颜色，再给你一个正$n$边形的项链，问你有多少种本质不同的染色方案。</p>
<p>注意本题的本质不同，定义为：<strong>只需要不能通过旋转与别的染色方案相同</strong>。</p>
<p>输入格式：第一行一个正整数$t$，表示数据组数，之后每一行一个数，代表$n$</p>
<p>输出格式：对于每一组数据，输出一个数，代表答案对$1e9+7$取模的结果。</p>
<p>样例输入：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>样例输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">11</span><br><span class="line">70</span><br><span class="line">629</span><br></pre></td></tr></table></figure>

<p>数据规模约定：$n\leq10^9,t\leq10^3$</p>
<p>在这里就不介绍Poyla定理的具体内容了，讲一讲应该如何优化。<br>我们不难求得答案是$ans&#x3D;\sum\limits_{i&#x3D;1}^nn^{gcd(i,n)}$</p>
<p>但是直接枚举复杂度是$O(tnlg^2n)$的，我们想办法优化。</p>
<p>我们可以发现对于$n$的每一个因子进行枚举可以发现，对于$n$的每一个因子$d$，我们有$n^d$种染色方案，又有$\varphi(\frac{n}{d})$个$gcd(i,n)&#x3D;d$的情况。<br>所以对于每一个$d$，我们将答案加上$n^d\varphi(\frac{n}{d})$</p>
<p>所以我们枚举$n$的因子即可，这样的复杂度可以变为$O(t(n\sqrt{n})^\frac{1}{2}lgn)$的，但这还不够，我们要继续优化。</p>
<p>我们可以先筛出每个质因子，然后再求欧拉函数的过程中，直接枚举质数即可。这样的复杂度可以变为$O(t(n^\frac{1}{2}lgn)^\frac{1}{2}lgn)$，就可以过了。</p>
<p>Code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pause system(<span class="string">&quot;pause&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e4</span>;</span><br><span class="line"><span class="type">int</span> prime[maxn + <span class="number">10</span>], tot;</span><br><span class="line"><span class="type">bool</span> vis[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getprime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * prime[j] &lt;= maxn; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a %= mod;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getphi</span><span class="params">(ll t, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1ll</span> * prime[i] * prime[i] &lt;= <span class="number">1ll</span> * t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t % prime[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * (prime[i] - <span class="number">1</span>) / prime[i];</span><br><span class="line">            <span class="keyword">while</span> (t % prime[i] == <span class="number">0</span>)</span><br><span class="line">                t /= prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans * (t - <span class="number">1</span>) / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">getprime</span>();</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n, ans = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * i == n)</span><br><span class="line">                ans += <span class="built_in">qp</span>(n, i - <span class="number">1</span>, mod) * <span class="built_in">getphi</span>(i, mod) % mod, ans %= mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += <span class="built_in">qp</span>(n, n / i - <span class="number">1</span>, mod) * <span class="built_in">getphi</span>(i, mod) % mod;</span><br><span class="line">                ans += <span class="built_in">qp</span>(n, i - <span class="number">1</span>, mod) * <span class="built_in">getphi</span>(n / i, mod) % mod;</span><br><span class="line">                ans %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt;(ans%mod+mod)%mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>群论</category>
      </categories>
      <tags>
        <tag>polya</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P5300 [GXOI/GZOI2019]与或和</title>
    <url>/2022/04/26/luogu-P5300/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单调栈好题</p>
<span id="more"></span>

<p><a href="https://www.luogu.com.cn/problem/P5300">传送门</a></p>
<p>大致题意：给你$n\times n$的矩阵$A$，让你求矩阵中所有子矩阵的与$\&amp;$和或$|$的和。<br>数据范围：$n\leq 2000,a_{i,j}\leq 2^{31}-1$</p>
<p>大致题解：拆位考虑，对于与运算，我们对每一个$a_{i,j}$计算以它为右下角的全1子矩阵个数，对于或运算，我们计算以$a_{i,j}$为右下角的全0子矩阵个数，然后用$i\times j$减去全0子矩阵的个数即可。</p>
<p>下面讨论怎么使用单调栈来维护以$a_{i,j}$为右下角的全1&#x2F;0子矩阵个数。</p>
<p>预处理$s_{i,j}$为以$a_{i,j}$上方连续的1&#x2F;0的个数，然后我们依次枚举一个点，计算以它为右下角的全1&#x2F;0的子矩阵的个数。</p>
<p>我们设$f_{i,j}$是以$a_{i,j}$为右下角的全1&#x2F;0子矩阵的个数，维护一个单调递增的栈，当未发生弹栈的时候，我们有</p>
<p>$$f_{i,j}&#x3D;f_{i,j-1}+s_{i,j}$$</p>
<p>其中第一部分是从左边延伸过来的，第二部分是从$a_{i,j}$向上延伸的。</p>
<p>具体见图：<img src="/2022/04/26/luogu-P5300/image.png"></p>
<p>当发生弹栈的时候，意味着左边的延伸不过去了，需要减掉，我们有</p>
<p>$$f_{i,j}&#x3D;f_{i,j}-(s_{i,j}-s_{i,st.top()})*(st.top()-st.(top-1)())$$</p>
<p>其中$st.(top-1)()$表示栈顶的下一个元素。</p>
<p>具体见图（3弹栈的时候）：</p>
<p><img src="/2022/04/26/luogu-P5300/image2.png"></p>
<p>这样就维护了答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(a,x) memset(a, x, sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; P;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">2e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">qp</span> <span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">			ans = ans * a % mod;</span><br><span class="line">		a = a * a % mod;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[maxn][maxn];</span><br><span class="line"><span class="type">int</span> up[maxn][maxn];</span><br><span class="line">ll ans1,ans2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IOS;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			cin&gt;&gt;a[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">31</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">mem</span>(up[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i][j]&amp;(<span class="number">1</span>&lt;&lt;k))</span><br><span class="line">					up[i][j]=up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					up[i][j]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">			s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">			up[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">			up[i][n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">			ll bns=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				bns+=up[i][j];</span><br><span class="line">				<span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;up[i][j]&lt;up[i][s.<span class="built_in">top</span>()])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> x = s.<span class="built_in">top</span>();</span><br><span class="line">					s.<span class="built_in">pop</span>();</span><br><span class="line">					bns=bns-(x-s.<span class="built_in">top</span>())*(up[i][x]-up[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				s.<span class="built_in">push</span>(j);</span><br><span class="line">				ans1=(ans1+(bns&lt;&lt;k))%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">mem</span>(up[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>((a[i][j]&amp;(<span class="number">1</span>&lt;&lt;k))==<span class="number">0</span>)</span><br><span class="line">					up[i][j]=up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					up[i][j]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">			up[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">			up[i][n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">			s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">			ll bns=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				bns=bns+up[i][j];</span><br><span class="line">				<span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;up[i][j]&lt;up[i][s.<span class="built_in">top</span>()])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> x = s.<span class="built_in">top</span>();</span><br><span class="line">					s.<span class="built_in">pop</span>();</span><br><span class="line">					bns=bns-(x-s.<span class="built_in">top</span>())*(up[i][x]-up[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				s.<span class="built_in">push</span>(j);</span><br><span class="line">				ans2=(ans2+((<span class="number">1ll</span>*i*j-bns)&lt;&lt;k))%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>这是什么</title>
    <url>/2022/10/30/what/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是什么？</p>
<span id="more"></span>


<p><img src="/2022/10/30/what/1.JPG"></p>
<p><img src="/2022/10/30/what/5.PNG"></p>
<h1 id="一些常用的"><a href="#一些常用的" class="headerlink" title="一些常用的"></a>一些常用的</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p>$$<br> \begin{bmatrix}<br>   1 &amp; 2 &amp; 3 \\<br>   4 &amp; 5 &amp; 6 \\<br>   7 &amp; 8 &amp; 9<br>  \end{bmatrix}<br>$$</p>
<p>$<br>\begin{cases}<br>P(A_iA_j)&#x3D;P(A_i)P(A_j) \\<br>P(A_iA_jA_k)&#x3D;P(A_i)P(A_j)P(A_k) \\<br>\cdots \\<br>P(A_1A_2\cdots A_n)&#x3D;P(A_1)P(A_2)\cdots P(A_n) \\<br>\end{cases}<br>$</p>
<p>$$\lim\limits_{x\rightarrow\infty}\frac{1}{x}$$</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>保研之路</title>
    <url>/2022/09/28/%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一次神奇而又壮丽的经历</p>
<span id="more"></span>

<p>大概统计一下：<br>最终去向：中国科学院大学<br>通过复试：清华数学、山大数学、国科大数学<br>未通过复试：北大数学<br>进入复试：浙大cs，国科大数学，武大数学、北师大数学、北理数学<br>未过初审：北大rw</p>
<h1 id="一些想说的，可能有些语无伦次"><a href="#一些想说的，可能有些语无伦次" class="headerlink" title="一些想说的，可能有些语无伦次"></a>一些想说的，可能有些语无伦次</h1><p>我一直在想我以后要成为一个什么样的人。</p>
<p>自从挂掉pku rw的夏令营之后，我就变得极度焦虑，睡眠也越来越不好，12点躺在床上之后怎么都睡不着，有的时候睡着的时候天都快蒙蒙亮了。我这个时候就在想这个保研究竟给我带来了什么。在当时来看，明明卷了四年，但是什么都没有得到的我是不是真的就是five。有的时候真的想往空间里倒倒垃圾，但是大部分时间都控制住了自己，但是有的时候憋着真的非常难受（<a href="https://crz-willis.github.io/2022/09/02/pofang/">可以看这里</a>）。结果越难受越憋着，越憋着心态越炸。当时我还对不少人发了脾气，在这里说一声抱歉。</p>
<p>有的时候我在想我到底适不适合读phd，确实非常纠结。我常常在幻想我读不下来phd的那种绝望的时候，我当时真的在想如果读不出来该怎么回去交代。并且我自认为自己并没有科研天赋，读phd肯定读不出来。所以这也是我拒了thu的一个主要原因。</p>
<p>这些时间和我家长也有些不合拍，尤其是昨天，感觉是最难绷的一次。主要是还是因为家长想让我读phd然后留校，但是我并不想这样。我每次和家长说的时候都要对线一次，然后家长第二天就忘了，然后就和我说这事。并且不知这件事情，在和家长聊天的时候有的时候就会问之前问过的东西，有的时候还会连着好几天问，这样一是会消磨自己的耐心，二是会感觉家长并不是很关心自己。所以有的时候会和家长渐行渐远。</p>
<p>其实关于phd这件事，我想说研一读一年，看看自己适不适合，然后再决定自己到底要不要读，但是家长说那个时候就来不及了，让我现在做决定，但是自己毕竟还是一点科研经历都没有的，让我现在做决定属实是太为难自己了。然后家长就说那你想就业的话还不找实习什么的，还说现在大厂裁人很严重，一再让我放弃。我想说的是计算机对口的公司不止有大厂啊，有大厂相对应的也有小厂，是不是。而且我现在学的东西去实习就是在给自己送死，数学院本科学的东西不适合任意一个方向的实习，这也是数学的一个尴尬之处吧。</p>
<p>我知道我家长都非常成功，但是我可能只是一个平凡的人，接受自己的平凡真的这么难吗？要是家长一而再再而三的这么说的话我感觉就可以直接摆烂了。反正做什么家长都不满意的话不如不做了。</p>
<h1 id="一些时间点"><a href="#一些时间点" class="headerlink" title="一些时间点"></a>一些时间点</h1><h2 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h2><p>从隔离点回来，在学校健康监测之后，各大学校的夏令营开始陆续报名了。可以出宿舍的时间已经是5月18日了，离某些学校的截止时间很近了。于是匆匆报名了人大信息、复旦cs和北大rw。</p>
<h2 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h2><p>复旦cs和人大信息挂初审，瞬间开始焦虑。</p>
<h2 id="7月"><a href="#7月" class="headerlink" title="7月"></a>7月</h2><p>北大rw过了初审，第一步要看论文交报告，顺利通过，杜第二步是入营前面试，挂掉了，于是夏令营还没开始就结束了。</p>
<p>此时夏令营0offer，已经焦虑的不成样子了。</p>
<h2 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h2><p>8月初去了长春，缓解缓解压力，在这里感谢yzhh陪我玩了四天。</p>
<p>8月底为了准备清华和国科大的推荐信和盖章，提前回来了一个礼拜，但是推荐信是线上完成的，只有盖章是线下盖的。</p>
<p>准备完之后我就开始复习了，在复习中我还在注意着别的学校的招生通知。</p>
<h2 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h2><h3 id="9-2"><a href="#9-2" class="headerlink" title="9.2"></a>9.2</h3><p>济南出疫情了，学校封校，原本的勤也没法出了，于是晚上开始在宿舍打om。</p>
<h3 id="9-20"><a href="#9-20" class="headerlink" title="9.20"></a>9.20</h3><p>thu面试，整个过程还算平稳，老师也没特别刁难，整个面试过程平稳结束。最后晚上拿到了offer，但是因为是直博，于是犹豫去不去。</p>
<h3 id="9-21"><a href="#9-21" class="headerlink" title="9.21"></a>9.21</h3><p>我认为自己不适合直接读博士，所以拒掉了thu的offer，此时还是0offer</p>
<h3 id="9-22"><a href="#9-22" class="headerlink" title="9.22"></a>9.22</h3><p>上午pku面试，整个过程完全爆炸，最后不出所料地寄了。</p>
<p>下午sdu面试，因为毕竟是本校，老师都挺和蔼的，平稳渡过，此时终于拿到了一个offer。</p>
<h3 id="9-23"><a href="#9-23" class="headerlink" title="9.23"></a>9.23</h3><p>ucas专业面试，顺利度过。</p>
<h3 id="9-26"><a href="#9-26" class="headerlink" title="9.26"></a>9.26</h3><p>ucas英语面试，也顺利度过，此时基本确定去向了。</p>
]]></content>
      <categories>
        <category>保研</category>
      </categories>
      <tags>
        <tag>保研</tag>
      </tags>
  </entry>
  <entry>
    <title>线性系统理论复习</title>
    <url>/2022/06/24/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>复习线性系统理论</p>
<span id="more"></span>


<h2 id="Ch2"><a href="#Ch2" class="headerlink" title="Ch2"></a>Ch2</h2><h3 id="能控性分解：对不完全能控的系统"><a href="#能控性分解：对不完全能控的系统" class="headerlink" title="能控性分解：对不完全能控的系统"></a>能控性分解：对不完全能控的系统</h3><p>假如有$\dot{x}&#x3D;Ax+Bu$<br>令$Q_c&#x3D;[B,AB,\cdots A^{n-1}B]$，从中取出$k$个线性无关的列$t_1,\cdots t_k$，令$T_1&#x3D;[t_1,\cdots t_k]$。再任选$n-k$个线性无关的向量$t_{k+1},\cdots, t_n$，令$T_2&#x3D;[t_{k+1},\cdots, t_n]$<br>令$T&#x3D;[T_1 ~~ T_2]$<br>则</p>
<p>$$\hat{A}&#x3D;T^{-1}AT&#x3D;<br> \begin{bmatrix}<br>   A_{11} &amp; A_{12} \\<br>   0 &amp; A_{22}<br>  \end{bmatrix}<br>$$</p>
<p>$$\hat{B}&#x3D;T^{-1}B&#x3D;<br> \begin{bmatrix}<br>   B_{1}  \\<br>   0<br>  \end{bmatrix}<br>$$</p>
<p>则对于不完全能控系统，存在非奇异线性变换$x&#x3D;T\hat{x}$，使系统按能控性分解的规范表达式为：</p>
<p>$$<br> \begin{bmatrix}\dot{x_1}  \\\dot{x_2}<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix} A_{11} &amp; A_{12}  \\ 0 &amp; A_{22}<br>\end{bmatrix} \begin{bmatrix}{x_1}  \\{x_2}<br>\end{bmatrix} + \begin{bmatrix} B_1  \\0<br>\end{bmatrix} u<br>$$<br>其中$n-k$维子系统：$\dot{x_2}&#x3D;A_{22}x_2$ 完全不能控<br>$k$维子系统$\dot{x_1}&#x3D;A_{11}x_1+A_{12}x_2+B_1u$是完全能控的。</p>
<h3 id="能控规范形：对单输入-单输出的完全能控的系统"><a href="#能控规范形：对单输入-单输出的完全能控的系统" class="headerlink" title="能控规范形：对单输入-单输出的完全能控的系统"></a>能控规范形：对单输入-单输出的完全能控的系统</h3><p>考虑完全能控的单输入-单输出系统：</p>
<p>$$\begin{matrix}<br>\dot{x}&#x3D;Ax+bu \\<br>y&#x3D;cx<br>\end{matrix}$$<br>其中$A$为$n\times n$常阵，$b,c$分别为$n\times 1 , 1 \times n$的常阵。由于系统完全能控，有$rank[b ~ Ab ~ \cdots ~ A^{n-1}b]&#x3D;n$<br>令其特征多项式为：$det(sI-A)&#x3D;\alpha(s)&#x3D;s^n+a_{n-1}s^{n-1}+ \cdots + a_1s+a_0$<br>构造变换矩阵<br>$$P&#x3D;[e_1 ~ e_2 ~ \cdots ~ e_n]&#x3D;[A^{n-1}b ~ \cdots ~ Ab ~ b]\begin{bmatrix}<br>1 &amp; &amp;   \\<br>a_{n-1} &amp; \ddots\\<br>\vdots &amp;\ddots &amp; \ddots \\<br>a_1 &amp;\cdots &amp; a_{n-1}&amp; 1\\<br>\end{bmatrix}<br>$$</p>
<p>引入非奇异线性变换$x&#x3D;P\bar{x}$，可以导出其能控规范型：</p>
<p>$$\begin{matrix}<br>\dot{\bar{x}}&#x3D;A_c\bar{x}+b_cu \\ y&#x3D;c_c\bar{x}<br>\end{matrix}$$</p>
<p>其中<br>$$A_c&#x3D;P^{-1}AP&#x3D;\begin{bmatrix}<br>0 &amp; 1&amp;   \\<br>\vdots &amp; &amp;\ddots\\<br>0 &amp; &amp; &amp; 1 \\<br>-a_0 &amp;-a_1 &amp; \cdots&amp; -a_{n-1}\\<br>\end{bmatrix},b_c&#x3D;P^{-1}b&#x3D; \begin{bmatrix}<br>0 \\<br>\vdots \\<br>0 \\<br>1 \\<br>\end{bmatrix}<br>$$<br>$$c_c&#x3D;cP&#x3D;[\beta_0 ~ \beta_1 ~ \cdots ~ \beta_{n-1}]$$</p>
<h2 id="Ch3"><a href="#Ch3" class="headerlink" title="Ch3"></a>Ch3</h2><h3 id="闭环极点配置问题"><a href="#闭环极点配置问题" class="headerlink" title="闭环极点配置问题"></a>闭环极点配置问题</h3><p>给定线性定常系统$\dot{x}&#x3D;Ax+Bu$，其中$x$为$n$维状态向量，$u$为$p$维控制向量，$A,B$分别是$n\times n, n\times p$阶常阵。再给定$n$个所期望的闭环系统的极点$\alpha_1,\cdots \alpha_n$，其中复数共轭出现。我们想确定状态反馈$u&#x3D;Kx+v$，使得所导出的闭环系统$\dot{x}&#x3D;(A+BK)x+Bv$的极点为$\alpha_1,\cdots \alpha_n$。</p>
<p>对于单输入单输出的系统来说，可以如下进行极点配置：</p>
<p>计算$A$的特征多项式$det(sI-A)&#x3D;\alpha(s)&#x3D;s^n+a_{n-1}s^{n-1}+ \cdots + a_1s+a_0$</p>
<p>计算$\alpha(s)&#x3D;(s-\alpha_1)\cdots (s-\alpha_n)&#x3D;s^n+\bar{a}_{n-1}s^{n-1}+\cdots \bar{a}_1s+\bar{a}_0$</p>
<p>计算$\hat{K} &#x3D; [a_0 - \bar{a} _0 ~ a_1 - \bar{a} _1 ~ a _{n-1} - \bar{a} _{n-1}]$</p>
<p>计算$T$以及$T^{-1}$，其中</p>
<p>$$T&#x3D;[e_1 ~ e_2 ~ \cdots ~ e_n]&#x3D;[A^{n-1}b ~ \cdots ~ Ab ~ b]\begin{bmatrix}<br>1 &amp; &amp;   \\<br>a_{n-1} &amp; \ddots\\<br>\vdots &amp;\ddots &amp; \ddots \\<br>a_1 &amp;\cdots &amp; a_{n-1}&amp; 1\\<br>\end{bmatrix}<br>$$</p>
<p>计算反馈矩阵$K&#x3D;\hat{K}T^{-1}$</p>
<h2 id="Ch4"><a href="#Ch4" class="headerlink" title="Ch4"></a>Ch4</h2><h3 id="能观性分解：对不完全能观的系统"><a href="#能观性分解：对不完全能观的系统" class="headerlink" title="能观性分解：对不完全能观的系统"></a>能观性分解：对不完全能观的系统</h3><p>考虑不完全能观的线性定常系统：<br>$$\begin{matrix}<br>\dot{x}&#x3D;Ax+Bu \\<br>y&#x3D;Cx<br>\end{matrix}$$<br>令$Q_O&#x3D;\begin{bmatrix}<br>C \\<br>CA \\<br>\vdots \\<br>CA^{n-1} \\<br>\end{bmatrix}$，选取$m$个线性无关的行$h_1,h_2,\cdots h_m$，记$H&#x3D;\begin{bmatrix}<br>h_1 \\<br>h_2 \\<br>\vdots \\<br>h_m\\<br>\end{bmatrix}$</p>
<p>再任取$n-m$个与$H_1$线性无关的行向量$h_m+1,\cdots h_m$，记$H_2&#x3D;\begin{bmatrix}<br>h_{m+1} \\<br>h_{m+2} \\<br>\vdots \\<br>h_n\\<br>\end{bmatrix}$<br>令$T&#x3D;\begin{bmatrix}<br>H_1 \\<br>H_2 \\<br>\end{bmatrix}$</p>
<p>对系统做非奇异线性变换，$x&#x3D;T^{-1}\hat{x}$，则系统可以等价的化为：<br>$$\begin{matrix}<br>\dot{\hat{x}}&#x3D;\hat{A}\hat{x}+\hat{B}u \\ y&#x3D;\hat{C}\hat{x}<br>\end{matrix}$$<br>其中$\hat{A}&#x3D;TAT^{-1}&#x3D; \begin{bmatrix}<br>A_{11} &amp; 0 \\<br>A_{21} &amp; A_{22} \\<br>\end{bmatrix},\hat{B}&#x3D;TB&#x3D;\begin{bmatrix}<br>B_1 \\<br>B_2 \\<br>\end{bmatrix},\hat{C}&#x3D;CT^{-1}&#x3D;[C_1 ~~ 0]$<br>则能观性分解的规范表达式为：<br>$$<br>\begin{matrix}<br> \begin{bmatrix}\dot{x_1}  \\\dot{x_2}<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix} A_{11} &amp; 0 \\ A_{21} &amp; A_{22}<br>\end{bmatrix} \begin{bmatrix}{x_1}  \\{x_2}<br>\end{bmatrix} + \begin{bmatrix} B_1  \\B_2<br>\end{bmatrix} u<br>\\<br>y&#x3D;\begin{bmatrix}{C_1}  &amp;{0}<br>\end{bmatrix}\begin{bmatrix}{x_1}  \\{x_2}<br>\end{bmatrix}<br>\end{matrix}<br>$$</p>
<h3 id="能观规范型：对于单输入-单输出的完全能观系统"><a href="#能观规范型：对于单输入-单输出的完全能观系统" class="headerlink" title="能观规范型：对于单输入-单输出的完全能观系统"></a>能观规范型：对于单输入-单输出的完全能观系统</h3><p>考虑完全能观的单输入-单输出系统：<br>$$\begin{matrix}<br>\dot{x}&#x3D;Ax+bu \\ y&#x3D;cx<br>\end{matrix}$$<br>其中$A$为$n\times n$常阵，$b,c$分别为$n\times 1 , 1 \times n$的常阵<br>令其特征多项式为：$det(sI-A)&#x3D;\alpha(s)&#x3D;s^n+\alpha_{n-1}s^{n-1}+ \cdots + \alpha_1s+\alpha_0$</p>
<p>构造变换矩阵<br>$$Q&#x3D;\begin{bmatrix}<br>e_1\\<br>e_2 \\<br>\vdots \\<br>e_n\\<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br>1 &amp; \alpha_{n-1} &amp; \cdots &amp; \alpha_1\\<br> &amp; \ddots &amp; \ddots &amp; \vdots\\<br>&amp; &amp; \ddots &amp; \alpha_{n-1} \\<br>&amp; &amp; &amp; 1\\<br>\end{bmatrix}\begin{bmatrix}<br>cA^{n-1}\\<br>cA^{n-2} \\<br>\vdots \\<br>c\\<br>\end{bmatrix}$$</p>
<p>则引入非奇异线性变换$\hat{x}&#x3D;Qx$，可以导出其能控规范型为：<br>$$\begin{matrix}<br>\dot{\hat{x}}&#x3D;A_O\hat{x}+b_O u \\ y&#x3D;c_O\hat{x}<br>\end{matrix}$$<br>其中$$A_O&#x3D;QAQ^{-1}&#x3D;\begin{bmatrix}<br>0 &amp; \cdots &amp; 0 &amp; -\alpha_{0}\\<br> 1 &amp;  &amp;  &amp; -\alpha_{1}\\<br>&amp; \ddots &amp; &amp;\vdots \\<br>&amp; &amp;1 &amp; -\alpha_{n-1}\\<br>\end{bmatrix},b_O&#x3D;Qb&#x3D;\begin{bmatrix}<br>\beta_0\\<br>\beta_1\\<br>\vdots \\<br>\beta_{n-1}\\<br>\end{bmatrix}C_O&#x3D;\begin{bmatrix}<br>0 &amp; \cdots &amp; 0 &amp; 1<br>\end{bmatrix}$$</p>
<h3 id="对偶性原理："><a href="#对偶性原理：" class="headerlink" title="对偶性原理："></a>对偶性原理：</h3><p>称$<br>\begin{cases}<br>\dot{x} &amp; &#x3D; &amp; A_1x+B_1u \\<br>y &amp; &#x3D; &amp; C_1x<br>\end{cases}<br>$     和      $<br>\begin{cases}<br>\dot{z} &amp; &#x3D; &amp; -A_1^Tz+C_1^Tv \\<br>w &amp; &#x3D; &amp; B_1^Tz<br>\end{cases}<br>$互为对偶</p>
<h2 id="Ch5"><a href="#Ch5" class="headerlink" title="Ch5"></a>Ch5</h2><h3 id="最小实现"><a href="#最小实现" class="headerlink" title="最小实现"></a>最小实现</h3><h4 id="单输入单输出系统的传递函数"><a href="#单输入单输出系统的传递函数" class="headerlink" title="单输入单输出系统的传递函数"></a>单输入单输出系统的传递函数</h4><p>$$G(s)&#x3D;\frac{c_{n-1}s^{n-1}+\cdots + c_1s+ c_0}{s^n+a_{n-1}s^{n-1}+\cdots + a_1s+a_0}$$</p>
<p>其中$a_i,c_i,i&#x3D;0,1,\cdots n-1$为实常数。</p>
<p>则可写出其能控型实现$$A&#x3D;\begin{bmatrix}<br>0 &amp; 1&amp;   \\<br>\vdots &amp; &amp;\ddots\\<br>0 &amp; &amp; &amp; 1 \\<br>-a_0 &amp;-a_1 &amp; \cdots&amp; -a_{n-1}\\<br>\end{bmatrix},b&#x3D; \begin{bmatrix}<br>0 \\<br>\vdots \\<br>0 \\<br>1 \\<br>\end{bmatrix},C&#x3D;\begin{bmatrix}<br>c_0 &amp; c_1 &amp; \cdots c_{n-1}<br>\end{bmatrix}$$</p>
<p>和能观型实现：<br>$$A&#x3D;\begin{bmatrix}<br>0 &amp; \cdots &amp; 0 &amp; -\alpha_{0}\\<br> 1 &amp;  &amp;  &amp; -\alpha_{1}\\<br>&amp; \ddots &amp; &amp;\vdots \\<br>&amp; &amp;1 &amp; -\alpha_{n-1}\\<br>\end{bmatrix},b&#x3D;\begin{bmatrix}<br>c_0\\<br>c_1\\<br>\vdots \\<br>c_{n-1}\\<br>\end{bmatrix},C&#x3D;\begin{bmatrix}<br>0 &amp; \cdots &amp; 0 &amp; 1<br>\end{bmatrix}$$</p>
<h4 id="单输入多输出系统："><a href="#单输入多输出系统：" class="headerlink" title="单输入多输出系统："></a>单输入多输出系统：</h4><p>传递函数矩阵$$G(s)&#x3D;\frac{C_{n-1}s^{n-1}+\cdots + C_1s+ c_0}{s^n+a_{n-1}s^{n-1}+\cdots + a_1s+a_0}$$</p>
<p>其中$a_i,i&#x3D;0,1,\cdots n-1$为实常数,$C_i,i&#x3D;0,1,\cdots n-1$为$q\times 1$实常阵。</p>
<p>可以写能控型实现：<br>$$A&#x3D;\begin{bmatrix}<br>0 &amp; 1&amp;   \\<br>\vdots &amp; &amp;\ddots\\<br>0 &amp; &amp; &amp; 1 \\<br>-a_0 &amp;-a_1 &amp; \cdots&amp; -a_{n-1}\\<br>\end{bmatrix},b&#x3D; \begin{bmatrix}<br>0 \\<br>\vdots \\<br>0 \\<br>1 \\<br>\end{bmatrix},C&#x3D;\begin{bmatrix}<br>C_0 &amp; C_1 &amp; \cdots C_{n-1}<br>\end{bmatrix}$$</p>
<p>$A,B,C$分别为$n\times n,n\times 1, q\times n$常阵</p>
<h4 id="单输出系统："><a href="#单输出系统：" class="headerlink" title="单输出系统："></a>单输出系统：</h4><p>传递函数矩阵$$G(s)&#x3D;\frac{C_{n-1}s^{n-1}+\cdots + C_1s+ c_0}{s^n+a_{n-1}s^{n-1}+\cdots + a_1s+a_0}$$</p>
<p>其中$a_i,i&#x3D;0,1,\cdots n-1$为实常数,$C_i,i&#x3D;0,1,\cdots n-1$为$1\times p$实常阵。</p>
<p>$$A&#x3D;\begin{bmatrix}<br>0 &amp; \cdots &amp; 0 &amp; -\alpha_{0}\\<br> 1 &amp;  &amp;  &amp; -\alpha_{1}\\<br>&amp; \ddots &amp; &amp;\vdots \\<br>&amp; &amp;1 &amp; -\alpha_{n-1}\\<br>\end{bmatrix},b&#x3D;\begin{bmatrix}<br>C_0\\<br>C_1\\<br>\vdots \\<br>C_{n-1}\\<br>\end{bmatrix},C&#x3D;\begin{bmatrix}<br>0 &amp; \cdots &amp; 0 &amp; 1<br>\end{bmatrix}$$</p>
<p>$A,B,C$分别为$n\times n,n\times p, 1\times n$常阵</p>
<h2 id="Ch6"><a href="#Ch6" class="headerlink" title="Ch6"></a>Ch6</h2><h3 id="全维状态观测器"><a href="#全维状态观测器" class="headerlink" title="全维状态观测器"></a>全维状态观测器</h3><p>考虑线性定常系统<br>$$\begin{matrix}<br>\dot{x}&#x3D;Ax+Bu &amp; x(0)&#x3D;x_0,t\geq 0 \\<br>y&#x3D;Cx<br>\end{matrix}$$</p>
<p>其全维状态观测器的形式为：<br>$$\begin{matrix}<br>\dot{z}&#x3D;Fz+Gy+Hu &amp; z(0)&#x3D;z_0\\<br>\hat{x}&#x3D;z<br>\end{matrix}$$<br>可以推出全维状态观测器为<font color="#dd0000"> $\dot{z}&#x3D;(A-GC)z+Gy+Bu $</font><br /></p>
<p>在全维状态观测器进行输出的动态反馈时，我们做$u&#x3D;Kz+v$<br>则作用于系统构成的闭环系统为：</p>
<p>$$ \begin{bmatrix}\dot{x}  \\\dot{z}<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix} A &amp; BK \\ GC &amp; A+GC-BK<br>\end{bmatrix} \begin{bmatrix}{x}  \\{z}<br>\end{bmatrix} + \begin{bmatrix} B  \\ B<br>\end{bmatrix} v<br>\\<br>y&#x3D;\begin{bmatrix}{C}  &amp;{0}<br>\end{bmatrix}\begin{bmatrix}{x}  \\{z}<br>\end{bmatrix}$$</p>
<p>在题中，题目会给出观测器极点$a_1,a_2,\cdots a_n$，设$G&#x3D;\begin{bmatrix} G_1  \\ G_2 \\ \vdots \\G_n<br>\end{bmatrix} $<br>则可写出$A-GC$，进而可以写出$det(sI-A+GC)$，将其和$(s-a_1)\cdots(s-a_n)$比较，可以写出$G$，进而可以求得状态观测器。</p>
<p>设计动态输出反馈时，会给出传递函数或者极点$\alpha_1,\cdots ,\alpha_n$（注意状态反馈不改变系统的零点）。设$K&#x3D;\begin{bmatrix} K_1 &amp; K_2 &amp; \cdots &amp; K_n<br>\end{bmatrix} $</p>
<p>则可求出$det(sI-(A+BK))$，将其与$(s-\alpha_1)\cdots (s-\alpha_n)$比较，可以求出$K$，进而写出动态输出反馈$$</p>
]]></content>
      <categories>
        <category>线性系统理论</category>
      </categories>
      <tags>
        <tag>线性系统理论</tag>
      </tags>
  </entry>
  <entry>
    <title>随机变量及其分布复习笔记</title>
    <url>/2022/04/23/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>随机变量及其分布复习笔记</p>
<span id="more"></span>

<h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><h3 id="什么是随机变量"><a href="#什么是随机变量" class="headerlink" title="什么是随机变量"></a>什么是随机变量</h3><p>用来表示随机现象结果的变量就是随机变量，常用大写字母$X,Y,Z$表示，而随机变量所取的值常用小写字母 $x,y,z$表示。若用等号或不等号把$X$和$x$联系起来就能表示事件，比如“$X&#x3D;x$”,“$Y\leq y$” , “$z_1&lt; Z \leq z_2$”都是事件。</p>
<p>怎么用数学语言表示？</p>
<p>$Def:$定义在样本空间$\Omega$上的实值函数$X&#x3D;X(\omega)$称为随机变量。在实数集上仅取有限个或可列个孤立点的随机变量成为离散型随机变量，可能取值在实数轴上的一个区间$(a,b)$的随机变量称为连续型随机变量，其中$a$可以是$-\infty$，$b$可以是$+\infty$。</p>
<p>可以看到，随机变量就是将样本空间上的每一个事件映射到一个实数的函数。</p>
<p>例如抛出$n(n\geq3)$枚硬币，设随机变量$X$为硬币正面朝上的次数，再设$\omega&#x3D;$朝上的硬币次数为$3$次。则我们可以令$X(\omega)&#x3D;3$。这是非常符合直觉的。</p>
<h3 id="随机变量的分布函数"><a href="#随机变量的分布函数" class="headerlink" title="随机变量的分布函数"></a>随机变量的分布函数</h3><p>$Def$：设$X$是一个随机变量，对任意实数$x$，事件$X\leq x$的概率是$x$的函数，记为：$F(x)&#x3D;P(X\leq x)$这个函数称为$X$的累积分布函数，简称分布函数。</p>
<p>分布函数的一些基本性质：<br>（1）$0\leq F(x)\leq 1$（因为$F(x)$是概率）<br>（2）$\lim\limits_{x\rightarrow -\infty} F(x)&#x3D;0$（事件$X&lt;-\infty$是不可能事件）<br>（3）$\lim\limits_{x\rightarrow +\infty} F(x)&#x3D;1$（事件$X&lt;+\infty$是必然事件）<br>（4）$F(x)$是非降函数，即对$\forall x_1&lt;x_2$，有$F(x_1)\leq F(x_2)$。这是因为事件$X\leq x_2$包含$X\leq x_1$。<br>（5）$F(x)$右连续，即$\lim\limits_{x-&gt;x_0^+}F(x)&#x3D;F(x_0)$<br>对（5）的极限成立做一个简要证明。<br>$Proof$：令$A_n&#x3D;{X \leq x_0 +  \frac{1}{n}}$，则$\bigcap\limits_{n&#x3D;1}^\infty A_n&#x3D;{X\leq x_0}$，则<br>$$\lim\limits_{x-&gt;x_0^+}F(x)&#x3D;\lim\limits_{n\rightarrow \infty}F(x_0+\frac{1}{n})&#x3D;\lim\limits_{n\rightarrow \infty}P(A_n)&#x3D;P(\lim\limits_{n\rightarrow \infty}A_n)&#x3D;P(\bigcap\limits_{n&#x3D;1}^\infty A_n)&#x3D;P(X\leq x_0)&#x3D;F(x_0)$$</p>
<p>注记：上面的推到不严谨，其中第3，4个等号需要证明，感兴趣的读者可以翻阅实变函数中的集合论部分。<br>注记2：对于上面的（3）（4）（5），需要证明极限的存在性，其中（3）（4）的极限存在性可以类似于上面的证明给出，（5）的极限存在性可以用确界定理给出。（这几部分的证明都可以去翻阅实变函数的教材）<br>注记3：分布函数并不是左连续的，反例很容易给出。</p>
<h2 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h2><h3 id="分布列"><a href="#分布列" class="headerlink" title="分布列"></a>分布列</h3><p>$Def$：设$X$是离散随机变量，它的所有可能取值为$x_1,x_2,\cdots , x_n , \cdots$，假如$X$取$x_i$的概率为：$P(X&#x3D;x_i)&#x3D;p(x_i)$，且满足<br>（1）非负性：$p(x_i)\geq 0$<br>（2）正则性：$\sum\limits_{i&#x3D;1}^\infty p(x_i)&#x3D;1$<br>则称这组概率${p(x_i)}$为随机变量$X$的分布列，或$X$的概率分布。</p>
<p>若已知$X$的分布列，则可以很容易的写出$X$的分布函数：$F(x_0)&#x3D;\sum\limits_{x_i\leq x} p(x_i)$</p>
<p>离散型随机变量的分布列还可以用如下表格来表示：</p>
<table>
<thead>
<tr>
<th>$X$</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$\cdots$</th>
<th>$x_n$</th>
<th>$\cdots$</th>
</tr>
</thead>
<tbody><tr>
<td>$P$</td>
<td>$p_1$</td>
<td>$p_2$</td>
<td>$\cdots$</td>
<td>$p_n$</td>
<td>$\cdots$</td>
</tr>
</tbody></table>
<p>除了表格，其还可以用线条图或者概率分布直方图来表示一个随机变量。</p>
<h3 id="伯努利概型中的一些分布"><a href="#伯努利概型中的一些分布" class="headerlink" title="伯努利概型中的一些分布"></a>伯努利概型中的一些分布</h3><h4 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h4><p>$Def$：令$X$为$n$重伯努利试验中成功出现的次数，则$X$是一个随机变量。用$B_{n,k}$表示$n$重伯努利试验中成功出现$k$次，则有$B_{n,k}&#x3D;$“$X&#x3D;k$”，其中$X$的可能取值为$0,1,\cdots ,n$，它取这些值的概率为：$$P(X&#x3D;k)&#x3D;C_n^k\cdot p^k\cdot (1-p)^{(n-k)},k&#x3D;0,1,\cdots ,n$$我们称这个概率分布为二项分布，记为$b(n,p)$。在概率论中“随机变量$X$的概率分布为二项分布$b(n,p)$”常被说成“随机变量$X$服从二项分布$b(n,p)$，<font color="#dd0000">记做$X\sim b(n,p)$</font>。</p>
<h4 id="两点分布"><a href="#两点分布" class="headerlink" title="两点分布"></a>两点分布</h4><p>$n&#x3D;1$的二项分布$b(1,p)$就称为两点分布（也称伯努利分布或者0-1分布）。其概率分布为：<br>$$<br>P(X&#x3D;k)&#x3D;\begin{cases}<br>p &amp; k&#x3D;1 \\<br>(1-p) &amp; k&#x3D;0<br>\end{cases}<br>$$</p>
<h4 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h4><p>我们讨论在伯努利试验中首次出现成功出现在第$k$次的概率，记成功的概率为$p$。若想第$k$次试验首次出现成功，我们需要在前$k-1$次试验中均失败，并且恰好在第$k$次试验出现成功。记$$g(k,p)&#x3D;(1-p)^{k-1}p ~~~~ k&#x3D;1,2,\cdots$$<br>我们称这个分布为几何分布</p>
<p>注记：这个分布的样本空间不是有限的。</p>
<p>注记2：几何分布具有无记忆性，即$$P(X &#x3D; s+t|X\geq s)&#x3D;\frac{P(x &#x3D;  s+t)}{P(X \geq s)}&#x3D;\frac{(1-p)^{s+t-1}\cdot p}{(1-p)^{s}} &#x3D; (1-p)^{t-1} \cdot p $$<br>这说明假定前$s$次没有出现成功，那么再经过$t$次试验成功的概率和直接进行$t$次试验成功的概率是相同的。与此同时，离散型随机变量中，只有几何分布有无记忆性。</p>
<h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>如果随机变量$X$有如下的概率分布：</p>
<p>$$P(X&#x3D;k)&#x3D;\frac{\lambda^k}{k!}e^{-\lambda}$$</p>
<p>就称$X$服从参数设$\lambda$的泊松分布。<font color="#dd0000">记做$X\sim P(\lambda)$</font>。</p>
<p>泊松分布的由来？</p>
<p>先看一个例子：<br>$eg$：某年龄段的保险者中，一年中每个人死亡的概率为$0.005$，现有$10000$个这类人参加保险，保险公司想知道在未来一年中有$40$个人死亡的概率</p>
<p>我们从二项分布可以知道$b(40;10000,0,005)&#x3D;C_{10000}^{40}(0.005)^{40}(0.995)^{9960}$（<font color="#dd0000">我们用$b(k,n,p)$表示$n$重伯努利试验中$A$出现$k$次的概率</font>）而直接计算这个数值相当困难，我们需要有更好的计算方法。</p>
<p>于是我们有泊松逼近定理：</p>
<p>$Th$：在独立试验中，以$p_n$代表事件$A$在试验中出现的概率。它与试验总数$n$有关，如果$np_n\rightarrow\lambda$，则当$n\rightarrow \infty$是，</p>
<p>$$b(k;n,p_n)\rightarrow\frac{\lambda^k}{k!}e^{-\lambda}$$</p>
<p>$Proof$：记$\lambda_n&#x3D;np_n$，则<br>$b(k;n,p_n)&#x3D;C_n^kp_n^k(1-p)^{n-k}&#x3D;\frac{n(n-1)\cdots(n-k+1)}{k!}(\frac{\lambda_n}{n})^k(1-\frac{\lambda_n}{n})^{n-k} $<br>$&#x3D;\frac{\lambda_n^k}{k!}(1-\frac{1}{n})\cdots (1-\frac{k-1}{n})(1-\frac{\lambda_n}{n})^{n-k}$</p>
<p>对于固定的$k$有<br>$$\lim\limits_{n\rightarrow\infty}\lambda_n^k&#x3D;\lambda^k，~~ \lim\limits_{n\rightarrow\infty}(1-\frac{\lambda_n}{n}^{n-k})&#x3D;e^{-\lambda}$$<br>和<br>$$\lim\limits_{n\rightarrow\infty}(1-\frac{1}{n})\cdots (1-\frac{k-1}{n})&#x3D;1$$</p>
<p>因此$$\lim\limits_{n\rightarrow\infty}b(k;n,p_n)&#x3D;\frac{\lambda^k}{k!}e^{-\lambda}$$</p>
<p>在应用中，当$p$相当小（一般当$p\leq0.1$时）我们用如下的近似公式：$$b(k;n,p)\approx\frac{(np)^k}{k!}e^{-np}$$</p>
<p>这就解决了上面二项分布不容易算的问题。</p>
<p>泊松分布发明不止是用来逼近二项分布的，我们还有如下的泊松过程：</p>
<p>考虑来到某交换装置的电话呼叫数，假定它具有下面三个性质：<br>（1）平稳性：在$[t_0,t_0+t)$中来到的呼叫数只与时间间隔长度$t$有关而与时间起点$t_0$无关。<br>（2）独立增量性：在$[t_0,t_0+t)$内来到$k$个呼叫这一事件与$t_0$之前发生的事件独立。<br>（3）普通性：在充分晓得时间间隔中，最多来一个呼叫。若记$\psi(t)&#x3D;1-P_0(t)-P_1(t)&#x3D;\sum\limits_{i&#x3D;2}^\infty P_i(t)$，则应有$\lim\limits_{t\rightarrow 0}\frac{\psi(t)}{t}&#x3D;0$</p>
<p>在这个过程中，可以求得$P_k(t)&#x3D;\frac{(\lambda t)^k}{k!}e^{-\lambda t}$，这正是泊松分布。</p>
<p>详细证明可以参考概率论教材。</p>
<h3 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h3><p>假设有$N$个产品组成的总体，其中含有$M$个不合格品，若丛中随机不放回地抽取$n$个，则其中含有不合格品的个数$X$是一个离散随机变量。假如$n\leq M$，则$X$可以取$0,1,\cdots , n$；若$n&gt;M$，则$X$可能取$0,1,\cdots M$。由古典概型可以计算得：<br>$$P(X&#x3D;x)&#x3D;\frac{C_M^xC_{N-M}^{n-x}}{C_N^n} ~~ x&#x3D;0,1,\cdots r$$<br>其中$r&#x3D;min(n,M)$。<font color="#dd0000">这个分布称为超几何分布，它有三个参数$N,M,n$，记为$h(n,N,M)$</font></p>
<h2 id="连续型随机变量"><a href="#连续型随机变量" class="headerlink" title="连续型随机变量"></a>连续型随机变量</h2><h3 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h3><p>$Def$：设$p(x)$设定义在整个实数轴上的一个函数，假如它满足如下两个性质：<br>（1）非负性：$p(x)\geq 0$<br>（2）正则性：$\int_{-\infty}^{\infty}p(x)dx&#x3D;1$<br>则称$p(x)$是概率密度函数，或密度函数。若随机变量$X$取值的统计规律性可用某个概率密度函数$p(x)$描述，则称$p(x)$为$X$的概率分布，记为$X\sim p(x)$</p>
<p>有了概率密度函数之后，随机变量$X$的分布函数就可以写成如下形式：</p>
<p>$$F(x)&#x3D;\int_{-\infty}^x p(x)dx$$</p>
<p>注记1：概率密度函数不是概率，即$P(X&#x3D;x)\neq p(x)$，事实上，对于$\forall x$,$$P(X&#x3D;x)&#x3D;\lim_{\Delta x \rightarrow 0}P(x+\Delta x)-P(x) &#x3D; \lim_{\Delta x \rightarrow 0} \int_x^{x+\Delta x}p(x)dx &#x3D; 0$$但是我们在$(x,x+\Delta x)$的概率密度可以用$\int_{x}^{x+\Delta x}p(x)dx$来求。类似的，$P(a\leq X \leq b)&#x3D;\int_{a}^{b}p(x)dx$</p>
<p>注记2：我们将概率为零的事件称为零概率事件，但是零概率小事件和不可能事件是有差距的：不可能事件一定是零概率事件，但是零概率事件不一定是不可能事件。同样的，必然事件发生的概率为1，但是发生概率为1的事件不一定是必然事件，我们一般称概率为1的事件为几乎必然发生的事件。</p>
<h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><p>$Def$：若$a,b(b&gt;a)$为有限数，则由下列函数给定的分布称为均匀分布：<br>$$<br>p(x)&#x3D;\begin{cases}<br>\frac{1}{b-a} &amp; a\leq x \leq b\\<br>0 &amp; otherwise<br>\end{cases}<br>$$</p>
<p>对应的分布函数为：<br>$$<br>F(x)&#x3D;\begin{cases}<br>0 &amp; x \leq a\\<br>\frac{x-a}{b-a} &amp; a &lt; x \leq b \\<br>1 &amp; b \leq x<br>\end{cases}<br>$$</p>
<p>注记：我们仍需令其满足分布函数的右连续性，有些课本上将第二个条件写成$a\leq x \leq b$，其实这是不严谨的。</p>
<h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><p>分布密度函数为</p>
<p>$$<br>p(x)&#x3D;\begin{cases}<br>\lambda e^{-\lambda x} &amp; x \geq 0 \\<br>0 &amp; x&lt;0<br>\end{cases}<br>$$</p>
<p>分布函数为</p>
<p>$$<br>F(x)&#x3D;\begin{cases}<br>1- e^{-\lambda x} &amp; x \geq 0 \\<br>0 &amp; x&lt;0<br>\end{cases}<br>$$</p>
<p>其中$\lambda &gt;0$，是参数，这种分布称为指数分布，简记为$Exp(\lambda)$</p>
<p>指数分布有重要的应用，我们常用它来做各种“寿命”的近似，例如电子元器件的寿命等。</p>
<p>指数分布还有类似于几何分布的无记忆性，设$X$服从指数分布，则对$\forall x&gt;0,t&gt;0$，<br>$$P\{X\geq s+t|X\geq s \} &#x3D; \frac{P\{ X\geq s+t\}}{P\{ X\geq s\}} &#x3D; \frac{e^{-\lambda(s+t)}}{e^{-\lambda s}} &#x3D; e^{-\lambda t}$$</p>
<h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p>密度函数为<br>$$p(x)&#x3D;\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}} ~~~ -\infty &lt; x &lt; \infty$$<br>其中$\sigma &gt; 0$，$\mu$和$\sigma$都为常数，相应的分布函数为<br>$$F(x)&#x3D;\int_{-\infty}^x \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(y-\mu)^2}{2\sigma^2}} ~~~ -\infty &lt; y &lt; \infty$$</p>
<p>这种分布称为正态分布，简记为$N(\mu,\sigma ^2)$</p>
<p>特别的，当$\mu&#x3D;0,\sigma&#x3D;1$的时候，这个分布称为标准正态分布，记为$N(0,1)$，相应的密度函数和概率分布函数分解记为$\phi(x)$和$\Phi(x)$</p>
<p>注记：若$X \sim N(\mu,\sigma^2)$，则$U&#x3D;\frac{X-\mu}{\sigma} \sim N(0,1)$。称这样的变换为$X$的标准化变换，称$U$为$X$的标准化随机变量。</p>
<p>注记2：设$X\sim N(\mu,\sigma^2)$，则<br>$$P(a&lt;X&lt;b)&#x3D;\Phi(\frac{b-\mu}{\sigma})-\Phi(\frac{a-\mu}{\sigma})$$</p>
<p>注记3：设$X\sim N(0,1)$，则</p>
<p>$$<br>P(|X-\mu|&lt;k\sigma)&#x3D;\begin{cases}<br>0.6826 &amp; k&#x3D;1 \\<br>0.9544 &amp; k&#x3D;2 \\<br>0.9973 &amp; k&#x3D;3<br>\end{cases}<br>$$<br>我们可以看到落在$3$倍标准差外的样本设很少的，在数据处理的时候一般将其剔除。我们称其为$3\sigma$原则。</p>
]]></content>
      <categories>
        <category>概率论</category>
        <category>随机变量及其分布</category>
      </categories>
      <tags>
        <tag>随机变量</tag>
      </tags>
  </entry>
  <entry>
    <title>经济决策技术复习</title>
    <url>/2022/11/11/%E7%BB%8F%E6%B5%8E%E5%86%B3%E7%AD%96%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>复习经济决策技术</p>
<p>参考书：经济预测与决策技术 武汉大学出版社 第六版</p>
<span id="more"></span>

<h1 id="决策学概论"><a href="#决策学概论" class="headerlink" title="决策学概论"></a>决策学概论</h1><h2 id="决策的概念及决策应遵循的基本原则："><a href="#决策的概念及决策应遵循的基本原则：" class="headerlink" title="决策的概念及决策应遵循的基本原则："></a>决策的概念及决策应遵循的基本原则：</h2><p>我们认为决策有侠义和广义之分。狭义地理解就是通常所讲的对未来事物所做的决定，仅限于对不同方案选出最佳方案；广义地理解就是把决策看作一个管理过程，是人们为了实现特定的目标，运用科学的理论与方法，系统地分析主客观条件，提出各种预选方案，从中选出最佳方案，并对最佳方案的实施进行监控，掌握决策的实施情况，强调系统的优化。</p>
<p>不管是狭义的决策还是广义的决策，都主张决策必须遵从一些基本的原则。这些原则是：</p>
<ol>
<li><p>最优化原则</p>
</li>
<li><p>系统原则</p>
</li>
<li><p>信息准全原则</p>
</li>
<li><p>可行性原则</p>
</li>
<li><p>集团决策原则</p>
</li>
</ol>
<h2 id="科学的决策程序"><a href="#科学的决策程序" class="headerlink" title="科学的决策程序"></a>科学的决策程序</h2><p>决策的步骤基本如下：</p>
<ol>
<li><p>发现决策问题</p>
</li>
<li><p>确定决策目标</p>
</li>
<li><p>指导信息搜集</p>
</li>
<li><p>确定价值标准</p>
</li>
<li><p>创建可供选择的方案</p>
</li>
<li><p>评估选择方案</p>
</li>
<li><p>选择最佳方案进行决策</p>
</li>
<li><p>方案实施，控制决策的执行情况</p>
</li>
<li><p>信息反馈，必要时实行追踪决策</p>
</li>
</ol>
<p><img src="/2022/11/11/%E7%BB%8F%E6%B5%8E%E5%86%B3%E7%AD%96%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/1.jpg"></p>
<h2 id="决策的基本类型"><a href="#决策的基本类型" class="headerlink" title="决策的基本类型"></a>决策的基本类型</h2><p>决策所要解决的以及所面临的问题是多方面的，因此，有不同类型的决策。归纳起来有以下几种类型。</p>
<ol>
<li><p>战略决策与战术决策</p>
</li>
<li><p>规范性决策和非规范性决策</p>
</li>
<li><p>单目标决策和多目标决策</p>
</li>
<li><p>个人决策和群体决策</p>
</li>
<li><p>确定型决策与非确定型决策</p>
</li>
<li><p>竞争性决策</p>
</li>
</ol>
<h1 id="非确定型决策"><a href="#非确定型决策" class="headerlink" title="非确定型决策"></a>非确定型决策</h1><h2 id="不确定型决策"><a href="#不确定型决策" class="headerlink" title="不确定型决策"></a>不确定型决策</h2><p>我们对于例子来分析每种决策</p>
<h3 id="悲观决策法和乐观决策法"><a href="#悲观决策法和乐观决策法" class="headerlink" title="悲观决策法和乐观决策法"></a>悲观决策法和乐观决策法</h3><p><img src="/2022/11/11/%E7%BB%8F%E6%B5%8E%E5%86%B3%E7%AD%96%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/2.jpg"></p>
<p>悲观决策法说的是在每种情况中取最坏的可能后再取收益最大的一种。</p>
<p>在上述例子中，三种情况最坏的收益分别为$-6,0,10$，再取最大的应该选择$D_3$</p>
<p>乐观决策法说的是在每种情况中取最好的可能后再取收益最大的一种。</p>
<p>在上述例子中，三种情况最好的收益分别为$60,30,10$，再取最大的应该选择$D_1$</p>
<h3 id="PERT决策法"><a href="#PERT决策法" class="headerlink" title="PERT决策法"></a>PERT决策法</h3><p>在策略$D_i$下，最乐观的盈利为$x_i$元，最保守的盈利为$y_i$元，最可能的盈利为$z_i$元。则期望获益的计算公式为：$$E(D_i)&#x3D;\frac{x_i+4z_i+y_i}{6}$$</p>
<p><img src="/2022/11/11/%E7%BB%8F%E6%B5%8E%E5%86%B3%E7%AD%96%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/2.jpg"></p>
<p>在上图中，设“畅销”对应于最乐观，“滞销”对应于最保守，“平销”对应着最可能，则</p>
<p>$$E(D_1)&#x3D;\frac{60+4\times 10-6}{6}&#x3D;15.7, E(D_2)&#x3D;22.66,E(D_3)&#x3D;10$$</p>
<p>取最大的即为$D_2$</p>
<h3 id="赫威兹（Hurwicz）决策法（乐观系数决策法）"><a href="#赫威兹（Hurwicz）决策法（乐观系数决策法）" class="headerlink" title="赫威兹（Hurwicz）决策法（乐观系数决策法）"></a>赫威兹（Hurwicz）决策法（乐观系数决策法）</h3><p>这种方法的基本步骤是对未来情况保持一定的乐观态度，但也不要盲目乐观，乐观程度大小以一个乐观系数$\alpha(0&lt; \alpha &lt; 1)$表示，$\alpha$越接近1，则代表越乐观。各种策略的期望收益可以按照下述公式计算：</p>
<p>$$E(D_i)&#x3D;最高获益\times \alpha + 最低获益\times (1-\alpha)$$</p>
<p><img src="/2022/11/11/%E7%BB%8F%E6%B5%8E%E5%86%B3%E7%AD%96%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/3.jpg"></p>
<p>决策准则是期望获益最大者为最优策略，上图最优策略即为$D_1$</p>
<h3 id="小中取大决策法（Wald决策准则）"><a href="#小中取大决策法（Wald决策准则）" class="headerlink" title="小中取大决策法（Wald决策准则）"></a>小中取大决策法（Wald决策准则）</h3><p>这种决策方法指导思想是，一切从最坏的情况出发去选取方案。然后，在个方案最坏的决策后果中，找出一种较好的结果。</p>
<p><img src="/2022/11/11/%E7%BB%8F%E6%B5%8E%E5%86%B3%E7%AD%96%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/2.jpg"></p>
<p>在上图中，$D_1,D_2,D_3$的最低获益是${-6,0,10}$，从中取最大的即为$10$，对应的为$D_3$</p>
<h3 id="最小最大后悔值法"><a href="#最小最大后悔值法" class="headerlink" title="最小最大后悔值法"></a>最小最大后悔值法</h3><p>就是选择让最大后悔值达到最小的方案。</p>
<p>具体步骤为：</p>
<p>（1）列出市场各种情况的最高获益。</p>
<p>（2）计算出市场各种情况的后悔值，即用各项最高收益减去该项原来的估计值。</p>
<p>（3）求出各项的最大后悔值，$D_1$对应$16$，$D_2,D_3$分别对应$30,50$，在从中选出最小的，即$D_1$对应的$16$，那么$D_1$就是最优策略。</p>
<p><img src="/2022/11/11/%E7%BB%8F%E6%B5%8E%E5%86%B3%E7%AD%96%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/2.jpg"></p>
<table>
<thead>
<tr>
<th>市场情况</th>
<th>畅销</th>
<th>平销</th>
<th>滞销</th>
</tr>
</thead>
<tbody><tr>
<td>最高获益</td>
<td>$60$</td>
<td>$25$</td>
<td>$10$</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>策略</th>
<th>畅销</th>
<th>平销</th>
<th>滞销</th>
</tr>
</thead>
<tbody><tr>
<td>$D_1$</td>
<td>$60-60&#x3D;0$</td>
<td>$25-10&#x3D;15$</td>
<td>$10-(-6)&#x3D;16$</td>
</tr>
<tr>
<td>$D_2$</td>
<td>$60-30&#x3D;30$</td>
<td>$25-25&#x3D;0$</td>
<td>$10-0&#x3D;10$</td>
</tr>
<tr>
<td>$D_3$</td>
<td>$60-10&#x3D;50$</td>
<td>$25-10&#x3D;15$</td>
<td>$10-10&#x3D;0$</td>
</tr>
</tbody></table>
<h3 id="等概率决策法"><a href="#等概率决策法" class="headerlink" title="等概率决策法"></a>等概率决策法</h3><p>我们虽然不知道每种情况的概率，但是我们把每种市场状态发生的可能性看作是完全相等的，由此导出的决策方法，成为等概率决策法。</p>
<p><img src="/2022/11/11/%E7%BB%8F%E6%B5%8E%E5%86%B3%E7%AD%96%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/2.jpg"></p>
<p>我们设畅销、平销和滞销的概率均为$1&#x2F;3$，那么可以计算出$D_1,D_2,D_3$三种情况的期望盈利</p>
<p>$$ED_1&#x3D;\frac{1}{3}\times 60 +\frac{1}{3} \times 10 + \frac{1}{3} \times (-6) \approx 22.33$$</p>
<p>$$ED_2&#x3D;\frac{1}{3} \times 30 + \frac{1}{3} \times 25 + \frac{1}{3} \times 0 \approx 18.33$$</p>
<p>$$ED_3&#x3D;\frac{1}{3} \times 10 + \frac{1}{3} \times 10 + \frac{1}{3} \times 10 &#x3D; 10$$</p>
<p>期望最大$D_1$的即为最优策略。</p>
<h2 id="风险型决策"><a href="#风险型决策" class="headerlink" title="风险型决策"></a>风险型决策</h2><h3 id="决策树技术"><a href="#决策树技术" class="headerlink" title="决策树技术"></a>决策树技术</h3><p><img src="/2022/11/11/%E7%BB%8F%E6%B5%8E%E5%86%B3%E7%AD%96%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/4.jpg"></p>
<p>上图中$(R)$代表决策点，称为树根，$(H_i),i&#x3D;1,2,\cdots , n$代表策略点。从$(R)$出发引出的$n$条线称为树枝或者策略枝。从策略点$(H_i)$引出的$m$条线，表示$m$种自然状态，出现第$j$种状态的概率计为$p_j,j&#x3D;1,2,\cdots, m$，称这$m$条线为概率枝。$v_{ij}$表示采用第$i$种策略的获利（或成本），则可计算各种策略（或方案）的期望获利（或成本），计算公式为$E(H_i)&#x3D;\sum_{i&#x3D;1}^mp_jv_{ij}$</p>
<p>由期望利益最大决策准则，得到最优策略是使${E(H_i)}$取最大值的$H_{i_0}$，即$ \max\limits_{1 \leq i \leq n} E(H_i)&#x3D;E(H_{i_0})$</p>
<p>若决策准则是期望成本最小，则最优策略是使${E(H_i)}$取最小值的$H_{i_0}$，即$ \min\limits_{1 \leq i \leq n} E(H_i)&#x3D;E(H_{i_0})$</p>
<p>例题：</p>
<p>设某企业准备生产一种新产品，在决策前估计市场状态可能有畅销$(\theta_1)$，平销$(\theta_2)$，滞销$(\theta_3)$，由历史资料统计，$P(\theta_1)&#x3D;0.35$,$P(\theta_2)&#x3D;0.3$,$P(\theta_3)&#x3D;0.35$，各种市场的盈利状态分别为20万元，2万元和-5万元。如果要做市场调查则要花0.3万元，预估的结果如表：</p>
<p><img src="/2022/11/11/%E7%BB%8F%E6%B5%8E%E5%86%B3%E7%AD%96%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/5.jpg"></p>
<p>表中$P(S|\theta)$表示实际市场状态为$\theta$的条件下，调查结果为$S$的概率。例如，$P(S_1|\theta_1)&#x3D;0.75$，表示在实际的市场状态是“畅销”，而调查结果状态为“畅销”的概率为$0.75$。但是，具有决策意义的是在调查结果为$S$的状态下，实际结果为$\theta$的概率$P(\theta |S)$。有条件概率公式得：</p>
<p>$$P(\theta |S ) &#x3D; \frac{P(\theta \cap S)}{P(S)}, ~~ P(\theta \cap S)&#x3D;P(S|\theta)P(\theta), ~~ P(S)&#x3D;\sum_{i&#x3D;1}^3P(\theta_i)P(S|\theta_i)$$</p>
<p>将表中的数据带入上述公式计算，可得到$P(\theta \cap S)$与$P(S)$的值，再可以算出$P(\theta |S)$</p>
<p><img src="/2022/11/11/%E7%BB%8F%E6%B5%8E%E5%86%B3%E7%AD%96%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/6.jpg"></p>
<p>由上述数据与已知条件，可作出决策树（绿色的为树根结点）</p>
<p><img src="/2022/11/11/%E7%BB%8F%E6%B5%8E%E5%86%B3%E7%AD%96%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/7.jpg"></p>
<h2 id="概率排序型决策"><a href="#概率排序型决策" class="headerlink" title="概率排序型决策"></a>概率排序型决策</h2><p>有若干种自然状态$S_1,S_2,\cdots , S_n$<br>概率：$p_1,p_2,\cdots , p_n$<br>后果值：$\theta_{i1},\theta_{i2},\cdots, \theta_{in}$</p>
<p>各自概率若满足$p_1 \ge p_2 \ge \cdots \ge p_n $，或者$p_j-p_{j+1} \ge 0 ~ (j&#x3D;1,2,\cdots,n-1)$，则称为概率弱排序</p>
<p>若能确定$M_j \ge 0 $，使得$p_j-p_{j+1} \ge M_j$，且至少有一个$M_j$大于$0$，则我们称为概率严排序。</p>
<p>在这种排序下，我们可以求出期望后果值的最大值与最小值，并以此作为决策的依据。</p>
<h3 id="概率弱排序决策"><a href="#概率弱排序决策" class="headerlink" title="概率弱排序决策"></a>概率弱排序决策</h3><p>假设对于某个方案$A$，它在自然状态$S_j$下的后果值为$\theta_j$，于是，该方案的期望收益为$\sum\limits_j p_j\theta_j$，求解该方案的期望的最大&#x2F;最小后果就可以转化为如下的线性规划问题：</p>
<p>$$<br>\begin{cases}<br>\min or \max &amp; E(A)&#x3D;\sum\limits_j p_j\theta_j  \\<br>s.t. &amp; p_j - p_{j+1} \ge 0 \\<br>     &amp; \sum\limits_j p_j &#x3D; 1 \\<br>     &amp; p_j \ge 0<br>\end{cases}<br>$$</p>
<p>令</p>
<p>$$q_j &#x3D; p_j - p_{j+1} , j&#x3D;1,2,\cdots n-1, q_n &#x3D; p_n$$</p>
<p>$$y_j &#x3D; \sum_{k&#x3D;1}^{j}\theta_j$$</p>
<p>则线性规划可以转化为：</p>
<p>$$<br>\begin{cases}<br>\min or \max &amp; E(A)&#x3D;\sum\limits_j q_jy_j  \\<br>s.t. &amp; \sum\limits_j jq_j &#x3D; 1 \\<br>     &amp; q_j \ge 0<br>\end{cases}<br>$$</p>
<p>该问题的基解为某个$q_k$为非零，其余$q_j$均非零。那么有$q_k &#x3D; \frac{1}{k}$</p>
<p>$$E(A)&#x3D;\frac{y_k}{k}&#x3D;\frac{\theta_1 + \theta_2 + \cdots + \theta_k}{k} &#x3D; \bar{\theta_k}$$</p>
<p>求出$\bar{\theta_k}$的最小、最大值即可。</p>
<p>例子：</p>
<p>某物品销售量和概率排序如下：</p>
<img src=17.jpg width="50%">

<img src=18.jpg width="20%">

<p>按照概率排序后，我们有</p>
<img src=16.jpg width="50%">

<p>对于$A_1$，我们可以算出</p>
<p>$\bar{\theta_1}&#x3D;\frac{40}{1} &#x3D; 40$</p>
<p>$\bar{\theta_2}&#x3D;\frac{40+(-2)}{2} &#x3D; 19$</p>
<p>$\bar{\theta_3}&#x3D;\frac{40+(-2)+85}{3} &#x3D; 41$</p>
<p>$\bar{\theta_4}&#x3D;\frac{40+(-2)+85+(-43)}{4} &#x3D; 20$</p>
<p>同理可以算出其他结果如图：</p>
<table>
<thead>
<tr>
<th>方案&#x2F;销量</th>
<th>$\bar{\theta_1}$</th>
<th>$\bar{\theta_2}$</th>
<th>$\bar{\theta_3}$</th>
<th>$\bar{\theta_4} $</th>
<th>概率弱排序下的$\max E(A) , \min E(A)$</th>
</tr>
</thead>
<tbody><tr>
<td>$A_1$</td>
<td>$40$</td>
<td>$19$</td>
<td>$41$</td>
<td>$20$</td>
<td>$41,19$</td>
</tr>
<tr>
<td>$A_2$</td>
<td>$37$</td>
<td>$24$</td>
<td>$34$</td>
<td>$22$</td>
<td>$37,22$</td>
</tr>
<tr>
<td>$A_3$</td>
<td>$24$</td>
<td>$18$</td>
<td>$20$</td>
<td>$15$</td>
<td>$24,15$</td>
</tr>
</tbody></table>
<h3 id="概率严排序决策"><a href="#概率严排序决策" class="headerlink" title="概率严排序决策"></a>概率严排序决策</h3><p>线性规划可变为：</p>
<p>$$<br>\begin{cases}<br>\min or \max &amp; E(A)&#x3D;\sum\limits_j p_j\theta_j  \\<br>s.t. &amp; p_j - p_{j+1} \ge M_j \\<br>     &amp; \sum\limits_j p_j &#x3D; 1 \\<br>     &amp; p_j \ge 0<br>\end{cases}<br>$$</p>
<p>做变换</p>
<p>$$r_j &#x3D;  p_j - p_{j+1} -M_j , j&#x3D;1,2,\cdots , n-1 , ~ r_n &#x3D; p_n$$</p>
<p>$$y_j &#x3D; \sum_{k&#x3D;1}^{j}\theta_j$$</p>
<p>$$C&#x3D;\sum_j M_jy_j, ~~ D &#x3D; \sum_j jM_j $$</p>
<p>则规划可以转化为</p>
<p>$$<br>\begin{cases}<br>\min or \max &amp; E(A)&#x3D;\frac{1-D}{k}y_k + C  \\<br>s.t. &amp; \sum\limits_j jr_j &#x3D; 1 - D \\<br>     &amp; r_j \ge 0<br>\end{cases}<br>$$</p>
<p>可以推出</p>
<p>$$\min ~~ (\max) ~~ E(A)(严)&#x3D; (1-D) \min ~~ (\max) ~~ E(A)(弱) + C$$</p>
<p>仍用上例，给出概率严排序$p_1 - p_2 \ge 0.15 , ~~ p_2 - p_3 \ge 0.3 , ~~ p_3 - p_4 \ge 0$，即$M_1 &#x3D; 0.15,M_2 &#x3D; 0.3, M_3 &#x3D;0 $</p>
<p>对于方案$A_1$可以算出</p>
<p>$$C&#x3D;M_1y_1 + M_2y_2 + M_3y_3 &#x3D; 40 \times 0.15 + 38 \times 0.3 + 123 \times 0 &#x3D; 17.4$$</p>
<p>$$D&#x3D;M_1 + 2M_2 + 3M_3 &#x3D; 0.15 + 2\times 0.3 + 3 \times 0 &#x3D; 0.75$$</p>
<p>$$\bar{\theta_1}&#x3D; 40, \bar{\theta_2}&#x3D; 19, \bar{\theta_3}&#x3D; 41, \bar{\theta_4}&#x3D; 20$$</p>
<p>进而</p>
<p>$$(1-D)\bar{\theta_1}+C &#x3D; 0.25 \times 40 + 17.4 &#x3D; 27.4$$</p>
<p>$$(1-D)\bar{\theta_2}+C &#x3D; 0.25 \times 19 + 17.4 &#x3D; 22.15$$</p>
<p>$$(1-D)\bar{\theta_3}+C &#x3D; 0.25 \times 41 + 17.4 &#x3D; 27.65$$</p>
<p>$$(1-D)\bar{\theta_4}+C &#x3D; 0.25 \times 20 + 17.4 &#x3D; 22.4$$</p>
<p>可以看出在概率严排序下：$\max E(A)&#x3D;27.65 , \min E(A) &#x3D; 22.15$</p>
<table>
<thead>
<tr>
<th>方案&#x2F;销量</th>
<th>$\bar{\theta_1}$</th>
<th>$\bar{\theta_2}$</th>
<th>$\bar{\theta_3}$</th>
<th>$\bar{\theta_4} $</th>
<th>概率严排序下的$\max E(A) , \min E(A)$</th>
</tr>
</thead>
<tbody><tr>
<td>$A_1$</td>
<td>$40$</td>
<td>$19$</td>
<td>$41$</td>
<td>$20$</td>
<td>$27.65,22.15$</td>
</tr>
<tr>
<td>$A_2$</td>
<td>$37$</td>
<td>$24$</td>
<td>$34$</td>
<td>$22$</td>
<td>$29.2, 25.45$</td>
</tr>
<tr>
<td>$A_3$</td>
<td>$24$</td>
<td>$18$</td>
<td>$20$</td>
<td>$15$</td>
<td>$20.4,18.15$</td>
</tr>
</tbody></table>
<h3 id="利用期望值极值进行决策"><a href="#利用期望值极值进行决策" class="headerlink" title="利用期望值极值进行决策"></a>利用期望值极值进行决策</h3><p>从$A_1$与$A_2$进行比较来看，从非确定型，到概率弱排序，再到概率严排序，我们得到的信息值越来越多，也可以发现$A_1$的优势越来越不明显。最后到概率严排序时，$A_2$的优势已经高于$A_1$。</p>
<h3 id="优势条件"><a href="#优势条件" class="headerlink" title="优势条件"></a>优势条件</h3><h4 id="严优势条件"><a href="#严优势条件" class="headerlink" title="严优势条件"></a>严优势条件</h4><p>$E(A_1)&gt;E(A_2)$的充要条件是$\min E(A_1-A_2)&gt;0$</p>
<p>令$D_1&#x3D;A_1-A_2,D_2 &#x3D; A_2-A_3,D_3 &#x3D; A_1-A_3$，</p>
<img src=16.jpg width="50%">

<p>计算出结果如下：</p>
<img src=19.jpg width="50%">

<p>可以看出$\min E(D_2) &lt; 0 , ~~ \min E(D_3) &lt; 0$，所以方案$A_2,A_1$对方案3都有严优势</p>
<p>另外，$\max E(D_1) &lt; 0$，所以$\min E(A_2 - A_1) &#x3D; -\max E(D_2) &gt;0$</p>
<p>因此在概率严排序的规则下，$A_2对A_1$也有严优势。</p>
<p>最优方案即为$A_2$</p>
<h4 id="弱优势条件"><a href="#弱优势条件" class="headerlink" title="弱优势条件"></a>弱优势条件</h4><p>对于方案$D&#x3D;A_1-A_2$和$D’&#x3D;A_2-A_1$</p>
<p>若$\max E(D) &gt; \max E(D”)$，则称方案$A_1$对方案$A_2$有弱优势。</p>
<p>例子</p>
<img src=20.jpg width="50%">

<p>方案$A_i$相对于其他两个方案的优势程度为：</p>
<p>$$\sum_{j\ne i}(\max E(A_i-A_j)+\min E(A_i-A_j))$$</p>
<p>则方案$A$的优势程度为：<br>$\max E(A-B) + \min E(A-B) + \max E(A-C) + \min E(A-C) &#x3D; 8+(-2)+5+(-6)&#x3D;5$</p>
<p>同理可算出方案$B$的优势程度为$-4$，方案$C$的优势程度为$-1$</p>
<h2 id="马尔可夫决策"><a href="#马尔可夫决策" class="headerlink" title="马尔可夫决策"></a>马尔可夫决策</h2><p>没讲</p>
<h1 id="效用理论及其在决策中的应用"><a href="#效用理论及其在决策中的应用" class="headerlink" title="效用理论及其在决策中的应用"></a>效用理论及其在决策中的应用</h1><h2 id="效用的概念"><a href="#效用的概念" class="headerlink" title="效用的概念"></a>效用的概念</h2><p>设$C$表示决策者选择某一方案后，其产生的后果所构成的集合，集合的元素用$C_1,C_2,\cdots,C_n$表示，$p_i$是$C_i$发生的概率，$i&#x3D;1,2,\cdots,n$，且$\sum\limits_{i&#x3D;1}^n p_i&#x3D;1$。以$P$表示后果的概率分布，并记$P&#x3D;(p_1,C_1;p_2,C_2;\cdots;p_n,C_n)$，称为展望。所有展望构成的集合，称为展望集，用$\mathscr{F}$表示。$\mathscr{F}$中的各个元素之间有优先关系，例如$P_1$优于$P_2$，$P_2$优于$P_3$，这种优先关系记为：$P_1 \succ P_2 \succ P_3$。还有一种关系，称为优于或无差异于关系，记为$P_1 \succeq P_2$。若$P_1 \sim P_2$则称$P_1$与$P_2$无差异。</p>
<p>定义：设$u$是定义在集合$\mathscr{F}$上的实值函数，如$u$满足下述两个条件：</p>
<p>1.函数$u$在$\mathscr{F}$上的“优于或无差异于”一致，也就是说：</p>
<center>对于任意$P_1,P_2\in \mathscr{F}$，当且仅当$u(P_1)\geq u(p_2)$时，有$P_1 \succeq P_2$</center>

<p>2.$u$在$\mathscr{F}$上是线性函数，即若$p_1,p_2 \in\mathscr{F}, 0\leq \lambda \leq 1$，有$$u(\lambda P_1+(1-\lambda ) P_2)&#x3D;\lambda u(P_1) + (1-\lambda )u(P_2)$$</p>
<p>则称$u$是定义在$\mathscr{F}$上的效用函数。此定义可推广到更一般的情况，即若$P_i \in \mathscr{F}$，且$\lambda_i \geq 0,i&#x3D;1,2,\cdots,m , \sum\limits_{i&#x3D;1}^m \lambda_i&#x3D;1$，则有<br>$$u(\sum\limits_{i&#x3D;1}^m\lambda_i P_i)&#x3D;\sum\limits_{i&#x3D;1}^m \lambda_i u(P_i)$$</p>
<h2 id="效用测定及效用曲线的制作"><a href="#效用测定及效用曲线的制作" class="headerlink" title="效用测定及效用曲线的制作"></a>效用测定及效用曲线的制作</h2><p>可以采用心理试验的方法打通过问答形式画出效用曲线，具体步骤如下：</p>
<p>1.确定效用的尺度范围</p>
<p>假定决策者有一幸运机会，可自由选择两周收入方案之一：</p>
<p>方案A:以0.5的概率得到300元，0.5的概率得到0元</p>
<p>方案B:稳拿50元</p>
<p>在这两个方案面前，决策者的最大收益是得到$300$元，效用最大，故取$u(300)&#x3D;1$，最小的收益为$0$元，效用最小，故取$u(0)&#x3D;0$</p>
<p>第二步：确定0元和300元中间的一个效用值，并对决策者进行问答，以测定决策者对不同方案的反应。</p>
<p>问：你认为方案B比方案A更稳妥吗？<br>答：是<br>这说明$50$元的效用值大于方案$A$的效用值，即$u(50)&gt;u(A)$</p>
<p>将方案$A$改为以0.7的概率得300元，以0.3的概率的0元，其余不变。<br>问：你还愿意选$B$吗？<br>答：愿意<br>这说明$50$元的效用值仍大于方案$A$的效用值</p>
<p>再将方案$A$改为以0.8的概率得300元，0.2的概率获得0元，方案B不变。<br>问：你选择A还是B<br>答：无所谓</p>
<p>这说明$A$，$B$是等效用的，即$u(50)&#x3D;u(A)$，而方案$A$的期望效用值为$0.8\times u(300)+0.2 \times u(0) &#x3D; 0.8$，所以$u(50)&#x3D;0.8$</p>
<p>第三步：确定50元与300元之间的一个点的效用值，假定确定了$u(100)&#x3D;0.94$</p>
<p>第四步：确定0元与50元之间一个点的效用函数值，假定确定了$u(20)&#x3D;0.56$</p>
<p>这样我们有5个点的效用函数值，分别为$u(0)&#x3D;0,u(20)&#x3D;0.56,u(50)&#x3D;0.8,u(100)&#x3D;0.94,u(300)&#x3D;1$</p>
<p>可以绘出如下曲线：</p>
<img src=8.jpg width="50%">

<h2 id="效用曲线的分类即效用决策准则"><a href="#效用曲线的分类即效用决策准则" class="headerlink" title="效用曲线的分类即效用决策准则"></a>效用曲线的分类即效用决策准则</h2><img src=9.jpg width="50%">

<p>效用曲线的类型一般分为三种：</p>
<p>A类效用曲线，是一种保守型效用曲线，它表示决策者对货币收入的态度是，效用值随货币收入的增加而递增，但其实递增的速度越来越慢。这类决策者对损失较为敏感，而对收益的迅速增加，则反应比较迟缓，是一种不求大利，但求稳妥，小心谨慎，避免风险的风险厌恶者。这种效用曲线的特点是呈上凸型。</p>
<p>B类效用曲线，是一种风险中立者的效用曲线。他的决策准则就是期望收益最大。其曲线的特点是呈上升直线。</p>
<p>C类效用曲线，是一种冒险型的效用曲线，表示决策者在随着货币收益增加，其效用值也跟着递增，而且递增的速度越来越快。这种效用曲线的特点是呈下凸型。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>某公司准备经营某类商品，拟定了三种经营方案，未来市场有畅销、平销和滞销三种可能，市场状态和各方案的损益值如表所示。试用效用准则求出最优方案。求解步骤如下：</p>
<img src=10.jpg width="50%">

<p>step1: 根据3.2的方法，做出决策者的效用曲线如下：</p>
<table>
<thead>
<tr>
<th>损益值</th>
<th>-10</th>
<th>-2</th>
<th>3</th>
<th>4</th>
<th>6</th>
<th>8</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>效用值</td>
<td>0</td>
<td>0.66</td>
<td>0.85</td>
<td>0.88</td>
<td>0.94</td>
<td>0.97</td>
<td>1.0</td>
</tr>
</tbody></table>
<p>step2: 根据上表中的数据，分别计算A、B、C的期望效用值，得到：</p>
<p>方案A的期望效用值为$u(12)\times 0.3 + u(6)\times 0.5 + u(-10)\times 0.2 &#x3D; 0.77$</p>
<p>方案B的期望效用值为$u(8)\times 0.3 + u(3)\times 0.5 + u(-2)\times 0.2 &#x3D; 0.85$</p>
<p>方案C的期望效用值为$u(4)\times (0.3+0.5+0.2) &#x3D; 0.88$</p>
<p>step3:运用决策树技术进行决策，从右往左计算出各方案的期望效用值，并填入圆圈内，再进行比较，即选择效用最大的方案作为最优方案。本例中方案C为最优方案。</p>
<img src=11.jpg width="50%">


<h1 id="对策论原理及其应用"><a href="#对策论原理及其应用" class="headerlink" title="对策论原理及其应用"></a>对策论原理及其应用</h1><h2 id="对策论基本概念"><a href="#对策论基本概念" class="headerlink" title="对策论基本概念"></a>对策论基本概念</h2><p>局中人，策略集，支付函数</p>
<p>一般用$G&#x3D;\{I,S,P\}$表示，其中$I$为局中人集合，$S$为策略空间，$P$代表支付函数。</p>
<p>若$S^*&#x3D;(S_1^*,S_2^*,\cdots,S_n^*)\in S$，能使 $P(S_1^*,S_2^*,\cdots,S_n^*)$ 满足某种性质和条件，则称$S^*$为$G&#x3D;\{I,S,P\}$在此意义的均衡解，称$S^*$为$S$中的一个均衡点，并称 $P(S_1^*,S_2^*,\cdots,S_n^*)$ 为相应的均衡支付。</p>
<h2 id="矩阵对策"><a href="#矩阵对策" class="headerlink" title="矩阵对策"></a>矩阵对策</h2><p>两人有限零和对策</p>
<h3 id="有鞍点的对策"><a href="#有鞍点的对策" class="headerlink" title="有鞍点的对策"></a>有鞍点的对策</h3><p>局中人有两个，记为$A,B$，$A$有$m$中策略，用$\alpha_1,\alpha_2,\cdots, \alpha_m$表示，$B$有$n$中策略，用$\beta_1,\beta_2,\cdots , \beta_n$表示。以$S_1$代表$A$的策略集，$S_2$代表$B$的策略集，$(\alpha_i,\beta_j)$构成局势，局势集合用$S$表示。</p>
<p>局中人$A$的支付矩阵记为$p_{ij}$，则矩阵</p>
<p>$$<br> P&#x3D;<br>    \left(<br>    \begin{matrix}<br>    p_{11} &amp; p_{12} &amp; \cdots &amp; p_{1n} \\<br>    p_{21} &amp; p_{22} &amp; \cdots &amp; p_{2n} \\<br>    \vdots &amp; \vdots &amp; &amp; \vdots \\<br>    p_{m1} &amp; p_{m2} &amp; \cdots &amp; p_{mn} \\<br>    \end{matrix}<br>    \right)<br>$$</p>
<p>记$I&#x3D;\{A,B\},S&#x3D;\{S_1,S_2\}$</p>
<p>则$G&#x3D;\{I,S,P\}$构成矩阵对策模型。</p>
<p>局中人$A$的最稳妥策略为$\max\limits_{i}\min\limits_{j} p_{ij}$</p>
<p>局中人$B$的最稳妥策略为$\min\limits_{j}\max\limits_{i} p_{ij}$</p>
<p>若其有鞍点，则满足$\max\limits_{i}\min\limits_{j} p_{ij}&#x3D;\min\limits_{j}\max\limits_{i} p_{ij}$</p>
<h3 id="无鞍点的对策"><a href="#无鞍点的对策" class="headerlink" title="无鞍点的对策"></a>无鞍点的对策</h3><p>混合扩充，可以用线性规划求解。</p>
<p>局中人$A$对应的线性规划为</p>
<p>$<br>\begin{cases}<br>\min &amp; \sum\limits_{i&#x3D;1}^m x_i  \\<br>s.t. &amp; \sum\limits_{i&#x3D;1}^m p_{ij}x_i \geq 1 , ~~ j&#x3D;1,2,\cdots , n \\<br>     &amp; x_i \geq 0 , ~~~~~ i&#x3D;1,2,\cdots,m \\<br>\end{cases}<br>$</p>
<p>局中人$B$对应的线性规划为</p>
<p>$<br>\begin{cases}<br>\max &amp; \sum\limits_{j&#x3D;1}^n y_j  \\<br>s.t. &amp; \sum\limits_{j&#x3D;1}^n p_{ij}y_j \leq 1 , ~~ i&#x3D;1,2,\cdots,m \\<br>     &amp; y_j \geq 0 , ~~~~~ j&#x3D;1,2,\cdots , n  \\<br>\end{cases}<br>$</p>
<p>并且设$\frac{1}{V}&#x3D;\sum\limits_{i&#x3D;1}^m x_i &#x3D; \sum\limits_{j&#x3D;1}^n y_j$，则 $X^* &#x3D; V(x_1,x_2,\cdots, x_m), Y^* &#x3D; V(y_1,y_2,\cdots , y_n)$是矩阵对策$\Gamma&#x3D;\{S_1,S_2;A\}$的平衡局势，$V$是$\Gamma$的值。</p>
<p>eg:给出矩阵对策的支付矩阵为</p>
<p>$$<br> P&#x3D; \begin{pmatrix}<br>   1 &amp; 3 &amp; 3 \\<br>   4 &amp; 2 &amp; 1 \\<br>   3 &amp; 2 &amp; 2<br>  \end{pmatrix}<br>$$</p>
<p>求最优策略和值</p>
<p>可以写出两个线性规划：</p>
<p>$<br>\begin{cases}<br>\min &amp; z&#x3D;x_1+x_2+x_3 \\<br>s.t. &amp; x_1+4x_2+3x_3\geq 1 \\<br>     &amp; 3x_1+2x_2+2x_3 \geq 1 \\<br>     &amp; 3x_1+x_2+2x_3 \geq 1 \\<br>     &amp; x_1,x_2,x_3 \geq 0<br>\end{cases}<br>$</p>
<p>$<br>\begin{cases}<br>\max &amp; w&#x3D;y_1+y_2+y_3 \\<br>s.t. &amp; y_1+3y_2+3y_3 \leq 1 \\<br>     &amp; 4y_1+2y_2+y_3 \leq 1 \\<br>     &amp; 3y_1+2y_2+2y_3 \leq 1 \\<br>     &amp; y_1,y_2,y_3 \geq 0<br>\end{cases}<br>$</p>
<p>解这对对偶规划，得到最优解：$X&#x3D;(\frac{1}{7},0,\frac{2}{7}),~ Y&#x3D;(\frac{1}{7},\frac{1}{7},\frac{1}{7}),~ V&#x3D;\frac{7}{3}$</p>
<p>则$X^*&#x3D;(\frac{1}{3},0,\frac{2}{3}), ~ Y^*&#x3D;(\frac{1}{3},\frac{1}{3},\frac{1}{3})$</p>
<h3 id="2-times-n-或-m-times-2-类型的矩阵对策平衡局势的求法"><a href="#2-times-n-或-m-times-2-类型的矩阵对策平衡局势的求法" class="headerlink" title="$2\times n $ 或 $m \times 2$类型的矩阵对策平衡局势的求法"></a>$2\times n $ 或 $m \times 2$类型的矩阵对策平衡局势的求法</h3><h4 id="2-times-n-类型的矩阵对策"><a href="#2-times-n-类型的矩阵对策" class="headerlink" title="$2\times n$类型的矩阵对策"></a>$2\times n$类型的矩阵对策</h4><p>Step1: 平面直角坐标系中做两条直线：$I:x&#x3D;0$以及$II:x&#x3D;1$</p>
<p>Step2: 在直线$I$处按照第二行矩阵的值标纵坐标，在直线$II$处按矩阵第一行的值标纵坐标；其意义是当局中人一采用某种纯策略时，局中人二各策略的赢得值。</p>
<p>Step3: 按列的方向将各对应纵坐标连成直线。</p>
<p>Step4: 令$0&lt;x&lt;1$，即局中人一采用混合策略时，找出线段中最小的纵坐标的若干条形成的折线，再在此折线上取最大值即可。</p>
<p>Step5: 通过交点确定$X^*$</p>
<p>Step6: 通过互补松紧条件确定$Y^*$</p>
<p>eg:求下面矩阵对策的平衡局势<br>$$<br> P&#x3D; \begin{pmatrix}<br>   2 &amp; 3 &amp; 11 \\<br>   7 &amp; 5 &amp; 2<br>  \end{pmatrix}<br>$$</p>
<img src=12.jpg width="50%">

<p>作图如上，可以列方程组：</p>
<p>$<br>\begin{cases}<br> 11x+2(1-x)&#x3D;V \\<br> 3x+5(1-x)&#x3D;V \\<br>\end{cases}<br>$</p>
<p>解得$x&#x3D;\frac{3}{11}$</p>
<p>则$X^*&#x3D;(\frac{3}{11},\frac{8}{11})$</p>
<p>再来求解$Y$，可以列出方程组</p>
<p>$<br>\begin{cases}<br> 2y_1^*+3y_2^*+11y_3^*&#x3D;V \\<br> 7y_1^*+5y_2^*+2y_3^*&#x3D;V \\<br> y_1^*+y_2^*+y_3^*&#x3D;1<br>\end{cases}<br>$</p>
<p>由互补松紧条件知$y_1^*&#x3D;0$，则可求解出$y_2^*&#x3D;\frac{9}{11},y_3^*&#x3D;\frac{2}{11}$</p>
<h4 id="m-times-2-类型的矩阵对策"><a href="#m-times-2-类型的矩阵对策" class="headerlink" title="$m\times 2$类型的矩阵对策"></a>$m\times 2$类型的矩阵对策</h4><p>与上面类似，</p>
<p>Step1: 平面直角坐标系中做两条直线：$I:y&#x3D;0$以及$II:y&#x3D;1$</p>
<p>Step2: 在直线$I$处按照第二列矩阵的值标纵坐标，在直线$II$处按矩阵第一列的值标纵坐标；其意义是当局中人二采用某种纯策略时，局中人一各策略的赢得值。</p>
<p>Step3: 按行的方向将各对应纵坐标连成直线。</p>
<p>Step4: 令$0&lt;x&lt;1$，即局中人二采用混合策略时，找出线段中最大的纵坐标的若干条形成的折线，再在此折线上取最小值即可。</p>
<p>Step5: 通过交点确定$Y^*$</p>
<p>Step6: 通过互补松紧条件确定$X^*$</p>
<p>eg:求下面矩阵对策的平衡局势<br>$$<br> P&#x3D; \begin{pmatrix}<br>   2 &amp; 7  \\<br>   6 &amp; 6 \\<br>   11 &amp; 2<br>  \end{pmatrix}<br>$$</p>
<img src=13.jpg width="50%">

<p>作图如上，按照和上例类似的方法即可求出平衡局势。</p>
<h3 id="连续对策"><a href="#连续对策" class="headerlink" title="连续对策"></a>连续对策</h3><p><font color="#dd0000">待更</font><br /> </p>
<h1 id="随机型需求的投资项目决策"><a href="#随机型需求的投资项目决策" class="headerlink" title="随机型需求的投资项目决策"></a>随机型需求的投资项目决策</h1><h2 id="项目选择准则"><a href="#项目选择准则" class="headerlink" title="项目选择准则"></a>项目选择准则</h2><p>在正态需求的情况下，对互斥方案的择优标准是什么？我们提出以下几条供决策者参考。</p>
<ol>
<li>盈利的可能性要有较大的把握，即盈利在99%以上</li>
<li>企业经营实现最低成本的可能性最大</li>
<li>期望成本最低</li>
<li>期望利润最大<br>以上四条可归结为成本和利润两个方面。此外，还要考虑设备利用率和满足市场需求方面的参考标准，这就是：</li>
<li>设备利用率在80%以上的可能性不低于75%</li>
<li>满足客户需求的可能性在80%以上。</li>
</ol>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>现通过一实例，给出一个互斥的项目建设方案的具体选优决策方法。</p>
<p><font color="#660066">假设某种产品的需求服从正态分布，其平均需求量为120万件，标准差为20万件，单件售价20万元。</p>
<p>方案甲：固定成本为400万元，使用自动化装置，年最大生产能力为130万件，每件可变成本为11.5元，规模属中等。</p>
<p>方案乙：固定成本为200万元，不采用自动化装置，年最大生产能力为100万件，每件可变成本为15元，属于小型规模</p>
<p>方案丙：采用高度自动化装置，固定成本为600万元，年最大生产能力为160万件，每件可变成本为10元，属于大型规模。</font><br /> </p>
<p>在最优化的准则下，怎么求出最优的建设方案？一下是可以采取的具体方法：</p>
<p>进行线性盈亏分析。设</p>
<p><font color="#dd0000">$Q$为产量，$TR$为总收益，$TC$为总成本，$F$为固定资本，$C_v$为可变成本，$p$为单件售价</font><br /> </p>
<p>总收益$TR&#x3D;pQ$</p>
<p>总成本$TC&#x3D;F+C_vQ$</p>
<p>可以算出盈亏平衡点的产量：</p>
<p>$<br>\begin{cases}<br> Q_甲^*&#x3D;\frac{400}{20-11.5}&#x3D;47.06 ~~ (万件) \\<br> Q_乙^*&#x3D;\frac{200}{20-15}&#x3D;40 ~~ (万件) \\<br> Q_丙^*&#x3D;\frac{600}{20-10}&#x3D;60 ~~ (万件)<br>\end{cases}<br>$</p>
<p>由上述计算，可得到$Q_乙^*&lt;Q_甲^*&lt;Q_丙^*$</p>
<p>企业乙有较低的盈亏平衡点。但是，他开始盈利之后，利润增长的速度比甲、丙都慢。</p>
<p>企业丙有较高的固定成本，因而盈亏平衡点比甲、乙都高。但是其一旦超过盈亏平衡点，利润将迅速增加。</p>
<p>企业甲则处于乙、丙之间。</p>
<p>可见，上述方案各有利弊，下面将从本实例继续展开分析。</p>
<h2 id="盈利可能性计算"><a href="#盈利可能性计算" class="headerlink" title="盈利可能性计算"></a>盈利可能性计算</h2><p>设$p(Q)$为需求量$Q$的概率密度，则有概率密度函数</p>
<p>$$p(Q)&#x3D;\frac{1}{20\sqrt{2\pi}}e^{-\frac{1}{2}(\frac{Q-120}{20})^2}$$</p>
<h3 id="盈利的可能性"><a href="#盈利的可能性" class="headerlink" title="盈利的可能性"></a>盈利的可能性</h3><p>方案甲：$P(Q&gt;Q_甲^*)&#x3D;P(Q&gt;47)&#x3D;\int_{47}^{\infty}p(Q)dQ&#x3D;99.95\%$</p>
<p>方案乙：$P(Q&gt;Q_乙^*)&#x3D;P(Q&gt;40)&#x3D;\int_{40}^{\infty}p(Q)dQ&#x3D;99.99\%$</p>
<p>方案丙：$P(Q&gt;Q_丙^*)&#x3D;P(Q&gt;60)&#x3D;\int_{60}^{\infty}p(Q)dQ&#x3D;99.86\%$</p>
<h3 id="盈利300万元以上的可能性计算"><a href="#盈利300万元以上的可能性计算" class="headerlink" title="盈利300万元以上的可能性计算"></a>盈利300万元以上的可能性计算</h3><p>首先求出相应的产量公式</p>
<p>$20Q-F-C_vQ &gt; 300 \Rightarrow Q &gt; \frac{300+F}{20-C_v}$</p>
<p>从而盈利300万元以上的可能性为：$P(Q&gt;\frac{300+F}{20-C_v})&#x3D;\int_{\frac{300+F}{20-C_v}}^{+\infty}p(Q)dQ$</p>
<p>可以算出以下各概率</p>
<p>方案甲：$P(Q&gt;\frac{300+400}{20-11.5})&#x3D;\int_{82.35}^{+\infty}p(Q)dQ&#x3D;97\%$</p>
<p>方案乙：盈利300万元以上，其产量$Q$至少应为100万件，但是方案乙的最大产量仅为100万件，故盈利300万元以上的概率为0。</p>
<p>方案丙：$P(Q&gt;\frac{300+600}{20-10})&#x3D;\int_{90}^{+\infty}p(Q)dQ&#x3D;93.3\%$</p>
<h3 id="盈利400万元以上的可能性计算"><a href="#盈利400万元以上的可能性计算" class="headerlink" title="盈利400万元以上的可能性计算"></a>盈利400万元以上的可能性计算</h3><p>方案甲：$P(Q&gt;\frac{400+400}{20-11.5})&#x3D;\int_{800&#x2F;8.5}^{+\infty}p(Q)dQ&#x3D;89.5\%$</p>
<p>方案乙：概率为0。</p>
<p>方案丙：$P(Q&gt;\frac{400+600}{20-10})&#x3D;\int_{100}^{+\infty}p(Q)dQ&#x3D;84.1\%$</p>
<h2 id="期望利润计算"><a href="#期望利润计算" class="headerlink" title="期望利润计算"></a>期望利润计算</h2><p>由于总收益和总成本均是需求量的函数，故总利润$TR-TC&#x3D;20Q-F-C_vQ&#x3D;(20-C_v)Q-F$</p>
<p>方案甲：由于设备最大生产能力为每年130万件，故它的利润计算公式为：</p>
<p>$<br>TR_甲-TC_甲&#x3D;<br>\begin{cases}<br>     (20-C_{v甲})Q-F_甲 &amp; 当需求量Q\le 130时 \\<br>     (20-C_{v甲})\times 130-F_甲 &amp; 当需求量Q&gt;130时<br>\end{cases}<br>$<br>期望利润为<br>$$E(TR_甲-TC_甲)&#x3D;\int_{-\infty}^{130}(20-11.5)Qp(Q)dQ+\int_{130}^{+\infty}(20-11.5)\times 130 p(Q)dQ-400 &#x3D;586.408(万元)$$</p>
<p>同理可算出乙的期望利润为$291.87$万元，丙的期望利润为$598.4$万元。</p>
<h2 id="期望成本计算"><a href="#期望成本计算" class="headerlink" title="期望成本计算"></a>期望成本计算</h2><p>成本公式$TC&#x3D;F+C_vQ$</p>
<p>方案甲的成本计算公式为$<br>TC_甲&#x3D;<br>\begin{cases}<br>     400+11.5Q &amp; 当需求量Q\le 130时 \\<br>    400+11.5\times 130 &amp; 当需求量Q&gt;130时<br>\end{cases}<br>$</p>
<p>故方案甲打的期望成本为</p>
<p>$$ETC_甲&#x3D;400+\frac{11.5}{20\sqrt{2\pi}}\int_{-\infty}^{130}Qe^{-\frac{1}{2}(\frac{Q-120}{20})^2}dQ +\frac{1495}{20\sqrt{2\pi}}\int_{130}^{+\infty}Qe^{-\frac{1}{2}(\frac{Q-120}{20})^2} dQ &#x3D; 1591.837(万元) $$</p>
<p>同理可算出方案乙的期望成本为$1675.1$万元，方案丙的期望成本为$1798.7$万元。</p>
<h2 id="实现最低成本的可能性计算"><a href="#实现最低成本的可能性计算" class="headerlink" title="实现最低成本的可能性计算"></a>实现最低成本的可能性计算</h2><p>首先将三种方案的成本直线绘制在同一图形上，如图所示</p>
<img src=14.jpg width="50%">

<p>$TC_甲$与$TC_乙$相交于$A$点，故在交点$A$处有：$TC_乙&#x3D;TC_甲$，$F_乙+C_{v乙}Q&#x3D;F_甲+C_+{v甲}Q$</p>
<p>即$Q_A&#x3D;\frac{F_甲-F_乙}{C_{v乙}-C_{v甲}}&#x3D;\frac{400-200}{15-11.5}&#x3D;57.14$（万件）</p>
<p>同理，在$B$处有$TC_甲&#x3D;TC_丙$，可以计算出$Q_B&#x3D;133.3$（万件）</p>
<p>$Q_A$与$Q_B$将产量分为三部分，从图形上看，当$Q\le Q_A$时，方案乙有最低成本，当$Q_A&lt;Q&lt;Q_B$时，方案甲有最低成本；当$Q&gt;Q_B$时，方案丙有最低成本。实现最低成本的可能性为：</p>
<p>方案甲：$P(Q_A&lt;Q&lt;Q_B)&#x3D;P(57.14&lt;Q&lt;133.3) &#x3D; \int_{57.14}^{133.3}p(Q)dQ &#x3D; 0.741$</p>
<p>方案乙：$P(Q&lt;Q_A)&#x3D;P(Q&lt;57.14)&#x3D;\int_{-\infty}^{57.14}p(Q)dQ &#x3D; 0.000135$</p>
<p>方案丙：$P(Q&gt;Q_B)&#x3D;P(Q&gt;133.3)&#x3D;\int_{133.3}^{+\infty} p(Q)dQ &#x3D; 0.2578$</p>
<h2 id="设备利用率计算"><a href="#设备利用率计算" class="headerlink" title="设备利用率计算"></a>设备利用率计算</h2><h3 id="设备充分利用的可能性"><a href="#设备充分利用的可能性" class="headerlink" title="设备充分利用的可能性"></a>设备充分利用的可能性</h3><p>方案甲：设备的最大生产能力为每年130万件，故设备充分利用的可能性就是需求量不少于130万件的可能性，即<br>$P(Q\geq 130)&#x3D;P(\frac{Q-120}{20}\geq \frac{130-120}{20}) &#x3D; P(\frac{Q-120}{20}&gt;0.5) &#x3D; 1-\Phi(0.5) &#x3D; 1-69.1\% &#x3D; 30.9 \% $</p>
<p>同理可计算出方案乙的可能性为$84.1\% $ ，方案丙的可能性为$ 2.3 \%$</p>
<h3 id="设备利用率大于80-的可能性"><a href="#设备利用率大于80-的可能性" class="headerlink" title="设备利用率大于80%的可能性"></a>设备利用率大于80%的可能性</h3><p>方案甲的可能性为<br>$P(Q\geq 130\times 0.8)&#x3D; P(\frac{Q-120}{20}&gt;-0.8) &#x3D; \Phi(0.8) &#x3D; 78.8\% $</p>
<p>同理可得方案乙的可能性为$97.7\% $，方案丙的可能性为$34.5 \% $</p>
<h2 id="优化分析"><a href="#优化分析" class="headerlink" title="优化分析"></a>优化分析</h2><p>可以从三方面来看：利润贡献分析，成本分析，设备使用率分析。</p>
<img src=15.jpg width="80%">

<h3 id="利润贡献分析"><a href="#利润贡献分析" class="headerlink" title="利润贡献分析"></a>利润贡献分析</h3><p>从表中可以看出，三种方案的<font color="#dd0000"> 盈利可能性</font>都在$99\% $以上，因而亏损的可能性很小。<font color="#dd0000"> 利润在300万元以上的可能性</font>，方案甲最高，从<font color="#dd0000"> 期望利润</font>来看，方案丙最高，但方案甲和方案丙差距不大。因此认为方案甲最优。</p>
<h3 id="成本分析"><a href="#成本分析" class="headerlink" title="成本分析"></a>成本分析</h3><p>从期望成本来看，方案甲有最低的<font color="#dd0000"> 期望成本</font>，实现<font color="#dd0000">最低成本生产的可能性</font>为$74.1\% $，从此看出甲方案最优。</p>
<h3 id="设备利用率分析"><a href="#设备利用率分析" class="headerlink" title="设备利用率分析"></a>设备利用率分析</h3><p>方案甲的<font color="#dd0000">设备充分利用概率</font>在$30\% $以上，而且<font color="#dd0000">利用率在$80\% $以上</font>的可能性在$78\% $以上。而方案乙的规模小，利用率比甲、丙方案都大，但方案乙的可变成本大，因而总成本高，从经济效益上看是不合算的。</p>
<p>另一方面，从<font color="#dd0000">满足需求</font>来看，规模愈大，满足需求的可能性就愈大，但规模愈大，设备利用率就低。方案甲的满足需求的可能性占$69.1\% $，即在大多数情况下基本可以满足需求。</p>
<p>综合上述分析，方案甲有最低的期望成本，实现最低成本生产的可能性最大，期望利润与方案丙相差无几，但比方案乙好，因此，按优化准则作全面衡量，方案甲是最优方案。</p>
]]></content>
      <categories>
        <category>经济预测与决策</category>
        <category>经济决策技术</category>
      </categories>
      <tags>
        <tag>经济决策技术</tag>
      </tags>
  </entry>
  <entry>
    <title>随机事件复习笔记</title>
    <url>/2022/04/22/%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>随机事件复习笔记</p>
<span id="more"></span>

<h3 id="概率的公理化定义"><a href="#概率的公理化定义" class="headerlink" title="概率的公理化定义"></a>概率的公理化定义</h3><p>在一个随机现象中，用来表示任一个随机事件$A$发生可能性大小的实数成为该事件的概率，并规定：<br>（1）非负性公理：对任一事件$A$，必有$P(A)\geq 0$<br>（2）正则化公理：必然事件的概率$P(\Omega)&#x3D;1$<br>（3）可列可加性公理：若$A_1,A_2,\cdots$是一列互不相容事件，则有：$P(\bigcup\limits_{n&#x3D;1}^\infty A_i)&#x3D;\sum\limits_{i&#x3D;1}^\infty P(A_i)$</p>
<p>不过这样的定义有些主观，我们下面给出一个更加严谨的定义。</p>
<h3 id="概率空间"><a href="#概率空间" class="headerlink" title="概率空间"></a>概率空间</h3><h4 id="事件域"><a href="#事件域" class="headerlink" title="事件域"></a>事件域</h4><p>设$\Omega$是试验$S$样本空间，$\mathcal{F}$是由$\Omega$子集组成的集合类，若$\mathcal{F}$满足以下性质：<br>（1）$\Omega \in \mathcal{F}$<br>（2）如果$A \in \mathcal{F}$，则$\bar{A} \in \mathcal{F}$<br>（3）如果$A_j \in \mathcal{F}$，则$\bigcup\limits_{j&#x3D;1}^\infty \in \mathcal{F}$<br>则我们称$\mathcal{F}$为$Borel$事件域，或者$\sigma$域，称$\mathcal{F}$中的元素为事件，称$(\Omega,\mathcal{F})$是可测空间。</p>
<p>如果对测度论感兴趣可以翻阅实变函数教材。</p>
<h4 id="在概率空间上定义概率"><a href="#在概率空间上定义概率" class="headerlink" title="在概率空间上定义概率"></a>在概率空间上定义概率</h4><p>设$(\Omega,\mathcal{F})$是可测空间，$P$是定义在$\mathcal{F}$上的函数，如果$P$满足下列条件：<br>（1）非负性：对$A\in \mathcal{F}$，$P(A)\geq0$<br>（2）完全性：$P(\Omega)&#x3D;1$<br>（3）可列可加性：对于$\mathcal{F}$中互不相容的事件$A_1,A_2,\cdots$，$P(\bigcup\limits_{n&#x3D;1}^\infty A_i)&#x3D;\sum\limits_{i&#x3D;1}^\infty P(A_i)$<br>我们就称$P$为$\mathcal{F}$上的概率测度，简称为概率，称$(\Omega,\mathcal{F},P)$为概率空间。</p>
<p>从这个定义我们可以看出概率其实是定义在事件域上的一个函数，将每一个事件赋予一个值，就叫做概率。</p>
<p>在以后我们所有模型都是建立在概率空间的基础上，所遇到的$\Omega$的子集都假定是事件。</p>
<h3 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h3><p>古典概型所满足的要求为：<br>（1）所涉及的随机现象只有有限个基本结果。<br>（2）每个基本结果出现的可能性是相通的（简称等可能性）<br>（3）假如被考察的事件$A$含有$k$个基本结果，则事件$A$的概率就是：$P(A)&#x3D;\frac{k}{n}&#x3D;\frac{A中包含基本结果的个数}{\Omega中基本结果的个数}$</p>
<p>在计算概率的时候还有频率方法和主观方法。</p>
<h3 id="概率的性质"><a href="#概率的性质" class="headerlink" title="概率的性质"></a>概率的性质</h3><p>1.不可能事件$\phi$的概率为0.<br>$Proof$：因为$\Omega&#x3D;\Omega \cup\phi\cup\phi\cdots$<br>由可列可加性公理有：$P(\Omega)&#x3D;P(\Omega)+\sum\limits_{n&#x3D;2}^\infty P(\phi)$，又因为$P(\Omega)&#x3D;1$，所以$P(\phi)&#x3D;0$。</p>
<p>2.对任一事件$A$，有$P(A)&#x3D;1-P(\bar{A})$<br>$Proof$：因为$A\cup \bar{A}&#x3D;\Omega$，$\Omega&#x3D;A\cup \bar{A} \cup \phi \cup \phi \cdots$<br>由可列可加性公理及性质1有：$P(\Omega)&#x3D;P(A)+P(\bar{A})+P(\phi)+P(\phi)+\cdots$<br>即$1&#x3D;P(A)+P(\bar{A})$</p>
<p>3.对于$n$个互不相容的事件$A_1,A_2,\cdots A_n$，有$P(\bigcup\limits_{i&#x3D;1}^{n}A_i)&#x3D;\sum\limits_{i&#x3D;1}^nP(A_i)$</p>
<p>$Proof$：利用数学归纳法。</p>
<p>4.对任意两个事件$A$和$B$，若$A\supset B$，则<br>（1）$P(A-B)&#x3D;P(A)-P(B)$<br>（2）$P(A)\geq P(B)$（概率的单调性）</p>
<p>$Proof$：将$A$分为两个互不相容事件$B$与$A-B$的并，由可列可加性公理得：$P(A)&#x3D;P(B)+P(A-B)$<br>再有非负性公理：$P(A-B)\geq 0$，即可得到（2）。</p>
<p>5.对任一事件$A$，有$0\leq P(A) \leq 1$<br>$Proof$：对任一事件$A$，总有:$\phi \subset A \subset \Omega$，由概率的单调性知$P(\phi)\leq P(A) \leq P(\Omega)$则有$0\leq P(A) \leq 1$。</p>
<p>6.对任意两个事件$A$和$B$，有：<br>（1）$P(A\cup B)&#x3D; P(A)+P(B)-P(AB)$<br>（2）$P(A\cup B)\leq P(A)+P(B)$</p>
<p>$Proof$：由于并事件可以写成两个互不相容的事件$A$与$B-AB$的并，从可加性公理有$P(A)&#x3D;P(B)+P(B-AB)$，又因为$B \supset AB$，则由性质4（1）有：$P(B-AB)&#x3D;P(B)-P(AB)$，带回即有（1）。再由$P(AB)\geq 0$立即得到（2）。</p>
<p>注记：将集合拆成几个不相交集合的并是集合论证明中常用的方法。</p>
<p>$Ex$：对任意两个事件A与B，证明$P(A)&#x3D;P(AB)+P(A\bar{B})$</p>
<p>$Ex2$：对任一三个事件$A,B,C$有：<br>（1）$P(A\cup B\cup C)&#x3D;P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)$<br>（2）$P(A\cup B\cup C)\geq P(A)+P(B)+P(C)$</p>
<br />

<p>$Eg$：设$P(A)&#x3D;1&#x2F;3,P(B)&#x3D;1&#x2F;2$<br>（1）：若事件$A$和$B$互不相容，求$P(B\bar{A})$<br>（2）：若$A\subset B$求$P(B\bar{A})$<br>（3）：若$P(AB)&#x3D;1&#x2F;8$，求$P(B\bar{A})$</p>
<p>$Sol$：<br>（1）因为$A$，$B$互不相容，所以$A\cap B &#x3D; \phi$，即$B \subset \bar{A}$，即有$\bar{A}&#x3D;B$，故$P(B\bar{A})&#x3D;P(B)&#x3D;1&#x2F;2$<br>（2）因为$P(B)&#x3D;P(AB)+P(B\bar{A})$且$A\subset B$，所以$P(AB)&#x3D;P(A)&#x3D;1&#x2F;3$，则有<br>$P(B\bar{A})&#x3D;$ $P(B)-P(AB)&#x3D;1&#x2F;6$<br>（3）同（2），有$P(B\bar{A})&#x3D;P(B)-P(AB)&#x3D;1&#x2F;2-1&#x2F;8&#x3D;3&#x2F;8$</p>
<br />

<p>$eg2$：某人对事件$A,B$及其并$A\cup B$分别给出主观概率如下：$P(A)&#x3D;1&#x2F;3,P(B)&#x3D;1&#x2F;3,P(A\cup B)&#x3D;3&#x2F;4$<br>按概率性质，应有$P(A\cup B)\leq P(A)+P(B)$，然而现在$P(A\cup B)&#x3D;3&#x2F;4$，$P(A)+P(B)&#x3D;2&#x2F;3$这个性质不满足。问题是出在了主管概率给定不恰当引起的。例如将$P(A\cup B)$修整成$3&#x2F;5$即可。</p>
<h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><p>$Def$：对任意两个事件$A,B$，若有$P(AB)&#x3D;P(A)+P(B)$，则称事件$A$与事件$B$相互独立，简称$A$和$B$独立。否则称事件$A$和$B$不独立。</p>
<p>注记：独立与互不相容没有必然联系，独立表示两件事件之间没有关系，而互不相容表示两件事件之间不可能同时发生。</p>
<p>$Th$：若事件$A$和$B$独立，则$A$与$\bar{B}$独立，$\bar{A}$与$B$独立，$\bar{A}$与$\bar{B}$独立。</p>
<p>$Proof$：$A\bar{B}&#x3D;A-AB$，又因为$AB\subset A$，再由A与B的独立性知：<br>$P(A\bar{B})&#x3D;P(A)-P(AB)&#x3D;P(A)-P(A)P(B)&#x3D;P(A)(1-P(B))&#x3D;P(A)P(\bar{B})$<br>其余的类似可证。</p>
<h4 id="多个事件的独立性"><a href="#多个事件的独立性" class="headerlink" title="多个事件的独立性"></a>多个事件的独立性</h4><p>设有$n$个事件$A_1,A_2,\cdots A_n$，假如对所有可能的$1\leq i&lt;j&lt;k&lt;\cdots \leq n$以下等式均成立：</p>
<p>$<br>\begin{cases}<br>P(A_iA_j)&#x3D;P(A_i)P(A_j) \\<br>P(A_iA_jA_k)&#x3D;P(A_i)P(A_j)P(A_k) \\<br>\cdots \\<br>P(A_1A_2\cdots A_n)&#x3D;P(A_1)P(A_2)\cdots P(A_n) \\<br>\end{cases}<br>$</p>
<p>则称这$n$个事件相互独立。</p>
<p>注记：只满足$P(A_iA_j)&#x3D;P(A_i)P(A_j)$是不可以的，我们有伯恩斯坦反例：</p>
<p>一个均匀的正四面体，第一面染上红色，第二面染上白色，第三面染上黑色，第四面同时染上红，白，黑三种颜色。记事件 $A,B,C$分别表示投一次均匀的正四面体出现红，白，黑颜色的事件。则$P(A)&#x3D;P(B)&#x3D;P(C)&#x3D;1&#x2F;2$，$P(AB)&#x3D;P(AC)&#x3D;P(BC)&#x3D;1&#x2F;4$，但是$P(ABC)&#x3D;1&#x2F;4$</p>
<p>本质是因为只有两两独立我们推不出$AB$和$C$独立、$A\cup B$和$C$独立。</p>
<p>有一个更直观的例子是波罗梅奥环，可以自行查阅。</p>
<h4 id="试验的独立性"><a href="#试验的独立性" class="headerlink" title="试验的独立性"></a>试验的独立性</h4><p>假设有$n$个试验$E_1,E_2,\cdots E_n$，假设$E_1$的任一结果，$E_2$的任一结果，$\cdots $  $ E_n$的任一结果都是相互独立的事件，则称试验  $E_1,E_2,\cdots E_n$是相互独立。如果这$n$次试验是相同的，则称其为$n$次独立重复试验。</p>
<p>$eg$：扔一枚硬币和扔一颗骰子是相互独立试验。</p>
<h3 id="n重伯努利试验"><a href="#n重伯努利试验" class="headerlink" title="n重伯努利试验"></a>n重伯努利试验</h3><p>$Def($伯努利试验$)$：只有两个结果$(A$和$\bar{A})$的试验称为伯努利试验。</p>
<p>在一次伯努利试验中，设发生$A$的概率为$p$，则有$P(A)&#x3D;p,P(\bar{A})&#x3D;1-p$</p>
<p>$Def(n$重伯努利试验$)$：由$n$次相同的，独立的伯努利试验组成的多随机试验成为$n$重伯努利试验。</p>
<p>$n$重伯努利试验可以用长度为$n$的$A$和$\bar{A}$的序列表示。</p>
<h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>$Def($条件概率$)$：设$A$和$B$是样本空间$\Omega$中的两个事件，且$P(B)&gt;0$，在事件$B$已经发生的条件下，事件$A$的条件概率$P(A|B)$定义为$\frac{P(AB)}{P(B)}$。</p>
<h4 id="条件概率的性质："><a href="#条件概率的性质：" class="headerlink" title="条件概率的性质："></a>条件概率的性质：</h4><p>1.条件概率是概率，即满足概率的$3$条公理。</p>
<p>2.（乘法公式）：对任意两个事件$A$和$B$，有：<br>$$P(AB)&#x3D;P(A|B)P(B)&#x3D;P(B|A)P(A)$$其中第一个等式要求$P(B)&gt;0$，第二个等式要求$P(A)&gt;0$</p>
<p>怎么理解？<br>通俗的来说，以第一个等式为例：$P(B)$表示将样本空间$\Omega$限制在了集合$B$上，$P(A|B)$代表将集合$A$限制在了集合$B$上。</p>
<p>2的结论还可以推广到多个事件</p>
<p>3.（一般乘法公式）：对任意$3$个事件$A,B,C$，假若$P(BC)&gt;0$，则有：$$P(ABC)&#x3D;P(A)P(B|A)P(C|AB)$$</p>
<p>$Def$：把样本空间$\Omega$分为$n$个事件$B_1,B_2,\cdots, B_n$，假如：<br>（1）$P(B_i)&gt;0,i&#x3D;1,2,\cdots, n$<br>（2）$B_1,B_2,\cdots B_n$互不相容<br>（3）$\bigcup\limits_{i&#x3D;1}^n B_i&#x3D;\Omega$<br>则称事件组$B_1,B_2,\cdots B_n$为样本空间$\Omega$的一个分割。</p>
<p>4.（全概率公式）：设$B_1,B_2,\cdots B_n$是样本空间$\Omega$的一个分割，则对$\Omega$的任意一事件$A$，有<br>$$P(A)&#x3D;\sum\limits_{i&#x3D;1}^nP(A|B_i)P(B_i)$$</p>
<p>怎么理解？<br>把$B_i$看成每个小空间，讲$B_i$上$A$发生的概率加起来就是$A$在$\Omega$上发生的概率。</p>
<p>5.（贝叶斯公式）：设事件$B_1,B_2,\cdots, B_n$是样本空间$\Omega$的一个分割，且他们各自的概率皆已知且为正，又设$A$是$\Omega$中的一个事件，$P(A)&gt;0$，且在$B_i$给定下事件$A$的条件概率$P(A|B_1),P(A|B_2),\cdots,P(A|B_n)$已知。则在$A$给定下，事件$B_k$的条件概率为：<br>$$P(B_k|A)&#x3D;\frac{P(A|B_k)P(B_k)}{P(A)}&#x3D;\frac{P(A|B_k)P(B_k)}{\sum\limits_{i&#x3D;1}^n P(A|B_i)P(B_i)}$$</p>
<p>我们称$P(B_k|A)$为后验概率，而$P(B_k)$为先验概率。</p>
<p>怎么理解？<br>我们把$B_i$看成一个人的决策集合，$P(B_i)$代表做$B_i$的决策的概率，现在通过试验我们得到了一个结果$A$，利用$A$我们可以得到$A$发生的时候$B_i$发生的概率，这样为做决策得到了试验的依据，可以根据试验情况改变决策。</p>
<h4 id="条件概率的例子"><a href="#条件概率的例子" class="headerlink" title="条件概率的例子"></a>条件概率的例子</h4><p>下面对于三个公式各给出一个例子</p>
<p>$eg1$（波利亚坛子模型）：设摊子内有$b$个黑球和$r$个红球，每次随机取出一个球， 把原球放回，还加进（与取出的球）同色的$c$个和异色球$d$个，这里$c$和$d$都是已知的整数。设$B_i$表示“第$i$次取出的是黑球”这一事件，$R_j$表示“第$j$次取出的是红球”这一事件，我们来研究下面几个事件的概率：<br>$$ P(B_1R_2R_3)&#x3D;P(B_1)P(R_2|B_1)P(R_3|R_2B_1)&#x3D;\frac{b}{b+r}\cdot\frac{r+d}{(b+c)+(r+d)}\cdot\frac{r+d+c}{(b+c+d)+(r+d+c)}$$</p>
<p>$$P(R_1B_2R_3)&#x3D;P(R_1)P(B_2|R_1)P(R_3|B_2R_1)&#x3D;\frac{r}{b+r}\cdot\frac{b+d}{(b+d)+(r+c)}\cdot\frac{r+c+d}{(b+d+c)+(r+c+d)} $$</p>
<p>$$ P(R_1R_2B_3)&#x3D;P(R_1)P(R_2|R_1)P(B_3|R_2R_1)&#x3D;\frac{r}{b+r}\cdot\frac{r+c}{(b+d)+(r+c)}\cdot\frac{b+2d}{(b+d+d)+(r+c+c)}$$</p>
<p>可以发现，这三个概率不一样，表明黑球出现的次序在影响着概率。</p>
<p>我们研究几个特殊的情况：</p>
<p>（1）$c&gt;0,d&#x3D;0$。这意味着每次取出球后会增加下一次也取到同色球的概率，这是一个传染病模型。每次发现一个传染病患者，以后都会增加再传染的概率。在这种情况下，上面三个概率分别为：</p>
<p>$$ P(B_1R_2R_3)&#x3D;\frac{b}{b+r}\cdot\frac{r}{(b+c)+(r)}\cdot\frac{r+c}{(b+c)+(r+c)}$$</p>
<p>$$P(R_1B_2R_3)&#x3D;\frac{r}{b+r}\cdot\frac{b}{(b)+(r+c)}\cdot\frac{r+c}{(b+c)+(r+c)} $$</p>
<p>$$ P(R_1R_2B_3)&#x3D;\frac{r}{b+r}\cdot\frac{r+c}{(b)+(r+c)}\cdot\frac{b}{(b)+(r+c+c)}$$</p>
<p>可以发现这三个概率相同，这表明在$d&#x3D;0$的时候，上述概率只与黑球和红球的次数有关，而与次序无关。</p>
<p>（2）$c&#x3D;0,d&gt;0$这是一个安全模型，每当发生事故（抓出红球）的时候安全工作就抓紧一些（放入黑球），否则就放松一些（放入红球），在这种情况下，上述三个概率分别为：</p>
<p>$$ P(B_1R_2R_3)&#x3D;\frac{b}{b+r}\cdot\frac{r+d}{(b)+(r+d)}\cdot\frac{r+d}{(b+d)+(r+d)}$$</p>
<p>$$P(R_1B_2R_3)&#x3D;\frac{r}{b+r}\cdot\frac{b+d}{(b+d)+(r)}\cdot\frac{r+d}{(b+d)+(r+d)} $$</p>
<p>$$ P(R_1R_2B_3)&#x3D;\frac{r}{b+r}\cdot\frac{r+c}{(b+d)+(r)}\cdot\frac{b+2d}{(b+d+d)+(r)}$$</p>
<p>这三个概率不相同，说明出事故的顺序影响着第$k$次出事故的概率。</p>
<p>（3）$c&#x3D;0,d&#x3D;0$，这是放回模型，抽$n$次抽出红球的次数这一随机变量服从二项分布$B(n,r&#x2F;(b+r))$<br>（4）$c&#x3D;-1,d&#x3D;0$，这是不放回模型，抽$n$次抽出红球的次数这一随机变量服从超几何分布。</p>
<br />

<p>$eg2$（敏感问题调查模型）：调查敏感问题时，有些人不愿如实回答，这时我们可以设计两个问题：</p>
<p>A：你的生日是否在7月1日以前？<br>B为敏感问题。</p>
<p>在问卷上我们只有是和否两个选项，同时设置一个包含红球和黑球的罐子，若抽出红球则回答A，否则回答B。且设罐中有红球$r$个，有黑球$b$个。（我们认为这个过程没有人监督，即所有填写问卷的人都如实回答。）<br>在调查后，我们可以得到问卷中填是的频率是$f&#x3D;\frac{k}{n}$，我们用频率估计概率得到$P(是)&#x3D;\frac{k}{n}$。<br>这里回答“是”有两种情况。一种是摸到红球回答“是”，一种是摸到黑球回答“是”。<br>对于第一种情况我们认为$P(是|红球)&#x3D;0.5$，而对于第二种情况，我们想知道的就是$P(是|黑球)$，设为$p$。<br>我们可以得到：<br>$$P(是)&#x3D;P(红球)\cdot P(是|红球)+P(黑球)\cdot P(是|黑球)$$<br>即：<br>$$\frac{k}{n}&#x3D;\frac{r}{r+b}\cdot 0.5 + \frac{b}{b+r}\cdot p$$<br>由此我们可以直接解出$p$。</p>
<br />

<p>$eg3$：为提高公司产品的质量，公司经理经过考虑后增加投资来改进生产设备，但从投资效果来看，下属部门有两种意见：<br>$$B_1：改进生产设备后，高质量产品可以占90\%$$<br>$$B_2：改进生产设备后，高质量产品可以占70\%$$<br>经理认为两种事件发生的概率为等可能的，即$P(B_1)&#x3D;P(B_2)&#x3D;0.5$。<br>经过试验一次试验$A$，试验结果为：试制了五个产品，全是高质量产品。<br>经理希望用此结果去改变其对最初观点的看法。我们由贝叶斯公式可以知道：<br>$$P(B_1|A)&#x3D;\frac{P(A|B_1)P(B_1)}{P(B_1)P(A|B_1)+P(B_2)P(A|B_2)}&#x3D;\frac{0.5\cdot 0.9^5}{0.5\cdot 0.9^5+0.5\cdot 0.7^5}$$</p>
<p>$$P(B_2|A)&#x3D;\frac{P(A|B_2)P(B_2)}{P(B_1)P(A|B_1)+P(B_2)P(A|B_2)}&#x3D;\frac{0.5\cdot 0.7^5}{0.5\cdot 0.9^5+0.5\cdot 0.7^5}$$</p>
<p>显然$P(B_1|A)&gt;P(B_2|A)$，所以经理对$B_1$更加信任。</p>
<p>注记：这个例子反映了机器学习中贝叶斯学习的过程。在机器学习中，试验$A$即为训练集中各个标签的频率，然后我们得到了后验概率后就可以在验证集中每个元素的分类。</p>
]]></content>
      <categories>
        <category>概率论</category>
        <category>随机事件及概率</category>
      </categories>
      <tags>
        <tag>条件概率</tag>
        <tag>贝叶斯公式</tag>
        <tag>概率</tag>
        <tag>独立性</tag>
      </tags>
  </entry>
  <entry>
    <title>高等代数拾遗</title>
    <url>/2022/09/05/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>查漏补缺前五章</p>
<p>参考书：高等代数北大第四版</p>
<span id="more"></span>

<p>这里讨论的多项式，向量组，矩阵都是在数域$P$上的。</p>
<h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><p>这里列出两个重要的定理：</p>
<p>$Th1:$如果不可约多项式$p(x)$是$f(x)$的$k$重因式$(k\geq 1)$，那么他是微商$f’(x)$的$k-1$重因式。</p>
<p>$Cor:$多项式$f(x)$没有重因式的充分必要条件是$f(x)$与$f’(x)$互素。</p>
<p>$Th2:$设$f(x)&#x3D;a_nx^n+a_{n-1}x^{n-1}+\cdots + a_0$是一个整系数多项式。如果有一个素数$p$，使得<br>$(1):p \nmid a_n$<br>$(2):p|a_{n-1},a_{n-2},\cdots, a_0$<br>$(3):p^2 \nmid a_0$<br>那么$f(x)$在有理数域上不可约。</p>
<p>一个经典的例子是$x^n+2$在有理数域上不可约，从而任意次多项式都可能再有理数域上不可约。</p>
<h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>本章主要是如何计算行列式，下面列出几个经典例子：</p>
<p>1.计算：<br>$$<br>D_n&#x3D;\begin{vmatrix}<br>        a_1-b_1 &amp; a_1-b_2 &amp; \cdots &amp; a_1-b_n \\<br>        a_2-b_1 &amp; a_2-b_2 &amp; \cdots &amp; ya_2-b_n \\<br>        \vdots &amp; \vdots &amp; &amp;  \vdots \\<br>        a_n-b_1 &amp; a_n-b_2 &amp; \cdots &amp; a_n-b_n \\<br>\end{vmatrix}<br>$$</p>
<p>在这里不列出详细过程，只列出答案：</p>
<p>$n&#x3D;1$时，行列式值为$a_1-b_1$</p>
<p>$n&#x3D;2$时，行列式值为$(a_1-a_2)(b_1-b_2)$</p>
<p>$n\geq 3$时，行列式值为 $0$</p>
<p>注记：计算行列式时，注意是否需要分类讨论。</p>
<br>
<br>

<p>2.计算：<br>$$<br>D_n&#x3D;\begin{vmatrix}<br>        x &amp; y &amp; y &amp; \cdots &amp; y &amp; y \\<br>        z &amp; x &amp; y &amp; \cdots &amp; y &amp; y \\<br>        z &amp; z &amp; x &amp; \cdots &amp; y &amp; y \\<br>        \vdots &amp; \vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots \\<br>        z &amp; z &amp; z &amp; \cdots &amp; x &amp; y \\<br>        z &amp; z &amp; z &amp; \cdots &amp; z &amp; x<br>\end{vmatrix}<br>$$</p>
<p>解：$x&#x3D;y$时，可以得到$D_n&#x3D;(x+(n-1)y)(x-y)^{n-1}$</p>
<p>$x\neq y$时，一个很经典的算法是将行列式化为$<br>\begin{vmatrix}<br>        x-y &amp; y &amp; y &amp; \cdots &amp; y &amp; y \\<br>        z-x &amp; x &amp; y &amp; \cdots &amp; y &amp; y \\<br>        0 &amp; z &amp; x &amp; \cdots &amp; y &amp; y \\<br>        \vdots &amp; \vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots \\<br>        0 &amp; z &amp; z &amp; \cdots &amp; x &amp; y \\<br>        0 &amp; z &amp; z &amp; \cdots &amp; z &amp; x<br>\end{vmatrix}<br>$后按照第一列展开，得到递推式：$D_n&#x3D;(x-y)D_{n-1}-y<br>\begin{vmatrix}<br>        1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \\<br>        z &amp; x &amp; \cdots &amp; y &amp; y \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots \\<br>        z &amp; z &amp; \cdots &amp; x &amp; y \\<br>        z &amp; z &amp; \cdots &amp; z &amp; x<br>\end{vmatrix}<br>$<br>$&#x3D;<br>(x-y)D_{n-1}-y<br>\begin{vmatrix}<br>        1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \\<br>        0 &amp; x-z &amp; \cdots &amp; y-z &amp; y-z \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots \\<br>        0 &amp; 0 &amp; \cdots &amp; x-z &amp; y-z \\<br>        0 &amp; 0 &amp; \cdots &amp; 0 &amp; x-z<br>\end{vmatrix}<br>$</p>
<p>$&#x3D;(x-y)D_{n-1}-y(x-z)^{n-1}$</p>
<p>用同样的方法还可得到$D_n&#x3D;(x-z)D_{n-1}-z(x-y)^{n-1}$</p>
<p>化简即有$D_n&#x3D;\frac{y(x-z)^n-z(x-y)^n}{y-z}$</p>
<br>
<br>

<p>3.计算</p>
<p>$$D_1&#x3D;\begin{vmatrix}<br>        1 &amp; 1 &amp; \cdots &amp; 1 \\<br>        x_1 &amp; x_2 &amp; \cdots &amp; x_{n} \\<br>        x_1^2 &amp; x_2^2 &amp; \cdots &amp; x_n^2 \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots \\<br>        x_1^{n-2} &amp; x_2^{n-2} &amp; \cdots &amp; x_n^{n-2} \\<br>        x_1^{n} &amp; x_2^{n} &amp; \cdots &amp; x_n^{n}<br>\end{vmatrix}$$</p>
<p>解：将其扩充为</p>
<p>$D&#x3D;\begin{vmatrix}<br>        1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \\<br>        x_1 &amp; x_2 &amp; \cdots &amp; x_{n} &amp; x_{n+1} \\<br>        x_1^2 &amp; x_2^2 &amp; \cdots &amp; x_n^2 &amp; x_{n+1}^2 \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots \\<br>        x_1^{n-2} &amp; x_2^{n-2} &amp; \cdots &amp; x_n^{n-2} &amp; x_{n+1}^{n-2} \\<br>        x_1^{n-1} &amp; x_2^{n-1} &amp; \cdots &amp; x_n^{n-1} &amp; x_{n+1}^{n-1} \\<br>        x_1^{n} &amp; x_2^{n} &amp; \cdots &amp; x_n^{n} &amp; x_{n+1}^{n}<br>\end{vmatrix}$</p>
<p>此行列式的值为$\prod\limits_{1\leq i &lt; j \leq n+1} (x_j-x_i)&#x3D;\prod\limits_{1\leq i &lt; j \leq n} (x_j-x_i) \times \prod\limits_{k&#x3D;1}^n(x_{n+1}-x_k)$<br>将扩充后的行列式按照最后一列展开，有<br>$D&#x3D;(-1)^{1+n+1}d_{1,n+1}+(-1)^{2+n+1}d_{2,n+1}+\cdots + (-1)^{n+1+n+1}d_{n+1,n+1}$<br>比较两边系数，有$(-1)^{n+n+1}D_1&#x3D;[x_{n+1}^{n-1}]D$，其中$[x^k]$表示$x^k$的系数。<br>$D_1&#x3D;(-1)^{n+n+1}\prod\limits_{1\leq i &lt; j \leq n} (x_j-x_i)\sum\limits_{k&#x3D;1}^n(-x_k)&#x3D;\prod\limits_{1\leq i &lt; j \leq n} (x_j-x_i)\sum\limits_{k&#x3D;1}^n x_k$</p>
<p>注记：对于一个不熟悉的行列式来说，我们要将其往我们熟悉的行列式上靠。</p>
<h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><p>这一章关于向量组的零碎的定理与推论较多，下面列出一些重要的和容易遗忘的：</p>
<p>1.设$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$与$\pmb{\beta}_1,\pmb{\beta}_2,\cdots,\pmb{\beta}_s$是两个向量组，如果<br>(1):向量组$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$可由$\pmb{\beta}_1,\pmb{\beta}_2,\cdots,\pmb{\beta}_s$线性表出<br>(2):$r&gt;s$<br>则$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$一定线性相关。</p>
<p>Cor1:如果向量组$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$可由$\pmb{\beta}_1,\pmb{\beta}_2,\cdots,\pmb{\beta}_s$线性表出，且$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$线性无关，则$r\leq s$</p>
<p>Cor2:任意$n+1$个$n$维向量一定线性相关。</p>
<p>Cor3:两个线性无关的等价向量组一定含有相同个数的向量。</p>
<p>Cor4:假设向量$\pmb{\beta}$可以经向量组$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$线性表出，则表示法唯一的充要条件为$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$线性无关。</p>
<p>注记：如果一个向量组成的向量组线性相关，那么它一定是零向量。</p>
<br>

<p>2.一个向量组的极大线性无关组都含有相同个数的向量。</p>
<p>据此我们可以定义向量组的秩：向量组的极大无关组所含的向量个数称为此向量组的秩。</p>
<br>

<p>3.矩阵的行秩就是将矩阵行向量组的秩，类似的可以定义矩阵的列秩。</p>
<p>Th1:矩阵的行秩与列秩相等，统称为矩阵的秩。</p>
<p>Th2:一个$n\times n$的方阵的行列式为0的充要条件是其秩小于$n$</p>
<p>3.5:在一个$s\times n$的矩阵$\pmb{A}$中任意选定$k$行和$k$列，位于这些选定的行和列的交点上的$k^2$个元素按照原来的次序所组成的$k$级行列式，称为$\pmb{A}$的一个$k$级子式。</p>
<p>Th3:一个矩阵秩为$r$的充要条件为矩阵中有一个$r$级子式不为0，但是所有$r+1$级子式全为0。</p>
<p>Th4:线性方程组$\pmb{Ax}&#x3D;\pmb{b}$有解的充要条件是$rank(\pmb{A})&#x3D;rank(\bar{\pmb{A}})$，这里的$\bar{\pmb{A}}$为$A$的增广矩阵。</p>
<br>

<p>4.线性方程组$\pmb{Ax}&#x3D;\pmb{b}$的导出组定义为$\pmb{Ax}&#x3D;\pmb{0}$</p>
<p>定义其次线性方程组$\pmb{Ax}&#x3D;\pmb{0}$的基础解系$\pmb{\eta}_1,\pmb{\eta}_2,\cdots,\pmb{\eta}_r$如下：<br>(1):$\pmb{Ax}&#x3D;\pmb{0}$的任意一个解都可以表示为$\pmb{\eta}_1,\pmb{\eta}_2,\cdots,\pmb{\eta}_r$的线性组合。<br>(2):$\pmb{\eta}_1,\pmb{\eta}_2,\cdots,\pmb{\eta}_r$线性无关。</p>
<p>Th1:其次线性方程组基础解系中的向量个数等于$n-rank(\pmb{A})$</p>
<p>Cor1:与基础解系等价的线性无关的向量组也是基础解系。</p>
<p>Th2:如果 $\pmb{\gamma}_0$ 是 $\pmb{Ax}&#x3D;\pmb{b}$ 的一个特解，那么 $\pmb{Ax}&#x3D;\pmb{b}$ 的任一解可表示为 $\pmb{\gamma}&#x3D;\pmb{\gamma}_0+\pmb{\eta}$ ，其中 $\pmb{\eta}$ 为导出组一解。因此当 $\pmb{\eta}$ 取遍导出组的全部解时，上式就取遍了 $\pmb{Ax}&#x3D;\pmb{b}$ 的全部解。</p>
<p>Cor2：方程组 $\pmb{Ax}&#x3D;\pmb{b}$ 有解时，解是唯一的充要条件时它的导出组只有零解。</p>
<p>下面列出两个习题：</p>
<p>1.线性方程组 $\pmb{Ax}&#x3D;\pmb{0}$ 的系数矩阵为：</p>
<p>$$\pmb{A}&#x3D;\begin{pmatrix}<br>        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br>        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots \\<br>        a_{n-1,1} &amp; a_{n-1,2} &amp; \cdots &amp; a_{n-1,n}<br>\end{pmatrix}$$</p>
<p>设$M_i$时从矩阵 $\pmb{A}$ 中划第 $i$ 列所剩下的 $(n-1)\times(n-1)$ 矩阵的行列式，证明：<br>(1): $(M_1,-M_2,\cdots (-1)^{n-1}M_n)$ 是方程组的一个解。<br>(2):如果$\pmb{A}$的秩为$n-1$，那么方程组的解全是 $(M_1,-M_2,\cdots (-1)^{n-1}M_n)$ 的倍数。</p>
<p>证明：<br>(1):考虑行列式<br>$$A_i&#x3D;\begin{vmatrix}<br>        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br>        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots \\<br>        a_{n-1,1} &amp; a_{n-1,2} &amp; \cdots &amp; a_{n-1,n} \\<br>        a_{i1} &amp; a_{i2} &amp; \cdots &amp; a_{in}<br>\end{vmatrix}&#x3D;0,i&#x3D;1,2,\cdots, n$$<br>按照最后一行展开，就有 $a_{i1}M_1-a_{i2}M_2+\cdots + (-1)^{n-1}a_{in}M_n&#x3D;0$<br>即 $(M_1,-M_2,\cdots (-1)^{n-1}M_n)$ 是原方程的一个解。<br>(2):若 $r(\pmb{A})&#x3D;n-1$，则其基础解系里只有一个解，所有解都为其倍数。所以只需证明(1)中求的一解非零即可。注意到 $r(\pmb{A})&#x3D;n-1$，则 $\pmb{A}$有一个$n-1$级子式不为 $0$，即(1)求的的解为非零解。<br><br></p>
<p>2.设<br>$$A&#x3D;\begin{pmatrix}<br>        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br>        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots \\<br>        a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}<br>\end{pmatrix}$$<br>为一实数域上的矩阵，证明：<br>(1):如果 $|a_{ii}|&gt;\sum\limits_{j\neq i} |a_{ij}|, i&#x3D;1,2,\cdots,n $，那么 $|A|\neq 0$<br>(2):如果 $a_{ii}&gt;\sum\limits_{j\neq i} |a_{ij}|, i&#x3D;1,2,\cdots,n$ ，那么 $|A| &gt; 0$</p>
<p>证明：<br>(1)只需证明 $\pmb{Ax}&#x3D;\pmb{0}$ 的解只有零解即可。<br>对于上述方程任一非零解 $\pmb{c}&#x3D;(c_1,c_2,\cdots,c_n)$ ，总可以选出 $c_i&gt;0$ 使得 $|c_i|\geq |c_j| , j&#x3D;1,2,\cdots,n$，那么 $|a_{i1}c_1+a_{i2}c_2+\cdots + a_{in}c_n| \geq |a_{ii}||c_i| - \sum\limits_{j\neq i}|a_{ij}c_i|  \geq |c_i|(|a_{ii}|-\sum\limits_{j\neq i}|a_{ij}|)&gt;0$<br>所以$\pmb{Ax}&#x3D;\pmb{0}$只有零解，这就证明了我们的结论。</p>
<p>(2)运用数学归纳法证明。<br>$n&#x3D;1$ 时， $|\pmb{A}|&#x3D;a_{11}&gt;0$ ，结论对 $n&#x3D;1$ 成立。<br>假设结论对 $n-1$ 成立，下面我们对 $n$ 证明结论。<br>取$A$的第一行$n$个代数余子式$A_{11},A_{12},\cdots,A_{1n}$，则有<br>$$a_{11}A_{11}+a_{12}A_{12}+\cdots+a_{1n}A_{1n}&#x3D;|\pmb{A}|$$<br>$$a_{i1}A_{11}+a_{i2}A_{12}+\cdots+a_{in}A_{1n}&#x3D;0, i\neq 1$$<br>由(1)有： $|A|\neq 0$ ，所以 $A_{11},\cdots,A_{1n}$ 至少有一个不为0。<br>下面我们证明 $|A_{11}|\geq|A_{1i}|,i&#x3D;1,2,3,\cdots n$。<br>事实上，假若存在 $i\neq 1$ ，使得 $|A_{1i}|\geq |A_{1j}|, j&#x3D;1,2,\cdots, n$，此时必然有$|A_{1i}|&gt;0$，则<br>$$0&#x3D;|a_{i1}A_{11}+a_{i2}A_{12}+\cdots+a_{in}A_{1n}| $$<br>$$\geq |a_{ii}||A_{1i}|-\sum\limits_{j\neq i}|a_{ij}||A_{1j}|$$<br>$$\geq |a_{ii}||A_{1i}|-\sum\limits_{j\neq i}|a_{ij}||A_{1i}|$$<br>$$&#x3D; |A_{1i}|-(|a_{ii}|-\sum\limits_{j\neq i}|a_{ij}|)&gt;0$$<br>矛盾了，所以 $|A_{11}|\geq|A_{1i}|,i&#x3D;1,2,3,\cdots n$。<br>由归纳假设有$A_{11}&gt;0$，故$a_{11}A_{11}&gt;0$，于是<br>所以 $|\pmb{A}|&#x3D;a_{11}A_{11}+\sum\limits_{i&#x3D;2}^n a_{1i}A_{1i}\geq a_{11}A_{11}-\sum\limits_{i&#x3D;2}^n|a_{1i}||A_{1i}|\geq (a_{11}-\sum\limits{i&#x3D;2}^n|a_{1i}|)A_{11}&gt;0$<br>这就完成了归纳法。</p>
<p>注记：形如(1)类型的矩阵称为严格对角占优矩阵，事实上，对于对称的严格对角占优的矩阵，我们可以证明其一定是正定矩阵。<br>这类矩阵在数值分析中也有重要的作用，例如其可以进行LU分解，也可以进行Jacobi迭代和G-S迭代和$0 &lt;\omega \leq 1$的松弛迭代等。</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>这一章关于矩阵的零碎的定理与推论较多，下面列出一些重要的和容易遗忘的：</p>
<p>1.关于矩阵的秩：<br>(1):$rank(\pmb{A}+\pmb{B})\leq rank(\pmb{A})+rank(\pmb{B})$<br>(2):$rank(\pmb{AB})\leq min(rank(\pmb{A}),rank(\pmb{B}))$<br>(3):如果 $\pmb{A} &#x3D; \pmb{A_1} \pmb{A_2} \cdots  \pmb{A_t}$，那么 $rank(\pmb{A})\leq \min\limits_{1\leq j\leq t }rank(\pmb{A}_j)$<br>(4):设$\pmb{A}$是$s\times n$矩阵，如果$\pmb{P}$是$s\times s$可逆矩阵，$\pmb{Q}$是$n\times n$可逆矩阵，那么$rank(\pmb{A})&#x3D;rank(\pmb{PA})&#x3D;rank(\pmb{AQ})$<br>(5):设$\pmb{A}$,$\pmb{B}$是$n\times n$矩阵，如果$\pmb{AB}&#x3D;\pmb{0}$，那么$rank(\pmb{A})+rank(\pmb{B}) \leq n$<br>(6):设$\pmb{A}$是$s\times n$矩阵，$\pmb{B}$是$n\times m$矩阵，则$rank(\pmb{AB})\geq rank(\pmb{A})+rank(\pmb{B})-n$<br>(7):$rank(\pmb{A}^*)&#x3D;\begin{cases}<br>n&amp; rank(\pmb{A})&#x3D;n \\<br>1&amp; rank(\pmb{A})&#x3D;n-1 \\<br>0&amp; rank(\pmb{A})&lt; n-1 \\<br>\end{cases}<br>$</p>
<br>

<p>2.关于逆矩阵：下面均假设矩阵可逆<br>(1):如果$|\pmb{A}|&#x3D;d$，那么$|\pmb{A}^{-1}|&#x3D;d^{-1}$<br>(2):如果矩阵$\pmb{A},\pmb{B}$可逆，那么$\pmb{A}’$和$\pmb{AB}$也可逆，且成立$(\pmb{A}’)^{-1}&#x3D;(\pmb{A}^{-1})’$，$(\pmb{AB})^{-1}&#x3D;\pmb{B}^{-1}\pmb{A}^{-1}$<br>(3): $\pmb{A}^{-1}&#x3D;\frac{1}{d}\pmb{A}^*$<br>(4): $|\pmb{A}^*|&#x3D;|\pmb{A}|^{n-1}$<br>(5): $(\pmb{A}^*)^*&#x3D;|\pmb{A}|^{n-2}\pmb{A}$</p>
<br>

<p>3.关于初等矩阵<br>(1):矩阵$\pmb{A}$与$\pmb{B}$称作等价的，如果$\pmb{B}$可以由$\pmb{A}$经过一系列初等变换得到。<br>(2):任何一$s\times n$矩阵都与一形式为 $\begin{pmatrix}<br>        \pmb{E}_r &amp;  0 \\<br>        0 &amp; 0 \\<br>\end{pmatrix}$等价，其中$r$是矩阵的秩。<br>(3):矩阵$\pmb{A}$与$\pmb{B}$等价的充要条件是有初等矩阵$\pmb{P}_1, \pmb{P}_2, \cdots, \pmb{P}_l, \pmb{Q}_1,\pmb{Q}_2\cdots,\pmb{Q}_t$，使得$\pmb{A}&#x3D;\pmb{P}_1 \pmb{P}_2 \cdots \pmb{P}_l \pmb{B} \pmb{Q}_1 \pmb{Q}_2 \cdots \pmb{Q}_t$<br>(4):两个$s\times n$矩阵$\pmb{A},\pmb{B}$等价的充要条件为，存在可逆的$s$级矩阵$\pmb{P}$和可逆的$n$级矩阵$\pmb{Q}$，使得$\pmb{A}&#x3D;\pmb{PBQ}$<br>(5):$n$级矩阵$\pmb{A}$可逆的充要条件为他能成一系列初等矩阵的乘积。</p>
<br>

<p>4.经典结论<br>(1):设$\pmb{A},\pmb{B}$分别是$n\times m, m\times n$矩阵，则：<br>$$\begin{vmatrix}<br>        \pmb{E}_m &amp;  \pmb{B} \\<br>        \pmb{A} &amp; \pmb{E}_n \\<br>\end{vmatrix}&#x3D;|\pmb{E}_n-\pmb{AB}|&#x3D;|\pmb{E}_m-\pmb{BA}|$$</p>
<p>Cor:设$\pmb{A},\pmb{B}$分别是$n\times m, m\times n$矩阵，则：<br>$$|\lambda \pmb{E}_n-\pmb{AB}|&#x3D;\lambda^{n-m}|\lambda\pmb{E}_m-\pmb{BA}|$$<br>提示：考虑$|\pmb{E}_n-(\frac{\pmb{A}}{\lambda})\pmb{B}|$，再用(1).</p>
<p>(2):设$\pmb{A}$为$2\times 2$矩阵，证明：如果$\exists l \geq 2,s.t. \pmb{A}^l&#x3D;\pmb{0}$，那么$\pmb{A}^2&#x3D;\pmb{0}$</p>
<p>提示：分$rank(\pmb{A})&#x3D;0$或者$1$讨论，注意$rank(\pmb{A})&#x3D;1$时，有$\pmb{A}^2&#x3D;k\pmb{A}$</p>
<p>注记：本题有许多种做法，一个经典的做法是使用Jordan型，由此可以推出$n$阶幂零矩阵的幂零指数不超过$n$。</p>
<p>(3):设$\pmb{A}$为$n\times n$矩阵，证明：如果$\pmb{A}^2&#x3D;\pmb{E}$，那么$rank(\pmb{A}+\pmb{E})+rank(\pmb{A}-\pmb{E})&#x3D;n$</p>
<p>提示：考虑$(\pmb A-\pmb{E})(\pmb{A}+\pmb{E})&#x3D;\pmb{0}$以及$(\pmb{A}+\pmb{E})+(\pmb{A}-\pmb{E})&#x3D;2\pmb{A}$</p>
<h2 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h2><p>我们用对称矩阵的角度来看二次型。</p>
<p>(1):合同关系<br>两个$n\times n$矩阵$\pmb A, \pmb B$称作合同的，如果有可逆的$n\times n$矩阵$\pmb{C}$，使得$\pmb{B}&#x3D;\pmb{C}’\pmb{AC}$。<br>合同关系是一个等价关系。<br>任意一个对称矩阵都合同于一个对角矩阵，即$\exists \pmb{C}$，使得$\pmb{C}’\pmb{AC}$是对角型矩阵。<br>注记：进一步的，我们可以要求$C$是正交的。</p>
<br>

<p>(2):规范形<br>任意一个复系数的对称矩阵$\pmb{A}$合同于一个形式为 $\begin{pmatrix}<br>        \pmb{E}_r &amp;  0 \\<br>        0 &amp; 0 \\<br>\end{pmatrix}$的对角矩阵，从而有任意两个复数对称矩阵合同的充要条件是他们的秩相等。</p>
<p>任意一个实系数的对称矩阵$\pmb{A}$合同于一个形式为 $\begin{pmatrix}<br>        \pmb{E_p} &amp;  0 &amp; 0 \\<br>        0 &amp; -\pmb{E_{r-p}} &amp; 0 \\<br>        0 &amp; 0 &amp; 0 \\\end{pmatrix}$的对角矩阵，其中对角线上$1$的个数$p$和$-1$的个数$r-p$都是唯一确定的，分别称为$\pmb{A}$的正、负惯性指数，它们的差$2p-r$称做$A$的符号差。</p>
<br>
(3):正定性

<p>1.实二次型$\pmb{X}’\pmb{AX}$是正定的充要条件是矩阵$A$的顺序主子式全大于零。</p>
<p>2.实二次型$\pmb{X}’\pmb{AX}$，其中$A$是对称矩阵，则下面命题等价：<br>(1)$\pmb{X}’\pmb{AX}$ 是半正定的；<br>(2)它的正惯性指数与秩相等；<br>(3)有可逆实矩阵$\pmb{C}$，使得$\pmb{C}’\pmb{AC}&#x3D;diag\{d_1,d_2,\cdots, d_n\},d_i \geq 0, i&#x3D;1,2,\cdots n$；<br>(4)有实矩阵$\pmb{C}$，使得$\pmb{A}&#x3D;\pmb{C}’\pmb{C}$；<br>(5)$\pmb{A}$的所有主子式皆大于零或等于零。</p>
<p>注记：在(5)中，不能只要求顺序主子式全大于或等于零。</p>
<p>列出几个习题：</p>
<p>(1):设$\pmb{A}$是反对称矩阵，证明：$\pmb{A}$合同于</p>
<p>$$\begin{pmatrix}<br>        0  &amp; 1 \\<br>        -1 &amp; 0 \\<br>           &amp;   &amp; 0 &amp; 1 \\<br>           &amp;   &amp; -1&amp; 0 \\<br>           &amp;   &amp;   &amp;  &amp; \ddots \\<br>           &amp;   &amp;   &amp;  &amp;       &amp; 0 &amp; 1 \\<br>           &amp;   &amp;   &amp;  &amp;       &amp; -1&amp; 0 \\<br>           &amp;   &amp;   &amp;  &amp;       &amp;   &amp;  &amp; 0 \\<br>           &amp;   &amp;   &amp;  &amp;       &amp;   &amp;  &amp;  &amp; \ddots \\<br>           &amp;   &amp;   &amp;  &amp;       &amp;   &amp;  &amp;  &amp; &amp; 0\\<br>\end{pmatrix}$$</p>
<p>提示：可以使用归纳法证明。</p>
<br>

<p>(2):证明$rank(\pmb{A}’\pmb{A})&#x3D;rank(\pmb{A})$</p>
<p>提示：可以从$\pmb{A}’\pmb{A}\pmb{X}&#x3D;0$和$\pmb{AX}&#x3D;\pmb{0}$的解的角度考虑。</p>
<br>
<br>

<p>先写这么多吧，后面五章看看有没有时间，有时间再写吧。</p>
]]></content>
      <categories>
        <category>高等代数</category>
      </categories>
      <tags>
        <tag>高等代数</tag>
      </tags>
  </entry>
  <entry>
    <title>随机变量的数学特征复习笔记</title>
    <url>/2022/05/03/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%A6%E7%89%B9%E5%BE%81%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简要介绍数学期望，方差，矩，分位数</p>
<span id="more"></span>

<h2 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h2><p>在日常生活中，求平均值是一个很常见的一种运算，例如求平均分，平均工资等。假设我们有$n$个样本，取值分别为$x_1,x_2,\cdots ,x_n$，则他们的平均值即为：<br>$$\bar{x}&#x3D;\frac{x_1+x_2+\cdots +x_n}{n}$$<br>加入我们给这些数一个权值$w_1,w_2,\cdots ,w_n$，则令</p>
<p>$$\bar{x}&#x3D;\sum\limits_{i&#x3D;1}^n w_ix_i$$<br>称为这$n$个样本的加权平均。</p>
<p>$Def$：设$X$为一离散型随机变量，它取值$x_1,x_2,\cdots $对应概率为$p_1,p_2,\cdots$，如果级数<br>$$\sum_{i&#x3D;1}^\infty x_ip_i$$<br>绝对收敛，则将其称为$X$的数学期望，简称期望，或均值，记为$EX$。</p>
<p>注记：当$\sum\limits_{i&#x3D;1}^\infty |x_i|p_i$发散时，则说$X$的期望不存在。（此时即使$\sum\limits_{i&#x3D;1}^\infty x_ip_i$条件收敛，我们也可以通过调换顺序让其和为任意值。）</p>
<p>$Def2$：设$X$设连续型随机变量，当积分$\int_{-\infty}^\infty x p(x)dx$绝对收敛时，我们称它为$X$的数学期望，记做$EX$</p>
<p>从Riemann-Stieltjes积分的角度可以这么定义：<br>$Def3$：若$X$的分布函数为$F(x)$，则定义<br>$$EX&#x3D;\int_{-\infty}^\infty xdF(x)$$<br>为$X$的数学期望（我们这里还要求上述积分绝对收敛）。</p>
<h3 id="随机变量函数的数学期望"><a href="#随机变量函数的数学期望" class="headerlink" title="随机变量函数的数学期望"></a>随机变量函数的数学期望</h3><p>$Th$：若$g(x)$是一元博雷尔函数，且$\eta &#x3D; g(\xi)$，则<br>$$\int_{-\infty}^{\infty}ydF_\eta(y)&#x3D;\int_{-\infty}^{\infty}g(x)dF_\xi(x)$$</p>
<p>注记：等式左端是$\eta$的数学期望的计算公式，而右边是将$x$替换成了$g(x)$所得到的，我们可以证明这两者相等。</p>
<p>在离散型场合，我们有<br>$$Eg(\xi)&#x3D;\sum\limits_{i&#x3D;1}^\infty g(x_i)p(x_i)$$<br>在连续型场合，我们有<br>$$Eg(\xi)&#x3D;\int_{-\infty}^{\infty}g(x)p(x)dx$$</p>
<h3 id="数学期望的性质"><a href="#数学期望的性质" class="headerlink" title="数学期望的性质"></a>数学期望的性质</h3><p>性质1：设$a,b,c$为常数，若$a\leq \xi \leq b$，则$a\leq E\xi \leq b$，特别的$Ec&#x3D;c$。</p>
<p>性质2：线性性：对任一常数$c_i ~ i&#x3D;1,2,\cdots n$和$b$有<br>$$E(\sum\limits_{i&#x3D;1}^n c_iX_i+b)&#x3D;\sum\limits_{i&#x3D;1}^n c_iEX_i+b$$<br>特别地<br>$$E(\sum\limits_{i&#x3D;1}^n X_i)&#x3D;\sum\limits_{i&#x3D;1}^n EX_i$$</p>
<h3 id="数学期望的求法"><a href="#数学期望的求法" class="headerlink" title="数学期望的求法"></a>数学期望的求法</h3><p>我们在这里介绍几种分布的数学期望的求法。</p>
<p>1.二项分布$X\sim b(n,p)$</p>
<p>$$Ex&#x3D;\sum\limits_{k&#x3D;0}^n kC_n^kp^kq^{n-k}&#x3D;np\sum\limits_{k&#x3D;1}^nC_{n-1}^{k-1}p^{k-1}q^{n-k}&#x3D; np(p+q)^{n-1}&#x3D;np$$<br>注记：我们用到了组合恒等式$k\cdot C_n^k&#x3D;n\cdot C_{n-1}^{k-1}$和二项式定理。</p>
<p>2.柯西分布$p(x)&#x3D;\frac{1}{\pi}\cdot \frac{1}{1+x^2}$<br>由于$$\int_{-\infty}^{\infty}|x|\frac{1}{\pi \cdot (1+x^2)}&#x3D;\infty$$<br>因此柯西分布的数学期望不存在。<br>注记：事实上，上述积分甚至不条件收敛，但是其有柯西主值0。</p>
<p>3.正态分布$N(\mu,\sigma^2)$<br>令$Y&#x3D;\frac{X-\mu}{\sigma}$，则$Y\sim N(0,1)$我们有<br>$$EY&#x3D;\int_{-\infty}^{\infty}\frac{1}{\sqrt{2\pi}}\cdot xe^\frac{-x^2}{2}dx&#x3D;0$$<br>那么$EX&#x3D;E(\sigma Y+\mu)&#x3D;\mu$<br>注记：正态分布的第一个分量是其数学期望。</p>
<p>4.超几何分布的数学期望<br>设想一个不放回的抽样，令<br>$$<br>x_i&#x3D;\begin{cases}<br>1 &amp; 第i次抽得次品 \\<br>0 &amp; 第i次抽得好品<br>\end{cases}<br>$$<br>则$P(x_i&#x3D;1)&#x3D;\frac{M}{N}$，因此$EX_i&#x3D;\frac{M}{N}$，而$X&#x3D;X_1+\cdots + X_n$，表示$n$次不放回抽样中抽出的次品数。他服从上述超几何分布，则有<br>$$EX&#x3D;EX_1+\cdots EX_n&#x3D;\frac{nM}{N}$$</p>
<h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><p>$Def$：设随机变量$X$的$EX^2$存在，则称偏差$X-EX$平方的数学期望$E[X-EX]^2$为随机变量$X$的方差，记为$DX$或者$Var(X)$。</p>
<p>注记：<br>$$E(X-EX)^2&#x3D;E(X^2-2X\cdot EX+(EX)^2)&#x3D;EX^2-2EX\cdot EX+(EX)^2&#x3D;EX^2-(EX)^2$$<br>在实际计算的时候我们可以用此公式$来计算</p>
<h3 id="方差的性质"><a href="#方差的性质" class="headerlink" title="方差的性质"></a>方差的性质</h3><p>性质1:常数的方差为0<br>性质2:$D(X+c)&#x3D;DX$，这里$c$是常数<br>性质3:$D(cX)&#x3D;c^2DX$，这里$c$是常数<br>性质4:若$c\neq EX$，则$DX&lt;E(X-c)^2$<br>$Proof$:因为<br>$$DX&#x3D;E(X-EX)^2&#x3D;E((X-c)-(EX-c))^2&#x3D;E(X-c)^2-(EX-c)^2$$<br>所以$EX\neq c$时，$DX&gt;E(X-c)^2$.<br>注记：对于随机变量$X$,若他的数学期望$EX$和方差$DX$都存在，且$DX&gt;0$，我们有时可以考虑标准化随机变量$X^*&#x3D;\frac{X-EX}{\sqrt{DX}}$，显然$EX^*&#x3D;0,DX^*&#x3D;1$，这正是称$X^*$为标准化随机变量的理由。</p>
<h3 id="切比雪夫不等式"><a href="#切比雪夫不等式" class="headerlink" title="切比雪夫不等式"></a>切比雪夫不等式</h3><p>$Th$：对于任何具有有限方差的随机变量$X$，都有<br>$$P(|X-EX|\geq \epsilon)\leq \frac{DX}{\epsilon^2}$$</p>
<p>$Proof$：设$F(x)$是$X$的分布函数，则显然有<br>$$DX&#x3D;\int_{-\infty}^\infty(x-EX)^2dF(x)\geq \int\limits_{|x-EX|\geq \epsilon}(x-EX)^2dF(x)\geq \int\limits_{|x-EX|\geq \epsilon}\epsilon^2 dF(x)$$<br>$$&#x3D;\epsilon^2 P(|X-EX|\geq \epsilon)$$</p>
<p>注记：我们这里的积分仍然是$Riemann-Stieltjes$积分</p>
<h2 id="常见分布的数学期望和方差"><a href="#常见分布的数学期望和方差" class="headerlink" title="常见分布的数学期望和方差"></a>常见分布的数学期望和方差</h2><p>下面给出一些最常见的分布的数学期望和方差</p>
<h3 id="离散型"><a href="#离散型" class="headerlink" title="离散型"></a>离散型</h3><table>
<thead>
<tr>
<th>分布名称</th>
<th>概率分布或密度函数$p(x)$</th>
<th>数学期望</th>
<th>方差</th>
</tr>
</thead>
<tbody><tr>
<td>退化分布</td>
<td>$p_c&#x3D;1$ $(c$为常数$)$</td>
<td>$c$</td>
<td>$0$</td>
</tr>
<tr>
<td>两点分布</td>
<td>$p_k&#x3D;\begin{cases}q &amp; k&#x3D;0 \\ p &amp; k&#x3D;1 \end{cases},$     $~~~~ 0&lt;p&lt;1,q&#x3D;1-p$</td>
<td>$p$</td>
<td>$pq$</td>
</tr>
<tr>
<td>二项分布</td>
<td>$b(k;n,p)&#x3D;C_n^kp^kq^{n-k} ~~~ k&#x3D;0,1,\cdots n, ~~~ 0&lt;p&lt;1, ~~~ q&#x3D;1-p$</td>
<td>$np$</td>
<td>$npq$</td>
</tr>
<tr>
<td>泊松分布</td>
<td>$p(k;\lambda)&#x3D;\frac{\lambda^k}{k!}e^{-\lambda}, ~~~ k&#x3D;0,1,\cdots, ~~~ \lambda &gt;0$</td>
<td>$\lambda$</td>
<td>$\lambda$</td>
</tr>
<tr>
<td>几何分布</td>
<td>$g(k;p)&#x3D;q^{k-1}p, ~~~ k&#x3D;1,2,\cdots,~~~ 0&lt;p&lt;1, ~~~ q&#x3D;1-p$</td>
<td>$\frac{1}{p}$</td>
<td>$\frac{q}{p^2}$</td>
</tr>
<tr>
<td>超几何分布</td>
<td>$p_k&#x3D;\frac{C_M^k C_{N-M}^{n-k}}{C_N^n}, ~~~ M\leq N,n\leq N, ~~~ k&#x3D;0,1,\cdots min(M,n)$</td>
<td>$ \frac{nM}{N}$</td>
<td>$\frac{nM}{N}(1-\frac{M}{N})\cdot \frac{N-n}{N-1}$</td>
</tr>
</tbody></table>
<h3 id="连续型"><a href="#连续型" class="headerlink" title="连续型"></a>连续型</h3><table>
<thead>
<tr>
<th>分布名称</th>
<th>概率分布或密度函数$p(x)$</th>
<th>数学期望</th>
<th>方差</th>
</tr>
</thead>
<tbody><tr>
<td>正态分布$N(\mu,\sigma^2)$</td>
<td>$p(x)&#x3D;\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}, ~~~ -\infty &lt; x &lt; \infty , ~~~ \mu ,\sigma &gt;0$</td>
<td>$\mu$</td>
<td>$\sigma^2$</td>
</tr>
<tr>
<td>均匀分布 $U[a,b]$</td>
<td>$p(x)&#x3D;\begin{cases}\frac{1}{b-a} &amp; a\leq x \leq b \\ 0 &amp; otherwise \end{cases}, ~~~ a&lt;b$</td>
<td>$\frac{a+b}{2}$</td>
<td>$\frac{(b-a)^2}{12}$</td>
</tr>
<tr>
<td>指数分布$Exp(\lambda)$</td>
<td>$p(x)&#x3D;\begin{cases}\lambda e^{-\lambda x} &amp; x\geq 0 \\ 0 &amp; x&lt;0 \end{cases} ~~~ \lambda &gt;0$</td>
<td>$\frac{1}{\lambda}$</td>
<td>$\frac{1}{\lambda^2}$</td>
</tr>
<tr>
<td>$\chi^2$分布</td>
<td>$p(x)&#x3D;\begin{cases}\frac{1}{2^{n&#x2F;2}\Gamma(\frac{n}{2})}x^{\frac{n}{2}-1}e^{-\frac{x}{2}} &amp; x\geq 0 \\ 0 &amp; x&lt;0 \end{cases} ~~~ n\in \mathbb{Z}$</td>
<td>$n$</td>
<td>$2n$</td>
</tr>
<tr>
<td>柯西分布</td>
<td>$p(x)&#x3D;\frac{1}{\pi}\cdot \frac{\lambda}{\lambda^2+(x-\mu)^2},~~~ -\infty &lt; x &lt; \infty, ~~~ \lambda&gt;0 $</td>
<td>不存在</td>
<td>不存在</td>
</tr>
</tbody></table>
<h2 id="其他数学特征"><a href="#其他数学特征" class="headerlink" title="其他数学特征"></a>其他数学特征</h2><h3 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h3><p>$Def$：设$X$为随机变量，$c$为常数，$k$为正整数，则量$E(X-c)^k$（假如它存在）称为<font color="#dd0000">$X$分布关于$c$的$k$阶矩</font>。若$c&#x3D;0$，则量$EX^k$成为$X$分布的<font color="#dd0000">$k$阶原点矩</font>，记为$\mu_k$，若$c&#x3D;EX$，则量$E(X-EX)^k$称为$X$分布的<font color="#dd0000">$k$阶中心矩</font>，记为$\nu_k$。<br>注记1:一阶原点矩就是数学期望，二阶中心矩就是方差。在实际应用中很少应用四阶以上的矩。<br>注记2:由于$|X|^{k-1}\leq |X|^k+1$故$k$阶矩存在时，$k-1$阶矩也存在，从而低于$k$阶的矩都存在。<br>注记3:原点矩和中心矩可以互相表出。<br>$$\nu_k&#x3D;E(X-EX)^k&#x3D;E(X-\mu_1)^k&#x3D;\sum_{i&#x3D;0}^k C_k^i\mu_i(-\mu_1)^{k-i}$$<br>$$\mu_k&#x3D;EX^k&#x3D;E((X-\nu_1)+\nu_1)^k&#x3D;\sum_{i&#x3D;0}^k C_k^i \nu_{k-i}\mu_1^i$$</p>
<h3 id="分位数和中位数"><a href="#分位数和中位数" class="headerlink" title="分位数和中位数"></a>分位数和中位数</h3><p>$Def$：对$0&lt;p&lt;1$，若$F(x_p)\leq p \leq F(x_p^+)$，则称$x_p$为分布函数$F(x)$的$p$分位数。其中$x_{0.5}$称为中位数。</p>
<h3 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h3><p>$Def$：设$X$是离散型随机变量，则$X$的最可能取的值称为$X$分布的众数。</p>
]]></content>
      <categories>
        <category>概率论</category>
        <category>随机变量及其分布</category>
      </categories>
      <tags>
        <tag>方差</tag>
        <tag>数学期望</tag>
        <tag>矩</tag>
        <tag>分位数</tag>
      </tags>
  </entry>
</search>
