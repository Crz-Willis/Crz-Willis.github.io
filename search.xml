<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ICPC 2021 昆明站游记</title>
    <url>/2022/04/16/kunming2021/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>拿到了人生的第一块“精神”金牌。</p>
<span id="more"></span>
<h1 id="inf-Days-before-Day-inf"><a href="#inf-Days-before-Day-inf" class="headerlink" title="inf Days before Day -inf"></a>inf Days before Day -inf</h1><p>lzc要去实习，zh和wzx说想为ec热手，于是就叫上了我和他们一起打昆明站。</p>
<h1 id="Day-inf"><a href="#Day-inf" class="headerlink" title="Day -inf"></a>Day -inf</h1><p>学校封校，去不了软件园校区，以为要被迫周烜双排了。</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>收到了昆明打星队伍可以远程打比赛的消息，于是赶紧和周烜协调了一下准备线上打昆明站。</p>
<h1 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h1><p>因为板子都在软件园，热身赛前三个小时紧急打了板子，-11.35</p>
<p>三人两机，远程参赛。晚上试了下场地，调了下环境就下线了。</p>
<p>主办方没提供热身赛题面，我还以为在大群里，折腾了半天最后才发现热身没有题面，只有正赛才有。</p>
<p>半夜12点半电脑突然响了，以为电脑出问题了，等了半个小时后发现是装更新？？？</p>
<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>早上9点半起床，发现志愿者已经在催核验身份了，于是光速起床洗漱，在宿舍调试好环境后准备开始比赛</p>
<p>拿到题面的过程还算顺利，决定我从头读，wzx从末尾读，zh在中间挑短的签到。</p>
<p>开比赛后我发现A题是一个大模拟，于是放到了一边转去读B。</p>
<p>B读完了之后发现B，G，K都有人过了，于是我给zh报了B的题意，wzx去想K，我去读了G。</p>
<p>wzx过了K以后，我给wzx讲了下我并没有什么思路的G，然后wzx秒了，过了一会就过了。</p>
<p>我：？？？？</p>
<p>此时D，E，F都有不少队过了，我读完F之后转化了下题意，发现$\frac{\sum\limits_{u\in V} b_u}{|V|}$这个东西不会求，于是找了wzx。</p>
<p>wzx：经典模型，然后等zh过了G之后就上去写了写。</p>
<p>写完交完发现wa了，于是下机想。最后发现分子上的东西可能能取到负的，最后wzx调了下之后就过了。</p>
<p>过了之后我觉得我已经无事可做了后开始写A，然后zh和wzx在另一边写B和D。在我写的过程中他们把D过了，然后开始调B。</p>
<p>我把A写完了之后不出意外出现了很多bug，而且还有tle的可能，于是我在枚举的时候加了个剪枝，本地测试极限数据跑了2秒后。</p>
<p>我：我写完A了，你们帮我交一下，要是没过我就下班了。</p>
<p>zh：好。</p>
<p>（30秒后）</p>
<p>zh：nb</p>
<p>我：过了？</p>
<p>zh：过了。</p>
<p>我：nb</p>
<p>然后我要了zh的B题代码之后没看几眼。</p>
<p>zh：我memset写错了。</p>
<p>然后他们就过了B。</p>
<p>然后最后对着C，E，L罚坐到了最后。</p>
<p>最后rk23，拿到了一块“金牌”。</p>
<p>说好不秃rk20，也恭喜他们拿到第一块金牌。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本身以为要0贡献了，结果写了个A还报了个F的做法，也算还行吧。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P5300 [GXOI/GZOI2019]与或和</title>
    <url>/2022/04/26/luogu-P5300/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单调栈好题</p>
<span id="more"></span>

<p><a href="https://www.luogu.com.cn/problem/P5300">传送门</a></p>
<p>大致题意：给你$n\times n$的矩阵$A$，让你求矩阵中所有子矩阵的与$\&amp;$和或$|$的和。<br>数据范围：$n\leq 2000,a_{i,j}\leq 2^{31}-1$</p>
<p>大致题解：拆位考虑，对于与运算，我们对每一个$a_{i,j}$计算以它为右下角的全1子矩阵个数，对于或运算，我们计算以$a_{i,j}$为右下角的全0子矩阵个数，然后用$i\times j$减去全0子矩阵的个数即可。</p>
<p>下面讨论怎么使用单调栈来维护以$a_{i,j}$为右下角的全1&#x2F;0子矩阵个数。</p>
<p>预处理$s_{i,j}$为以$a_{i,j}$上方连续的1&#x2F;0的个数，然后我们依次枚举一个点，计算以它为右下角的全1&#x2F;0的子矩阵的个数。</p>
<p>我们设$f_{i,j}$是以$a_{i,j}$为右下角的全1&#x2F;0子矩阵的个数，维护一个单调递增的栈，当未发生弹栈的时候，我们有</p>
<p>$$f_{i,j}&#x3D;f_{i,j-1}+s_{i,j}$$</p>
<p>其中第一部分是从左边延伸过来的，第二部分是从$a_{i,j}$向上延伸的。</p>
<p>具体见图：<img src="/2022/04/26/luogu-P5300/image.png"></p>
<p>当发生弹栈的时候，意味着左边的延伸不过去了，需要减掉，我们有</p>
<p>$$f_{i,j}&#x3D;f_{i,j}-(s_{i,j}-s_{i,st.top()})*(st.top()-st.(top-1)())$$</p>
<p>其中$st.(top-1)()$表示栈顶的下一个元素。</p>
<p>具体见图（3弹栈的时候）：</p>
<p><img src="/2022/04/26/luogu-P5300/image2.png"></p>
<p>这样就维护了答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(a,x) memset(a, x, sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; P;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">2e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">qp</span> <span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">			ans = ans * a % mod;</span><br><span class="line">		a = a * a % mod;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[maxn][maxn];</span><br><span class="line"><span class="type">int</span> up[maxn][maxn];</span><br><span class="line">ll ans1,ans2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IOS;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			cin&gt;&gt;a[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">31</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">mem</span>(up[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i][j]&amp;(<span class="number">1</span>&lt;&lt;k))</span><br><span class="line">					up[i][j]=up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					up[i][j]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">			s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">			up[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">			up[i][n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">			ll bns=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				bns+=up[i][j];</span><br><span class="line">				<span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;up[i][j]&lt;up[i][s.<span class="built_in">top</span>()])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> x = s.<span class="built_in">top</span>();</span><br><span class="line">					s.<span class="built_in">pop</span>();</span><br><span class="line">					bns=bns-(x-s.<span class="built_in">top</span>())*(up[i][x]-up[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				s.<span class="built_in">push</span>(j);</span><br><span class="line">				ans1=(ans1+(bns&lt;&lt;k))%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">mem</span>(up[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>((a[i][j]&amp;(<span class="number">1</span>&lt;&lt;k))==<span class="number">0</span>)</span><br><span class="line">					up[i][j]=up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					up[i][j]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">			up[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">			up[i][n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">			s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">			ll bns=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				bns=bns+up[i][j];</span><br><span class="line">				<span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;up[i][j]&lt;up[i][s.<span class="built_in">top</span>()])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> x = s.<span class="built_in">top</span>();</span><br><span class="line">					s.<span class="built_in">pop</span>();</span><br><span class="line">					bns=bns-(x-s.<span class="built_in">top</span>())*(up[i][x]-up[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				s.<span class="built_in">push</span>(j);</span><br><span class="line">				ans2=(ans2+((<span class="number">1ll</span>*i*j-bns)&lt;&lt;k))%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>破防了</title>
    <url>/2022/09/02/pofang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>保研破防</p>
<span id="more"></span>

<p>有点想说的，正好今天有空就写写吧。</p>
<p>自从高考失利，谈恋爱失败后，我就把绝大部分心思放在了学习上。但是我现在有些后悔。</p>
<p>2019年5月份的时候，我降级转专业到了数学学院，在数学院的三年时间里，我基本一心学习和音游。最后拿到了一个说得过去的绩点。虽然在某些考试之前有过没有睡着觉的经历，也有过心态爆炸的时候，但是我觉得都无伤大雅。</p>
<p>转眼就到了21年5月，各大学校开始了夏令营的招生。我当时想仗着四块ACM银牌的优势跨专业保研到AI或者CS之类的专业。投了fdu，ruc和pku。结果全寄了。</p>
<p>在全寄了之后，我就在想我到底哪个环节出了问题，后来感觉大家就业普遍减少，深造普遍变多，就导致研究生这条路更卷了。加上我是跨专业，就更加不占优势。所以经过一番考虑之后，我决定回到数学专业读运筹。</p>
<p>但是此时翻看学校是发现，大部分学校的运筹学专业之开设了直博这一条路，但是我认为我的科研水平几乎为0，加上大部分人说直博都不会很好过，考虑到我之前的心理状态，我比较抵触走直博这条路，因为谁也不知道我会不会读着读着心态就崩了然后去重开。但是考虑到直博中间读不下去的话还可以转硕士，这也是一个可以后退的道路吧。大不了先直博进去，读不动了再quit也是一个选择。</p>
<p>在此同时，家中的老人得了类风湿病一类的病，腿脚变得非常不方便，和家里人商量后，我们一致认为能在北京读研是最好的。</p>
<p>在下了这个决定之后，我就叫同学将复习所需要的书都寄回到了家中，开始了复习。期间我逐渐的变得熬夜和睡不着觉，有的时候12点钟躺在床上，翻来覆去，两点半还睡不着觉。有的时候躺下了，想着到时候面试的时候我答不上来的样子，然后就一下子睡意全无了。结果到8月中的时候，精神越来越差，就逐渐开始摆烂了。</p>
<p>与此同时，有些学校的预推免通知已经出来了，我就回到了济南准备材料。这之间还发生了不少事，不过都是后话了。但是清华的推荐信只要到了一封，剩下还有一封没有老师回我，但是31好就截止了，不知道能不能弄得上去。</p>
<p>有的时候感觉要是待材料学院就好了，或者想要是在数学院多摆摆烂，混个保研擦边的绩点，留sdu算了。</p>
<p>还有的时候想找个人倾诉倾诉，发泄一下情绪，又哪里找得到呢。</p>
<p>不过路已经走到这里了，又哪里有回头的机会呢。</p>
]]></content>
  </entry>
  <entry>
    <title>polya</title>
    <url>/2022/04/16/polya/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.luogu.com.cn/problem/P4980">传送门</a></p>
<span id="more"></span>


<p>题目描述：</p>
<p>给你$n$种颜色，再给你一个正$n$边形的项链，问你有多少种本质不同的染色方案。</p>
<p>注意本题的本质不同，定义为：<strong>只需要不能通过旋转与别的染色方案相同</strong>。</p>
<p>输入格式：第一行一个正整数$t$，表示数据组数，之后每一行一个数，代表$n$</p>
<p>输出格式：对于每一组数据，输出一个数，代表答案对$1e9+7$取模的结果。</p>
<p>样例输入：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>样例输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">11</span><br><span class="line">70</span><br><span class="line">629</span><br></pre></td></tr></table></figure>

<p>数据规模约定：$n\leq10^9,t\leq10^3$</p>
<p>在这里就不介绍Poyla定理的具体内容了，讲一讲应该如何优化。<br>我们不难求得答案是$ans&#x3D;\sum\limits_{i&#x3D;1}^nn^{gcd(i,n)}$</p>
<p>但是直接枚举复杂度是$O(tnlg^2n)$的，我们想办法优化。</p>
<p>我们可以发现对于$n$的每一个因子进行枚举可以发现，对于$n$的每一个因子$d$，我们有$n^d$种染色方案，又有$\varphi(\frac{n}{d})$个$gcd(i,n)&#x3D;d$的情况。<br>所以对于每一个$d$，我们将答案加上$n^d\varphi(\frac{n}{d})$</p>
<p>所以我们枚举$n$的因子即可，这样的复杂度可以变为$O(t(n\sqrt{n})^\frac{1}{2}lgn)$的，但这还不够，我们要继续优化。</p>
<p>我们可以先筛出每个质因子，然后再求欧拉函数的过程中，直接枚举质数即可。这样的复杂度可以变为$O(t(n^\frac{1}{2}lgn)^\frac{1}{2}lgn)$，就可以过了。</p>
<p>Code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pause system(<span class="string">&quot;pause&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e4</span>;</span><br><span class="line"><span class="type">int</span> prime[maxn + <span class="number">10</span>], tot;</span><br><span class="line"><span class="type">bool</span> vis[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getprime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * prime[j] &lt;= maxn; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a %= mod;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getphi</span><span class="params">(ll t, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1ll</span> * prime[i] * prime[i] &lt;= <span class="number">1ll</span> * t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t % prime[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * (prime[i] - <span class="number">1</span>) / prime[i];</span><br><span class="line">            <span class="keyword">while</span> (t % prime[i] == <span class="number">0</span>)</span><br><span class="line">                t /= prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans * (t - <span class="number">1</span>) / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">getprime</span>();</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n, ans = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * i == n)</span><br><span class="line">                ans += <span class="built_in">qp</span>(n, i - <span class="number">1</span>, mod) * <span class="built_in">getphi</span>(i, mod) % mod, ans %= mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += <span class="built_in">qp</span>(n, n / i - <span class="number">1</span>, mod) * <span class="built_in">getphi</span>(i, mod) % mod;</span><br><span class="line">                ans += <span class="built_in">qp</span>(n, i - <span class="number">1</span>, mod) * <span class="built_in">getphi</span>(n / i, mod) % mod;</span><br><span class="line">                ans %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt;(ans%mod+mod)%mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>群论</category>
      </categories>
      <tags>
        <tag>polya</tag>
      </tags>
  </entry>
  <entry>
    <title>线性系统理论复习</title>
    <url>/2022/06/24/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>复习线性系统理论</p>
<span id="more"></span>


<h2 id="Ch2"><a href="#Ch2" class="headerlink" title="Ch2"></a>Ch2</h2><h3 id="能控性分解：对不完全能控的系统"><a href="#能控性分解：对不完全能控的系统" class="headerlink" title="能控性分解：对不完全能控的系统"></a>能控性分解：对不完全能控的系统</h3><p>假如有$\dot{x}&#x3D;Ax+Bu$<br>令$Q_c&#x3D;[B,AB,\cdots A^{n-1}B]$，从中取出$k$个线性无关的列$t_1,\cdots t_k$，令$T_1&#x3D;[t_1,\cdots t_k]$。再任选$n-k$个线性无关的向量$t_{k+1},\cdots, t_n$，令$T_2&#x3D;[t_{k+1},\cdots, t_n]$<br>令$T&#x3D;[T_1 ~~ T_2]$<br>则</p>
<p>$$\hat{A}&#x3D;T^{-1}AT&#x3D;<br> \begin{bmatrix}<br>   A_{11} &amp; A_{12} \\<br>   0 &amp; A_{22}<br>  \end{bmatrix}<br>$$</p>
<p>$$\hat{B}&#x3D;T^{-1}B&#x3D;<br> \begin{bmatrix}<br>   B_{1}  \\<br>   0<br>  \end{bmatrix}<br>$$</p>
<p>则对于不完全能控系统，存在非奇异线性变换$x&#x3D;T\hat{x}$，使系统按能控性分解的规范表达式为：</p>
<p>$$<br> \begin{bmatrix}\dot{x_1}  \\\dot{x_2}<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix} A_{11} &amp; A_{12}  \\ 0 &amp; A_{22}<br>\end{bmatrix} \begin{bmatrix}{x_1}  \\{x_2}<br>\end{bmatrix} + \begin{bmatrix} B_1  \\0<br>\end{bmatrix} u<br>$$<br>其中$n-k$维子系统：$\dot{x_2}&#x3D;A_{22}x_2$ 完全不能控<br>$k$维子系统$\dot{x_1}&#x3D;A_{11}x_1+A_{12}x_2+B_1u$是完全能控的。</p>
<h3 id="能控规范形：对单输入-单输出的完全能控的系统"><a href="#能控规范形：对单输入-单输出的完全能控的系统" class="headerlink" title="能控规范形：对单输入-单输出的完全能控的系统"></a>能控规范形：对单输入-单输出的完全能控的系统</h3><p>考虑完全能控的单输入-单输出系统：</p>
<p>$$\begin{matrix}<br>\dot{x}&#x3D;Ax+bu \\<br>y&#x3D;cx<br>\end{matrix}$$<br>其中$A$为$n\times n$常阵，$b,c$分别为$n\times 1 , 1 \times n$的常阵。由于系统完全能控，有$rank[b ~ Ab ~ \cdots ~ A^{n-1}b]&#x3D;n$<br>令其特征多项式为：$det(sI-A)&#x3D;\alpha(s)&#x3D;s^n+a_{n-1}s^{n-1}+ \cdots + a_1s+a_0$<br>构造变换矩阵<br>$$P&#x3D;[e_1 ~ e_2 ~ \cdots ~ e_n]&#x3D;[A^{n-1}b ~ \cdots ~ Ab ~ b]\begin{bmatrix}<br>1 &amp; &amp;   \\<br>a_{n-1} &amp; \ddots\\<br>\vdots &amp;\ddots &amp; \ddots \\<br>a_1 &amp;\cdots &amp; a_{n-1}&amp; 1\\<br>\end{bmatrix}<br>$$</p>
<p>引入非奇异线性变换$x&#x3D;P\bar{x}$，可以导出其能控规范型：</p>
<p>$$\begin{matrix}<br>\dot{\bar{x}}&#x3D;A_c\bar{x}+b_cu \\ y&#x3D;c_c\bar{x}<br>\end{matrix}$$</p>
<p>其中<br>$$A_c&#x3D;P^{-1}AP&#x3D;\begin{bmatrix}<br>0 &amp; 1&amp;   \\<br>\vdots &amp; &amp;\ddots\\<br>0 &amp; &amp; &amp; 1 \\<br>-a_0 &amp;-a_1 &amp; \cdots&amp; -a_{n-1}\\<br>\end{bmatrix},b_c&#x3D;P^{-1}b&#x3D; \begin{bmatrix}<br>0 \\<br>\vdots \\<br>0 \\<br>1 \\<br>\end{bmatrix}<br>$$<br>$$c_c&#x3D;cP&#x3D;[\beta_0 ~ \beta_1 ~ \cdots ~ \beta_{n-1}]$$</p>
<h2 id="Ch3"><a href="#Ch3" class="headerlink" title="Ch3"></a>Ch3</h2><h3 id="闭环极点配置问题"><a href="#闭环极点配置问题" class="headerlink" title="闭环极点配置问题"></a>闭环极点配置问题</h3><p>给定线性定常系统$\dot{x}&#x3D;Ax+Bu$，其中$x$为$n$维状态向量，$u$为$p$维控制向量，$A,B$分别是$n\times n, n\times p$阶常阵。再给定$n$个所期望的闭环系统的极点$\alpha_1,\cdots \alpha_n$，其中复数共轭出现。我们想确定状态反馈$u&#x3D;Kx+v$，使得所导出的闭环系统$\dot{x}&#x3D;(A+BK)x+Bv$的极点为$\alpha_1,\cdots \alpha_n$。</p>
<p>对于单输入单输出的系统来说，可以如下进行极点配置：</p>
<p>计算$A$的特征多项式$det(sI-A)&#x3D;\alpha(s)&#x3D;s^n+a_{n-1}s^{n-1}+ \cdots + a_1s+a_0$</p>
<p>计算$\alpha(s)&#x3D;(s-\alpha_1)\cdots (s-\alpha_n)&#x3D;s^n+\bar{a}_{n-1}s^{n-1}+\cdots \bar{a}_1s+\bar{a}_0$</p>
<p>计算$\hat{K} &#x3D; [a_0 - \bar{a} _0 ~ a_1 - \bar{a} _1 ~ a _{n-1} - \bar{a} _{n-1}]$</p>
<p>计算$T$以及$T^{-1}$，其中</p>
<p>$$T&#x3D;[e_1 ~ e_2 ~ \cdots ~ e_n]&#x3D;[A^{n-1}b ~ \cdots ~ Ab ~ b]\begin{bmatrix}<br>1 &amp; &amp;   \\<br>a_{n-1} &amp; \ddots\\<br>\vdots &amp;\ddots &amp; \ddots \\<br>a_1 &amp;\cdots &amp; a_{n-1}&amp; 1\\<br>\end{bmatrix}<br>$$</p>
<p>计算反馈矩阵$K&#x3D;\hat{K}T^{-1}$</p>
<h2 id="Ch4"><a href="#Ch4" class="headerlink" title="Ch4"></a>Ch4</h2><h3 id="能观性分解：对不完全能观的系统"><a href="#能观性分解：对不完全能观的系统" class="headerlink" title="能观性分解：对不完全能观的系统"></a>能观性分解：对不完全能观的系统</h3><p>考虑不完全能观的线性定常系统：<br>$$\begin{matrix}<br>\dot{x}&#x3D;Ax+Bu \\<br>y&#x3D;Cx<br>\end{matrix}$$<br>令$Q_O&#x3D;\begin{bmatrix}<br>C \\<br>CA \\<br>\vdots \\<br>CA^{n-1} \\<br>\end{bmatrix}$，选取$m$个线性无关的行$h_1,h_2,\cdots h_m$，记$H&#x3D;\begin{bmatrix}<br>h_1 \\<br>h_2 \\<br>\vdots \\<br>h_m\\<br>\end{bmatrix}$</p>
<p>再任取$n-m$个与$H_1$线性无关的行向量$h_m+1,\cdots h_m$，记$H_2&#x3D;\begin{bmatrix}<br>h_{m+1} \\<br>h_{m+2} \\<br>\vdots \\<br>h_n\\<br>\end{bmatrix}$<br>令$T&#x3D;\begin{bmatrix}<br>H_1 \\<br>H_2 \\<br>\end{bmatrix}$</p>
<p>对系统做非奇异线性变换，$x&#x3D;T^{-1}\hat{x}$，则系统可以等价的化为：<br>$$\begin{matrix}<br>\dot{\hat{x}}&#x3D;\hat{A}\hat{x}+\hat{B}u \\ y&#x3D;\hat{C}\hat{x}<br>\end{matrix}$$<br>其中$\hat{A}&#x3D;TAT^{-1}&#x3D; \begin{bmatrix}<br>A_{11} &amp; 0 \\<br>A_{21} &amp; A_{22} \\<br>\end{bmatrix},\hat{B}&#x3D;TB&#x3D;\begin{bmatrix}<br>B_1 \\<br>B_2 \\<br>\end{bmatrix},\hat{C}&#x3D;CT^{-1}&#x3D;[C_1 ~~ 0]$<br>则能观性分解的规范表达式为：<br>$$<br>\begin{matrix}<br> \begin{bmatrix}\dot{x_1}  \\\dot{x_2}<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix} A_{11} &amp; 0 \\ A_{21} &amp; A_{22}<br>\end{bmatrix} \begin{bmatrix}{x_1}  \\{x_2}<br>\end{bmatrix} + \begin{bmatrix} B_1  \\B_2<br>\end{bmatrix} u<br>\\<br>y&#x3D;\begin{bmatrix}{C_1}  &amp;{0}<br>\end{bmatrix}\begin{bmatrix}{x_1}  \\{x_2}<br>\end{bmatrix}<br>\end{matrix}<br>$$</p>
<h3 id="能观规范型：对于单输入-单输出的完全能观系统"><a href="#能观规范型：对于单输入-单输出的完全能观系统" class="headerlink" title="能观规范型：对于单输入-单输出的完全能观系统"></a>能观规范型：对于单输入-单输出的完全能观系统</h3><p>考虑完全能观的单输入-单输出系统：<br>$$\begin{matrix}<br>\dot{x}&#x3D;Ax+bu \\ y&#x3D;cx<br>\end{matrix}$$<br>其中$A$为$n\times n$常阵，$b,c$分别为$n\times 1 , 1 \times n$的常阵<br>令其特征多项式为：$det(sI-A)&#x3D;\alpha(s)&#x3D;s^n+\alpha_{n-1}s^{n-1}+ \cdots + \alpha_1s+\alpha_0$</p>
<p>构造变换矩阵<br>$$Q&#x3D;\begin{bmatrix}<br>e_1\\<br>e_2 \\<br>\vdots \\<br>e_n\\<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br>1 &amp; \alpha_{n-1} &amp; \cdots &amp; \alpha_1\\<br> &amp; \ddots &amp; \ddots &amp; \vdots\\<br>&amp; &amp; \ddots &amp; \alpha_{n-1} \\<br>&amp; &amp; &amp; 1\\<br>\end{bmatrix}\begin{bmatrix}<br>cA^{n-1}\\<br>cA^{n-2} \\<br>\vdots \\<br>c\\<br>\end{bmatrix}$$</p>
<p>则引入非奇异线性变换$\hat{x}&#x3D;Qx$，可以导出其能控规范型为：<br>$$\begin{matrix}<br>\dot{\hat{x}}&#x3D;A_O\hat{x}+b_O u \\ y&#x3D;c_O\hat{x}<br>\end{matrix}$$<br>其中$$A_O&#x3D;QAQ^{-1}&#x3D;\begin{bmatrix}<br>0 &amp; \cdots &amp; 0 &amp; -\alpha_{0}\\<br> 1 &amp;  &amp;  &amp; -\alpha_{1}\\<br>&amp; \ddots &amp; &amp;\vdots \\<br>&amp; &amp;1 &amp; -\alpha_{n-1}\\<br>\end{bmatrix},b_O&#x3D;Qb&#x3D;\begin{bmatrix}<br>\beta_0\\<br>\beta_1\\<br>\vdots \\<br>\beta_{n-1}\\<br>\end{bmatrix}C_O&#x3D;\begin{bmatrix}<br>0 &amp; \cdots &amp; 0 &amp; 1<br>\end{bmatrix}$$</p>
<h3 id="对偶性原理："><a href="#对偶性原理：" class="headerlink" title="对偶性原理："></a>对偶性原理：</h3><p>称$<br>\begin{cases}<br>\dot{x} &amp; &#x3D; &amp; A_1x+B_1u \\<br>y &amp; &#x3D; &amp; C_1x<br>\end{cases}<br>$     和      $<br>\begin{cases}<br>\dot{z} &amp; &#x3D; &amp; -A_1^Tz+C_1^Tv \\<br>w &amp; &#x3D; &amp; B_1^Tz<br>\end{cases}<br>$互为对偶</p>
<h2 id="Ch5"><a href="#Ch5" class="headerlink" title="Ch5"></a>Ch5</h2><h3 id="最小实现"><a href="#最小实现" class="headerlink" title="最小实现"></a>最小实现</h3><h4 id="单输入单输出系统的传递函数"><a href="#单输入单输出系统的传递函数" class="headerlink" title="单输入单输出系统的传递函数"></a>单输入单输出系统的传递函数</h4><p>$$G(s)&#x3D;\frac{c_{n-1}s^{n-1}+\cdots + c_1s+ c_0}{s^n+a_{n-1}s^{n-1}+\cdots + a_1s+a_0}$$</p>
<p>其中$a_i,c_i,i&#x3D;0,1,\cdots n-1$为实常数。</p>
<p>则可写出其能控型实现$$A&#x3D;\begin{bmatrix}<br>0 &amp; 1&amp;   \\<br>\vdots &amp; &amp;\ddots\\<br>0 &amp; &amp; &amp; 1 \\<br>-a_0 &amp;-a_1 &amp; \cdots&amp; -a_{n-1}\\<br>\end{bmatrix},b&#x3D; \begin{bmatrix}<br>0 \\<br>\vdots \\<br>0 \\<br>1 \\<br>\end{bmatrix},C&#x3D;\begin{bmatrix}<br>c_0 &amp; c_1 &amp; \cdots c_{n-1}<br>\end{bmatrix}$$</p>
<p>和能观型实现：<br>$$A&#x3D;\begin{bmatrix}<br>0 &amp; \cdots &amp; 0 &amp; -\alpha_{0}\\<br> 1 &amp;  &amp;  &amp; -\alpha_{1}\\<br>&amp; \ddots &amp; &amp;\vdots \\<br>&amp; &amp;1 &amp; -\alpha_{n-1}\\<br>\end{bmatrix},b&#x3D;\begin{bmatrix}<br>c_0\\<br>c_1\\<br>\vdots \\<br>c_{n-1}\\<br>\end{bmatrix},C&#x3D;\begin{bmatrix}<br>0 &amp; \cdots &amp; 0 &amp; 1<br>\end{bmatrix}$$</p>
<h4 id="单输入多输出系统："><a href="#单输入多输出系统：" class="headerlink" title="单输入多输出系统："></a>单输入多输出系统：</h4><p>传递函数矩阵$$G(s)&#x3D;\frac{C_{n-1}s^{n-1}+\cdots + C_1s+ c_0}{s^n+a_{n-1}s^{n-1}+\cdots + a_1s+a_0}$$</p>
<p>其中$a_i,i&#x3D;0,1,\cdots n-1$为实常数,$C_i,i&#x3D;0,1,\cdots n-1$为$q\times 1$实常阵。</p>
<p>可以写能控型实现：<br>$$A&#x3D;\begin{bmatrix}<br>0 &amp; 1&amp;   \\<br>\vdots &amp; &amp;\ddots\\<br>0 &amp; &amp; &amp; 1 \\<br>-a_0 &amp;-a_1 &amp; \cdots&amp; -a_{n-1}\\<br>\end{bmatrix},b&#x3D; \begin{bmatrix}<br>0 \\<br>\vdots \\<br>0 \\<br>1 \\<br>\end{bmatrix},C&#x3D;\begin{bmatrix}<br>C_0 &amp; C_1 &amp; \cdots C_{n-1}<br>\end{bmatrix}$$</p>
<p>$A,B,C$分别为$n\times n,n\times 1, q\times n$常阵</p>
<h4 id="单输出系统："><a href="#单输出系统：" class="headerlink" title="单输出系统："></a>单输出系统：</h4><p>传递函数矩阵$$G(s)&#x3D;\frac{C_{n-1}s^{n-1}+\cdots + C_1s+ c_0}{s^n+a_{n-1}s^{n-1}+\cdots + a_1s+a_0}$$</p>
<p>其中$a_i,i&#x3D;0,1,\cdots n-1$为实常数,$C_i,i&#x3D;0,1,\cdots n-1$为$1\times p$实常阵。</p>
<p>$$A&#x3D;\begin{bmatrix}<br>0 &amp; \cdots &amp; 0 &amp; -\alpha_{0}\\<br> 1 &amp;  &amp;  &amp; -\alpha_{1}\\<br>&amp; \ddots &amp; &amp;\vdots \\<br>&amp; &amp;1 &amp; -\alpha_{n-1}\\<br>\end{bmatrix},b&#x3D;\begin{bmatrix}<br>C_0\\<br>C_1\\<br>\vdots \\<br>C_{n-1}\\<br>\end{bmatrix},C&#x3D;\begin{bmatrix}<br>0 &amp; \cdots &amp; 0 &amp; 1<br>\end{bmatrix}$$</p>
<p>$A,B,C$分别为$n\times n,n\times p, 1\times n$常阵</p>
<h2 id="Ch6"><a href="#Ch6" class="headerlink" title="Ch6"></a>Ch6</h2><h3 id="全维状态观测器"><a href="#全维状态观测器" class="headerlink" title="全维状态观测器"></a>全维状态观测器</h3><p>考虑线性定常系统<br>$$\begin{matrix}<br>\dot{x}&#x3D;Ax+Bu &amp; x(0)&#x3D;x_0,t\geq 0 \\<br>y&#x3D;Cx<br>\end{matrix}$$</p>
<p>其全维状态观测器的形式为：<br>$$\begin{matrix}<br>\dot{z}&#x3D;Fz+Gy+Hu &amp; z(0)&#x3D;z_0\\<br>\hat{x}&#x3D;z<br>\end{matrix}$$<br>可以推出全维状态观测器为<font color="#dd0000"> $\dot{z}&#x3D;(A-GC)z+Gy+Bu $</font><br /></p>
<p>在全维状态观测器进行输出的动态反馈时，我们做$u&#x3D;Kz+v$<br>则作用于系统构成的闭环系统为：</p>
<p>$$ \begin{bmatrix}\dot{x}  \\\dot{z}<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix} A &amp; BK \\ GC &amp; A+GC-BK<br>\end{bmatrix} \begin{bmatrix}{x}  \\{z}<br>\end{bmatrix} + \begin{bmatrix} B  \\ B<br>\end{bmatrix} v<br>\\<br>y&#x3D;\begin{bmatrix}{C}  &amp;{0}<br>\end{bmatrix}\begin{bmatrix}{x}  \\{z}<br>\end{bmatrix}$$</p>
<p>在题中，题目会给出观测器极点$a_1,a_2,\cdots a_n$，设$G&#x3D;\begin{bmatrix} G_1  \\ G_2 \\ \vdots \\G_n<br>\end{bmatrix} $<br>则可写出$A-GC$，进而可以写出$det(sI-A+GC)$，将其和$(s-a_1)\cdots(s-a_n)$比较，可以写出$G$，进而可以求得状态观测器。</p>
<p>设计动态输出反馈时，会给出传递函数或者极点$\alpha_1,\cdots ,\alpha_n$（注意状态反馈不改变系统的零点）。设$K&#x3D;\begin{bmatrix} K_1 &amp; K_2 &amp; \cdots &amp; K_n<br>\end{bmatrix} $</p>
<p>则可求出$det(sI-(A+BK))$，将其与$(s-\alpha_1)\cdots (s-\alpha_n)$比较，可以求出$K$，进而写出动态输出反馈$$</p>
]]></content>
      <categories>
        <category>线性系统理论</category>
      </categories>
      <tags>
        <tag>线性系统理论</tag>
      </tags>
  </entry>
  <entry>
    <title>随机事件复习笔记</title>
    <url>/2022/04/22/%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>随机事件复习笔记</p>
<span id="more"></span>

<h3 id="概率的公理化定义"><a href="#概率的公理化定义" class="headerlink" title="概率的公理化定义"></a>概率的公理化定义</h3><p>在一个随机现象中，用来表示任一个随机事件$A$发生可能性大小的实数成为该事件的概率，并规定：<br>（1）非负性公理：对任一事件$A$，必有$P(A)\geq 0$<br>（2）正则化公理：必然事件的概率$P(\Omega)&#x3D;1$<br>（3）可列可加性公理：若$A_1,A_2,\cdots$是一列互不相容事件，则有：$P(\bigcup\limits_{n&#x3D;1}^\infty A_i)&#x3D;\sum\limits_{i&#x3D;1}^\infty P(A_i)$</p>
<p>不过这样的定义有些主观，我们下面给出一个更加严谨的定义。</p>
<h3 id="概率空间"><a href="#概率空间" class="headerlink" title="概率空间"></a>概率空间</h3><h4 id="事件域"><a href="#事件域" class="headerlink" title="事件域"></a>事件域</h4><p>设$\Omega$是试验$S$样本空间，$\mathcal{F}$是由$\Omega$子集组成的集合类，若$\mathcal{F}$满足以下性质：<br>（1）$\Omega \in \mathcal{F}$<br>（2）如果$A \in \mathcal{F}$，则$\bar{A} \in \mathcal{F}$<br>（3）如果$A_j \in \mathcal{F}$，则$\bigcup\limits_{j&#x3D;1}^\infty \in \mathcal{F}$<br>则我们称$\mathcal{F}$为$Borel$事件域，或者$\sigma$域，称$\mathcal{F}$中的元素为事件，称$(\Omega,\mathcal{F})$是可测空间。</p>
<p>如果对测度论感兴趣可以翻阅实变函数教材。</p>
<h4 id="在概率空间上定义概率"><a href="#在概率空间上定义概率" class="headerlink" title="在概率空间上定义概率"></a>在概率空间上定义概率</h4><p>设$(\Omega,\mathcal{F})$是可测空间，$P$是定义在$\mathcal{F}$上的函数，如果$P$满足下列条件：<br>（1）非负性：对$A\in \mathcal{F}$，$P(A)\geq0$<br>（2）完全性：$P(\Omega)&#x3D;1$<br>（3）可列可加性：对于$\mathcal{F}$中互不相容的事件$A_1,A_2,\cdots$，$P(\bigcup\limits_{n&#x3D;1}^\infty A_i)&#x3D;\sum\limits_{i&#x3D;1}^\infty P(A_i)$<br>我们就称$P$为$\mathcal{F}$上的概率测度，简称为概率，称$(\Omega,\mathcal{F},P)$为概率空间。</p>
<p>从这个定义我们可以看出概率其实是定义在事件域上的一个函数，将每一个事件赋予一个值，就叫做概率。</p>
<p>在以后我们所有模型都是建立在概率空间的基础上，所遇到的$\Omega$的子集都假定是事件。</p>
<h3 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h3><p>古典概型所满足的要求为：<br>（1）所涉及的随机现象只有有限个基本结果。<br>（2）每个基本结果出现的可能性是相通的（简称等可能性）<br>（3）假如被考察的事件$A$含有$k$个基本结果，则事件$A$的概率就是：$P(A)&#x3D;\frac{k}{n}&#x3D;\frac{A中包含基本结果的个数}{\Omega中基本结果的个数}$</p>
<p>在计算概率的时候还有频率方法和主观方法。</p>
<h3 id="概率的性质"><a href="#概率的性质" class="headerlink" title="概率的性质"></a>概率的性质</h3><p>1.不可能事件$\phi$的概率为0.<br>$Proof$：因为$\Omega&#x3D;\Omega \cup\phi\cup\phi\cdots$<br>由可列可加性公理有：$P(\Omega)&#x3D;P(\Omega)+\sum\limits_{n&#x3D;2}^\infty P(\phi)$，又因为$P(\Omega)&#x3D;1$，所以$P(\phi)&#x3D;0$。</p>
<p>2.对任一事件$A$，有$P(A)&#x3D;1-P(\bar{A})$<br>$Proof$：因为$A\cup \bar{A}&#x3D;\Omega$，$\Omega&#x3D;A\cup \bar{A} \cup \phi \cup \phi \cdots$<br>由可列可加性公理及性质1有：$P(\Omega)&#x3D;P(A)+P(\bar{A})+P(\phi)+P(\phi)+\cdots$<br>即$1&#x3D;P(A)+P(\bar{A})$</p>
<p>3.对于$n$个互不相容的事件$A_1,A_2,\cdots A_n$，有$P(\bigcup\limits_{i&#x3D;1}^{n}A_i)&#x3D;\sum\limits_{i&#x3D;1}^nP(A_i)$</p>
<p>$Proof$：利用数学归纳法。</p>
<p>4.对任意两个事件$A$和$B$，若$A\supset B$，则<br>（1）$P(A-B)&#x3D;P(A)-P(B)$<br>（2）$P(A)\geq P(B)$（概率的单调性）</p>
<p>$Proof$：将$A$分为两个互不相容事件$B$与$A-B$的并，由可列可加性公理得：$P(A)&#x3D;P(B)+P(A-B)$<br>再有非负性公理：$P(A-B)\geq 0$，即可得到（2）。</p>
<p>5.对任一事件$A$，有$0\leq P(A) \leq 1$<br>$Proof$：对任一事件$A$，总有:$\phi \subset A \subset \Omega$，由概率的单调性知$P(\phi)\leq P(A) \leq P(\Omega)$则有$0\leq P(A) \leq 1$。</p>
<p>6.对任意两个事件$A$和$B$，有：<br>（1）$P(A\cup B)&#x3D; P(A)+P(B)-P(AB)$<br>（2）$P(A\cup B)\leq P(A)+P(B)$</p>
<p>$Proof$：由于并事件可以写成两个互不相容的事件$A$与$B-AB$的并，从可加性公理有$P(A)&#x3D;P(B)+P(B-AB)$，又因为$B \supset AB$，则由性质4（1）有：$P(B-AB)&#x3D;P(B)-P(AB)$，带回即有（1）。再由$P(AB)\geq 0$立即得到（2）。</p>
<p>注记：将集合拆成几个不相交集合的并是集合论证明中常用的方法。</p>
<p>$Ex$：对任意两个事件A与B，证明$P(A)&#x3D;P(AB)+P(A\bar{B})$</p>
<p>$Ex2$：对任一三个事件$A,B,C$有：<br>（1）$P(A\cup B\cup C)&#x3D;P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)$<br>（2）$P(A\cup B\cup C)\geq P(A)+P(B)+P(C)$</p>
<br />

<p>$Eg$：设$P(A)&#x3D;1&#x2F;3,P(B)&#x3D;1&#x2F;2$<br>（1）：若事件$A$和$B$互不相容，求$P(B\bar{A})$<br>（2）：若$A\subset B$求$P(B\bar{A})$<br>（3）：若$P(AB)&#x3D;1&#x2F;8$，求$P(B\bar{A})$</p>
<p>$Sol$：<br>（1）因为$A$，$B$互不相容，所以$A\cap B &#x3D; \phi$，即$B \subset \bar{A}$，即有$\bar{A}&#x3D;B$，故$P(B\bar{A})&#x3D;P(B)&#x3D;1&#x2F;2$<br>（2）因为$P(B)&#x3D;P(AB)+P(B\bar{A})$且$A\subset B$，所以$P(AB)&#x3D;P(A)&#x3D;1&#x2F;3$，则有<br>$P(B\bar{A})&#x3D;$ $P(B)-P(AB)&#x3D;1&#x2F;6$<br>（3）同（2），有$P(B\bar{A})&#x3D;P(B)-P(AB)&#x3D;1&#x2F;2-1&#x2F;8&#x3D;3&#x2F;8$</p>
<br />

<p>$eg2$：某人对事件$A,B$及其并$A\cup B$分别给出主观概率如下：$P(A)&#x3D;1&#x2F;3,P(B)&#x3D;1&#x2F;3,P(A\cup B)&#x3D;3&#x2F;4$<br>按概率性质，应有$P(A\cup B)\leq P(A)+P(B)$，然而现在$P(A\cup B)&#x3D;3&#x2F;4$，$P(A)+P(B)&#x3D;2&#x2F;3$这个性质不满足。问题是出在了主管概率给定不恰当引起的。例如将$P(A\cup B)$修整成$3&#x2F;5$即可。</p>
<h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><p>$Def$：对任意两个事件$A,B$，若有$P(AB)&#x3D;P(A)+P(B)$，则称事件$A$与事件$B$相互独立，简称$A$和$B$独立。否则称事件$A$和$B$不独立。</p>
<p>注记：独立与互不相容没有必然联系，独立表示两件事件之间没有关系，而互不相容表示两件事件之间不可能同时发生。</p>
<p>$Th$：若事件$A$和$B$独立，则$A$与$\bar{B}$独立，$\bar{A}$与$B$独立，$\bar{A}$与$\bar{B}$独立。</p>
<p>$Proof$：$A\bar{B}&#x3D;A-AB$，又因为$AB\subset A$，再由A与B的独立性知：<br>$P(A\bar{B})&#x3D;P(A)-P(AB)&#x3D;P(A)-P(A)P(B)&#x3D;P(A)(1-P(B))&#x3D;P(A)P(\bar{B})$<br>其余的类似可证。</p>
<h4 id="多个事件的独立性"><a href="#多个事件的独立性" class="headerlink" title="多个事件的独立性"></a>多个事件的独立性</h4><p>设有$n$个事件$A_1,A_2,\cdots A_n$，假如对所有可能的$1\leq i&lt;j&lt;k&lt;\cdots \leq n$以下等式均成立：</p>
<p>$<br>\begin{cases}<br>P(A_iA_j)&#x3D;P(A_i)P(A_j) \\<br>P(A_iA_jA_k)&#x3D;P(A_i)P(A_j)P(A_k) \\<br>\cdots \\<br>P(A_1A_2\cdots A_n)&#x3D;P(A_1)P(A_2)\cdots P(A_n) \\<br>\end{cases}<br>$</p>
<p>则称这$n$个事件相互独立。</p>
<p>注记：只满足$P(A_iA_j)&#x3D;P(A_i)P(A_j)$是不可以的，我们有伯恩斯坦反例：</p>
<p>一个均匀的正四面体，第一面染上红色，第二面染上白色，第三面染上黑色，第四面同时染上红，白，黑三种颜色。记事件 $A,B,C$分别表示投一次均匀的正四面体出现红，白，黑颜色的事件。则$P(A)&#x3D;P(B)&#x3D;P(C)&#x3D;1&#x2F;2$，$P(AB)&#x3D;P(AC)&#x3D;P(BC)&#x3D;1&#x2F;4$，但是$P(ABC)&#x3D;1&#x2F;4$</p>
<p>本质是因为只有两两独立我们推不出$AB$和$C$独立、$A\cup B$和$C$独立。</p>
<p>有一个更直观的例子是波罗梅奥环，可以自行查阅。</p>
<h4 id="试验的独立性"><a href="#试验的独立性" class="headerlink" title="试验的独立性"></a>试验的独立性</h4><p>假设有$n$个试验$E_1,E_2,\cdots E_n$，假设$E_1$的任一结果，$E_2$的任一结果，$\cdots $  $ E_n$的任一结果都是相互独立的事件，则称试验  $E_1,E_2,\cdots E_n$是相互独立。如果这$n$次试验是相同的，则称其为$n$次独立重复试验。</p>
<p>$eg$：扔一枚硬币和扔一颗骰子是相互独立试验。</p>
<h3 id="n重伯努利试验"><a href="#n重伯努利试验" class="headerlink" title="n重伯努利试验"></a>n重伯努利试验</h3><p>$Def($伯努利试验$)$：只有两个结果$(A$和$\bar{A})$的试验称为伯努利试验。</p>
<p>在一次伯努利试验中，设发生$A$的概率为$p$，则有$P(A)&#x3D;p,P(\bar{A})&#x3D;1-p$</p>
<p>$Def(n$重伯努利试验$)$：由$n$次相同的，独立的伯努利试验组成的多随机试验成为$n$重伯努利试验。</p>
<p>$n$重伯努利试验可以用长度为$n$的$A$和$\bar{A}$的序列表示。</p>
<h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>$Def($条件概率$)$：设$A$和$B$是样本空间$\Omega$中的两个事件，且$P(B)&gt;0$，在事件$B$已经发生的条件下，事件$A$的条件概率$P(A|B)$定义为$\frac{P(AB)}{P(B)}$。</p>
<h4 id="条件概率的性质："><a href="#条件概率的性质：" class="headerlink" title="条件概率的性质："></a>条件概率的性质：</h4><p>1.条件概率是概率，即满足概率的$3$条公理。</p>
<p>2.（乘法公式）：对任意两个事件$A$和$B$，有：<br>$$P(AB)&#x3D;P(A|B)P(B)&#x3D;P(B|A)P(A)$$其中第一个等式要求$P(B)&gt;0$，第二个等式要求$P(A)&gt;0$</p>
<p>怎么理解？<br>通俗的来说，以第一个等式为例：$P(B)$表示将样本空间$\Omega$限制在了集合$B$上，$P(A|B)$代表将集合$A$限制在了集合$B$上。</p>
<p>2的结论还可以推广到多个事件</p>
<p>3.（一般乘法公式）：对任意$3$个事件$A,B,C$，假若$P(BC)&gt;0$，则有：$$P(ABC)&#x3D;P(A)P(B|A)P(C|AB)$$</p>
<p>$Def$：把样本空间$\Omega$分为$n$个事件$B_1,B_2,\cdots, B_n$，假如：<br>（1）$P(B_i)&gt;0,i&#x3D;1,2,\cdots, n$<br>（2）$B_1,B_2,\cdots B_n$互不相容<br>（3）$\bigcup\limits_{i&#x3D;1}^n B_i&#x3D;\Omega$<br>则称事件组$B_1,B_2,\cdots B_n$为样本空间$\Omega$的一个分割。</p>
<p>4.（全概率公式）：设$B_1,B_2,\cdots B_n$是样本空间$\Omega$的一个分割，则对$\Omega$的任意一事件$A$，有<br>$$P(A)&#x3D;\sum\limits_{i&#x3D;1}^nP(A|B_i)P(B_i)$$</p>
<p>怎么理解？<br>把$B_i$看成每个小空间，讲$B_i$上$A$发生的概率加起来就是$A$在$\Omega$上发生的概率。</p>
<p>5.（贝叶斯公式）：设事件$B_1,B_2,\cdots, B_n$是样本空间$\Omega$的一个分割，且他们各自的概率皆已知且为正，又设$A$是$\Omega$中的一个事件，$P(A)&gt;0$，且在$B_i$给定下事件$A$的条件概率$P(A|B_1),P(A|B_2),\cdots,P(A|B_n)$已知。则在$A$给定下，事件$B_k$的条件概率为：<br>$$P(B_k|A)&#x3D;\frac{P(A|B_k)P(B_k)}{P(A)}&#x3D;\frac{P(A|B_k)P(B_k)}{\sum\limits_{i&#x3D;1}^n P(A|B_i)P(B_i)}$$</p>
<p>我们称$P(B_k|A)$为后验概率，而$P(B_k)$为先验概率。</p>
<p>怎么理解？<br>我们把$B_i$看成一个人的决策集合，$P(B_i)$代表做$B_i$的决策的概率，现在通过试验我们得到了一个结果$A$，利用$A$我们可以得到$A$发生的时候$B_i$发生的概率，这样为做决策得到了试验的依据，可以根据试验情况改变决策。</p>
<h4 id="条件概率的例子"><a href="#条件概率的例子" class="headerlink" title="条件概率的例子"></a>条件概率的例子</h4><p>下面对于三个公式各给出一个例子</p>
<p>$eg1$（波利亚坛子模型）：设摊子内有$b$个黑球和$r$个红球，每次随机取出一个球， 把原球放回，还加进（与取出的球）同色的$c$个和异色球$d$个，这里$c$和$d$都是已知的整数。设$B_i$表示“第$i$次取出的是黑球”这一事件，$R_j$表示“第$j$次取出的是红球”这一事件，我们来研究下面几个事件的概率：<br>$$ P(B_1R_2R_3)&#x3D;P(B_1)P(R_2|B_1)P(R_3|R_2B_1)&#x3D;\frac{b}{b+r}\cdot\frac{r+d}{(b+c)+(r+d)}\cdot\frac{r+d+c}{(b+c+d)+(r+d+c)}$$</p>
<p>$$P(R_1B_2R_3)&#x3D;P(R_1)P(B_2|R_1)P(R_3|B_2R_1)&#x3D;\frac{r}{b+r}\cdot\frac{b+d}{(b+d)+(r+c)}\cdot\frac{r+c+d}{(b+d+c)+(r+c+d)} $$</p>
<p>$$ P(R_1R_2B_3)&#x3D;P(R_1)P(R_2|R_1)P(B_3|R_2R_1)&#x3D;\frac{r}{b+r}\cdot\frac{r+c}{(b+d)+(r+c)}\cdot\frac{b+2d}{(b+d+d)+(r+c+c)}$$</p>
<p>可以发现，这三个概率不一样，表明黑球出现的次序在影响着概率。</p>
<p>我们研究几个特殊的情况：</p>
<p>（1）$c&gt;0,d&#x3D;0$。这意味着每次取出球后会增加下一次也取到同色球的概率，这是一个传染病模型。每次发现一个传染病患者，以后都会增加再传染的概率。在这种情况下，上面三个概率分别为：</p>
<p>$$ P(B_1R_2R_3)&#x3D;\frac{b}{b+r}\cdot\frac{r}{(b+c)+(r)}\cdot\frac{r+c}{(b+c)+(r+c)}$$</p>
<p>$$P(R_1B_2R_3)&#x3D;\frac{r}{b+r}\cdot\frac{b}{(b)+(r+c)}\cdot\frac{r+c}{(b+c)+(r+c)} $$</p>
<p>$$ P(R_1R_2B_3)&#x3D;\frac{r}{b+r}\cdot\frac{r+c}{(b)+(r+c)}\cdot\frac{b}{(b)+(r+c+c)}$$</p>
<p>可以发现这三个概率相同，这表明在$d&#x3D;0$的时候，上述概率只与黑球和红球的次数有关，而与次序无关。</p>
<p>（2）$c&#x3D;0,d&gt;0$这是一个安全模型，每当发生事故（抓出红球）的时候安全工作就抓紧一些（放入黑球），否则就放松一些（放入红球），在这种情况下，上述三个概率分别为：</p>
<p>$$ P(B_1R_2R_3)&#x3D;\frac{b}{b+r}\cdot\frac{r+d}{(b)+(r+d)}\cdot\frac{r+d}{(b+d)+(r+d)}$$</p>
<p>$$P(R_1B_2R_3)&#x3D;\frac{r}{b+r}\cdot\frac{b+d}{(b+d)+(r)}\cdot\frac{r+d}{(b+d)+(r+d)} $$</p>
<p>$$ P(R_1R_2B_3)&#x3D;\frac{r}{b+r}\cdot\frac{r+c}{(b+d)+(r)}\cdot\frac{b+2d}{(b+d+d)+(r)}$$</p>
<p>这三个概率不相同，说明出事故的顺序影响着第$k$次出事故的概率。</p>
<p>（3）$c&#x3D;0,d&#x3D;0$，这是放回模型，抽$n$次抽出红球的次数这一随机变量服从二项分布$B(n,r&#x2F;(b+r))$<br>（4）$c&#x3D;-1,d&#x3D;0$，这是不放回模型，抽$n$次抽出红球的次数这一随机变量服从超几何分布。</p>
<br />

<p>$eg2$（敏感问题调查模型）：调查敏感问题时，有些人不愿如实回答，这时我们可以设计两个问题：</p>
<p>A：你的生日是否在7月1日以前？<br>B为敏感问题。</p>
<p>在问卷上我们只有是和否两个选项，同时设置一个包含红球和黑球的罐子，若抽出红球则回答A，否则回答B。且设罐中有红球$r$个，有黑球$b$个。（我们认为这个过程没有人监督，即所有填写问卷的人都如实回答。）<br>在调查后，我们可以得到问卷中填是的频率是$f&#x3D;\frac{k}{n}$，我们用频率估计概率得到$P(是)&#x3D;\frac{k}{n}$。<br>这里回答“是”有两种情况。一种是摸到红球回答“是”，一种是摸到黑球回答“是”。<br>对于第一种情况我们认为$P(是|红球)&#x3D;0.5$，而对于第二种情况，我们想知道的就是$P(是|黑球)$，设为$p$。<br>我们可以得到：<br>$$P(是)&#x3D;P(红球)\cdot P(是|红球)+P(黑球)\cdot P(是|黑球)$$<br>即：<br>$$\frac{k}{n}&#x3D;\frac{r}{r+b}\cdot 0.5 + \frac{b}{b+r}\cdot p$$<br>由此我们可以直接解出$p$。</p>
<br />

<p>$eg3$：为提高公司产品的质量，公司经理经过考虑后增加投资来改进生产设备，但从投资效果来看，下属部门有两种意见：<br>$$B_1：改进生产设备后，高质量产品可以占90\%$$<br>$$B_2：改进生产设备后，高质量产品可以占70\%$$<br>经理认为两种事件发生的概率为等可能的，即$P(B_1)&#x3D;P(B_2)&#x3D;0.5$。<br>经过试验一次试验$A$，试验结果为：试制了五个产品，全是高质量产品。<br>经理希望用此结果去改变其对最初观点的看法。我们由贝叶斯公式可以知道：<br>$$P(B_1|A)&#x3D;\frac{P(A|B_1)P(B_1)}{P(B_1)P(A|B_1)+P(B_2)P(A|B_2)}&#x3D;\frac{0.5\cdot 0.9^5}{0.5\cdot 0.9^5+0.5\cdot 0.7^5}$$</p>
<p>$$P(B_2|A)&#x3D;\frac{P(A|B_2)P(B_2)}{P(B_1)P(A|B_1)+P(B_2)P(A|B_2)}&#x3D;\frac{0.5\cdot 0.7^5}{0.5\cdot 0.9^5+0.5\cdot 0.7^5}$$</p>
<p>显然$P(B_1|A)&gt;P(B_2|A)$，所以经理对$B_1$更加信任。</p>
<p>注记：这个例子反映了机器学习中贝叶斯学习的过程。在机器学习中，试验$A$即为训练集中各个标签的频率，然后我们得到了后验概率后就可以在验证集中每个元素的分类。</p>
]]></content>
      <categories>
        <category>概率论</category>
        <category>随机事件及概率</category>
      </categories>
      <tags>
        <tag>条件概率</tag>
        <tag>贝叶斯公式</tag>
        <tag>概率</tag>
        <tag>独立性</tag>
      </tags>
  </entry>
  <entry>
    <title>随机变量及其分布复习笔记</title>
    <url>/2022/04/23/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>随机变量及其分布复习笔记</p>
<span id="more"></span>

<h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><h3 id="什么是随机变量"><a href="#什么是随机变量" class="headerlink" title="什么是随机变量"></a>什么是随机变量</h3><p>用来表示随机现象结果的变量就是随机变量，常用大写字母$X,Y,Z$表示，而随机变量所取的值常用小写字母 $x,y,z$表示。若用等号或不等号把$X$和$x$联系起来就能表示事件，比如“$X&#x3D;x$”,“$Y\leq y$” , “$z_1&lt; Z \leq z_2$”都是事件。</p>
<p>怎么用数学语言表示？</p>
<p>$Def:$定义在样本空间$\Omega$上的实值函数$X&#x3D;X(\omega)$称为随机变量。在实数集上仅取有限个或可列个孤立点的随机变量成为离散型随机变量，可能取值在实数轴上的一个区间$(a,b)$的随机变量称为连续型随机变量，其中$a$可以是$-\infty$，$b$可以是$+\infty$。</p>
<p>可以看到，随机变量就是将样本空间上的每一个事件映射到一个实数的函数。</p>
<p>例如抛出$n(n\geq3)$枚硬币，设随机变量$X$为硬币正面朝上的次数，再设$\omega&#x3D;$朝上的硬币次数为$3$次。则我们可以令$X(\omega)&#x3D;3$。这是非常符合直觉的。</p>
<h3 id="随机变量的分布函数"><a href="#随机变量的分布函数" class="headerlink" title="随机变量的分布函数"></a>随机变量的分布函数</h3><p>$Def$：设$X$是一个随机变量，对任意实数$x$，事件$X\leq x$的概率是$x$的函数，记为：$F(x)&#x3D;P(X\leq x)$这个函数称为$X$的累积分布函数，简称分布函数。</p>
<p>分布函数的一些基本性质：<br>（1）$0\leq F(x)\leq 1$（因为$F(x)$是概率）<br>（2）$\lim\limits_{x\rightarrow -\infty} F(x)&#x3D;0$（事件$X&lt;-\infty$是不可能事件）<br>（3）$\lim\limits_{x\rightarrow +\infty} F(x)&#x3D;1$（事件$X&lt;+\infty$是必然事件）<br>（4）$F(x)$是非降函数，即对$\forall x_1&lt;x_2$，有$F(x_1)\leq F(x_2)$。这是因为事件$X\leq x_2$包含$X\leq x_1$。<br>（5）$F(x)$右连续，即$\lim\limits_{x-&gt;x_0^+}F(x)&#x3D;F(x_0)$<br>对（5）的极限成立做一个简要证明。<br>$Proof$：令$A_n&#x3D;{X \leq x_0 +  \frac{1}{n}}$，则$\bigcap\limits_{n&#x3D;1}^\infty A_n&#x3D;{X\leq x_0}$，则<br>$$\lim\limits_{x-&gt;x_0^+}F(x)&#x3D;\lim\limits_{n\rightarrow \infty}F(x_0+\frac{1}{n})&#x3D;\lim\limits_{n\rightarrow \infty}P(A_n)&#x3D;P(\lim\limits_{n\rightarrow \infty}A_n)&#x3D;P(\bigcap\limits_{n&#x3D;1}^\infty A_n)&#x3D;P(X\leq x_0)&#x3D;F(x_0)$$</p>
<p>注记：上面的推到不严谨，其中第3，4个等号需要证明，感兴趣的读者可以翻阅实变函数中的集合论部分。<br>注记2：对于上面的（3）（4）（5），需要证明极限的存在性，其中（3）（4）的极限存在性可以类似于上面的证明给出，（5）的极限存在性可以用确界定理给出。（这几部分的证明都可以去翻阅实变函数的教材）<br>注记3：分布函数并不是左连续的，反例很容易给出。</p>
<h2 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h2><h3 id="分布列"><a href="#分布列" class="headerlink" title="分布列"></a>分布列</h3><p>$Def$：设$X$是离散随机变量，它的所有可能取值为$x_1,x_2,\cdots , x_n , \cdots$，假如$X$取$x_i$的概率为：$P(X&#x3D;x_i)&#x3D;p(x_i)$，且满足<br>（1）非负性：$p(x_i)\geq 0$<br>（2）正则性：$\sum\limits_{i&#x3D;1}^\infty p(x_i)&#x3D;1$<br>则称这组概率${p(x_i)}$为随机变量$X$的分布列，或$X$的概率分布。</p>
<p>若已知$X$的分布列，则可以很容易的写出$X$的分布函数：$F(x_0)&#x3D;\sum\limits_{x_i\leq x} p(x_i)$</p>
<p>离散型随机变量的分布列还可以用如下表格来表示：</p>
<table>
<thead>
<tr>
<th>$X$</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$\cdots$</th>
<th>$x_n$</th>
<th>$\cdots$</th>
</tr>
</thead>
<tbody><tr>
<td>$P$</td>
<td>$p_1$</td>
<td>$p_2$</td>
<td>$\cdots$</td>
<td>$p_n$</td>
<td>$\cdots$</td>
</tr>
</tbody></table>
<p>除了表格，其还可以用线条图或者概率分布直方图来表示一个随机变量。</p>
<h3 id="伯努利概型中的一些分布"><a href="#伯努利概型中的一些分布" class="headerlink" title="伯努利概型中的一些分布"></a>伯努利概型中的一些分布</h3><h4 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h4><p>$Def$：令$X$为$n$重伯努利试验中成功出现的次数，则$X$是一个随机变量。用$B_{n,k}$表示$n$重伯努利试验中成功出现$k$次，则有$B_{n,k}&#x3D;$“$X&#x3D;k$”，其中$X$的可能取值为$0,1,\cdots ,n$，它取这些值的概率为：$$P(X&#x3D;k)&#x3D;C_n^k\cdot p^k\cdot (1-p)^{(n-k)},k&#x3D;0,1,\cdots ,n$$我们称这个概率分布为二项分布，记为$b(n,p)$。在概率论中“随机变量$X$的概率分布为二项分布$b(n,p)$”常被说成“随机变量$X$服从二项分布$b(n,p)$，<font color="#dd0000">记做$X\sim b(n,p)$</font>。</p>
<h4 id="两点分布"><a href="#两点分布" class="headerlink" title="两点分布"></a>两点分布</h4><p>$n&#x3D;1$的二项分布$b(1,p)$就称为两点分布（也称伯努利分布或者0-1分布）。其概率分布为：<br>$$<br>P(X&#x3D;k)&#x3D;\begin{cases}<br>p &amp; k&#x3D;1 \\<br>(1-p) &amp; k&#x3D;0<br>\end{cases}<br>$$</p>
<h4 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h4><p>我们讨论在伯努利试验中首次出现成功出现在第$k$次的概率，记成功的概率为$p$。若想第$k$次试验首次出现成功，我们需要在前$k-1$次试验中均失败，并且恰好在第$k$次试验出现成功。记$$g(k,p)&#x3D;(1-p)^{k-1}p ~~~~ k&#x3D;1,2,\cdots$$<br>我们称这个分布为几何分布</p>
<p>注记：这个分布的样本空间不是有限的。</p>
<p>注记2：几何分布具有无记忆性，即$$P(X &#x3D; s+t|X\geq s)&#x3D;\frac{P(x &#x3D;  s+t)}{P(X \geq s)}&#x3D;\frac{(1-p)^{s+t-1}\cdot p}{(1-p)^{s}} &#x3D; (1-p)^{t-1} \cdot p $$<br>这说明假定前$s$次没有出现成功，那么再经过$t$次试验成功的概率和直接进行$t$次试验成功的概率是相同的。与此同时，离散型随机变量中，只有几何分布有无记忆性。</p>
<h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>如果随机变量$X$有如下的概率分布：</p>
<p>$$P(X&#x3D;k)&#x3D;\frac{\lambda^k}{k!}e^{-\lambda}$$</p>
<p>就称$X$服从参数设$\lambda$的泊松分布。<font color="#dd0000">记做$X\sim P(\lambda)$</font>。</p>
<p>泊松分布的由来？</p>
<p>先看一个例子：<br>$eg$：某年龄段的保险者中，一年中每个人死亡的概率为$0.005$，现有$10000$个这类人参加保险，保险公司想知道在未来一年中有$40$个人死亡的概率</p>
<p>我们从二项分布可以知道$b(40;10000,0,005)&#x3D;C_{10000}^{40}(0.005)^{40}(0.995)^{9960}$（<font color="#dd0000">我们用$b(k,n,p)$表示$n$重伯努利试验中$A$出现$k$次的概率</font>）而直接计算这个数值相当困难，我们需要有更好的计算方法。</p>
<p>于是我们有泊松逼近定理：</p>
<p>$Th$：在独立试验中，以$p_n$代表事件$A$在试验中出现的概率。它与试验总数$n$有关，如果$np_n\rightarrow\lambda$，则当$n\rightarrow \infty$是，</p>
<p>$$b(k;n,p_n)\rightarrow\frac{\lambda^k}{k!}e^{-\lambda}$$</p>
<p>$Proof$：记$\lambda_n&#x3D;np_n$，则<br>$b(k;n,p_n)&#x3D;C_n^kp_n^k(1-p)^{n-k}&#x3D;\frac{n(n-1)\cdots(n-k+1)}{k!}(\frac{\lambda_n}{n})^k(1-\frac{\lambda_n}{n})^{n-k} $<br>$&#x3D;\frac{\lambda_n^k}{k!}(1-\frac{1}{n})\cdots (1-\frac{k-1}{n})(1-\frac{\lambda_n}{n})^{n-k}$</p>
<p>对于固定的$k$有<br>$$\lim\limits_{n\rightarrow\infty}\lambda_n^k&#x3D;\lambda^k，~~ \lim\limits_{n\rightarrow\infty}(1-\frac{\lambda_n}{n}^{n-k})&#x3D;e^{-\lambda}$$<br>和<br>$$\lim\limits_{n\rightarrow\infty}(1-\frac{1}{n})\cdots (1-\frac{k-1}{n})&#x3D;1$$</p>
<p>因此$$\lim\limits_{n\rightarrow\infty}b(k;n,p_n)&#x3D;\frac{\lambda^k}{k!}e^{-\lambda}$$</p>
<p>在应用中，当$p$相当小（一般当$p\leq0.1$时）我们用如下的近似公式：$$b(k;n,p)\approx\frac{(np)^k}{k!}e^{-np}$$</p>
<p>这就解决了上面二项分布不容易算的问题。</p>
<p>泊松分布发明不止是用来逼近二项分布的，我们还有如下的泊松过程：</p>
<p>考虑来到某交换装置的电话呼叫数，假定它具有下面三个性质：<br>（1）平稳性：在$[t_0,t_0+t)$中来到的呼叫数只与时间间隔长度$t$有关而与时间起点$t_0$无关。<br>（2）独立增量性：在$[t_0,t_0+t)$内来到$k$个呼叫这一事件与$t_0$之前发生的事件独立。<br>（3）普通性：在充分晓得时间间隔中，最多来一个呼叫。若记$\psi(t)&#x3D;1-P_0(t)-P_1(t)&#x3D;\sum\limits_{i&#x3D;2}^\infty P_i(t)$，则应有$\lim\limits_{t\rightarrow 0}\frac{\psi(t)}{t}&#x3D;0$</p>
<p>在这个过程中，可以求得$P_k(t)&#x3D;\frac{(\lambda t)^k}{k!}e^{-\lambda t}$，这正是泊松分布。</p>
<p>详细证明可以参考概率论教材。</p>
<h3 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h3><p>假设有$N$个产品组成的总体，其中含有$M$个不合格品，若丛中随机不放回地抽取$n$个，则其中含有不合格品的个数$X$是一个离散随机变量。假如$n\leq M$，则$X$可以取$0,1,\cdots , n$；若$n&gt;M$，则$X$可能取$0,1,\cdots M$。由古典概型可以计算得：<br>$$P(X&#x3D;x)&#x3D;\frac{C_M^xC_{N-M}^{n-x}}{C_N^n} ~~ x&#x3D;0,1,\cdots r$$<br>其中$r&#x3D;min(n,M)$。<font color="#dd0000">这个分布称为超几何分布，它有三个参数$N,M,n$，记为$h(n,N,M)$</font></p>
<h2 id="连续型随机变量"><a href="#连续型随机变量" class="headerlink" title="连续型随机变量"></a>连续型随机变量</h2><h3 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h3><p>$Def$：设$p(x)$设定义在整个实数轴上的一个函数，假如它满足如下两个性质：<br>（1）非负性：$p(x)\geq 0$<br>（2）正则性：$\int_{-\infty}^{\infty}p(x)dx&#x3D;1$<br>则称$p(x)$是概率密度函数，或密度函数。若随机变量$X$取值的统计规律性可用某个概率密度函数$p(x)$描述，则称$p(x)$为$X$的概率分布，记为$X\sim p(x)$</p>
<p>有了概率密度函数之后，随机变量$X$的分布函数就可以写成如下形式：</p>
<p>$$F(x)&#x3D;\int_{-\infty}^x p(x)dx$$</p>
<p>注记1：概率密度函数不是概率，即$P(X&#x3D;x)\neq p(x)$，事实上，对于$\forall x$,$$P(X&#x3D;x)&#x3D;\lim_{\Delta x \rightarrow 0}P(x+\Delta x)-P(x) &#x3D; \lim_{\Delta x \rightarrow 0} \int_x^{x+\Delta x}p(x)dx &#x3D; 0$$但是我们在$(x,x+\Delta x)$的概率密度可以用$\int_{x}^{x+\Delta x}p(x)dx$来求。类似的，$P(a\leq X \leq b)&#x3D;\int_{a}^{b}p(x)dx$</p>
<p>注记2：我们将概率为零的事件称为零概率事件，但是零概率小事件和不可能事件是有差距的：不可能事件一定是零概率事件，但是零概率事件不一定是不可能事件。同样的，必然事件发生的概率为1，但是发生概率为1的事件不一定是必然事件，我们一般称概率为1的事件为几乎必然发生的事件。</p>
<h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><p>$Def$：若$a,b(b&gt;a)$为有限数，则由下列函数给定的分布称为均匀分布：<br>$$<br>p(x)&#x3D;\begin{cases}<br>\frac{1}{b-a} &amp; a\leq x \leq b\\<br>0 &amp; otherwise<br>\end{cases}<br>$$</p>
<p>对应的分布函数为：<br>$$<br>F(x)&#x3D;\begin{cases}<br>0 &amp; x \leq a\\<br>\frac{x-a}{b-a} &amp; a &lt; x \leq b \\<br>1 &amp; b \leq x<br>\end{cases}<br>$$</p>
<p>注记：我们仍需令其满足分布函数的右连续性，有些课本上将第二个条件写成$a\leq x \leq b$，其实这是不严谨的。</p>
<h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><p>分布密度函数为</p>
<p>$$<br>p(x)&#x3D;\begin{cases}<br>\lambda e^{-\lambda x} &amp; x \geq 0 \\<br>0 &amp; x&lt;0<br>\end{cases}<br>$$</p>
<p>分布函数为</p>
<p>$$<br>F(x)&#x3D;\begin{cases}<br>1- e^{-\lambda x} &amp; x \geq 0 \\<br>0 &amp; x&lt;0<br>\end{cases}<br>$$</p>
<p>其中$\lambda &gt;0$，是参数，这种分布称为指数分布，简记为$Exp(\lambda)$</p>
<p>指数分布有重要的应用，我们常用它来做各种“寿命”的近似，例如电子元器件的寿命等。</p>
<p>指数分布还有类似于几何分布的无记忆性，设$X$服从指数分布，则对$\forall x&gt;0,t&gt;0$，<br>$$P\{X\geq s+t|X\geq s \} &#x3D; \frac{P\{ X\geq s+t\}}{P\{ X\geq s\}} &#x3D; \frac{e^{-\lambda(s+t)}}{e^{-\lambda s}} &#x3D; e^{-\lambda t}$$</p>
<h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p>密度函数为<br>$$p(x)&#x3D;\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}} ~~~ -\infty &lt; x &lt; \infty$$<br>其中$\sigma &gt; 0$，$\mu$和$\sigma$都为常数，相应的分布函数为<br>$$F(x)&#x3D;\int_{-\infty}^x \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(y-\mu)^2}{2\sigma^2}} ~~~ -\infty &lt; y &lt; \infty$$</p>
<p>这种分布称为正态分布，简记为$N(\mu,\sigma ^2)$</p>
<p>特别的，当$\mu&#x3D;0,\sigma&#x3D;1$的时候，这个分布称为标准正态分布，记为$N(0,1)$，相应的密度函数和概率分布函数分解记为$\phi(x)$和$\Phi(x)$</p>
<p>注记：若$X \sim N(\mu,\sigma^2)$，则$U&#x3D;\frac{X-\mu}{\sigma} \sim N(0,1)$。称这样的变换为$X$的标准化变换，称$U$为$X$的标准化随机变量。</p>
<p>注记2：设$X\sim N(\mu,\sigma^2)$，则<br>$$P(a&lt;X&lt;b)&#x3D;\Phi(\frac{b-\mu}{\sigma})-\Phi(\frac{a-\mu}{\sigma})$$</p>
<p>注记3：设$X\sim N(0,1)$，则</p>
<p>$$<br>P(|X-\mu|&lt;k\sigma)&#x3D;\begin{cases}<br>0.6826 &amp; k&#x3D;1 \\<br>0.9544 &amp; k&#x3D;2 \\<br>0.9973 &amp; k&#x3D;3<br>\end{cases}<br>$$<br>我们可以看到落在$3$倍标准差外的样本设很少的，在数据处理的时候一般将其剔除。我们称其为$3\sigma$原则。</p>
]]></content>
      <categories>
        <category>概率论</category>
        <category>随机变量及其分布</category>
      </categories>
      <tags>
        <tag>随机变量</tag>
      </tags>
  </entry>
  <entry>
    <title>随机变量的数学特征复习笔记</title>
    <url>/2022/05/03/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%A6%E7%89%B9%E5%BE%81%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简要介绍数学期望，方差，矩，分位数</p>
<span id="more"></span>

<h2 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h2><p>在日常生活中，求平均值是一个很常见的一种运算，例如求平均分，平均工资等。假设我们有$n$个样本，取值分别为$x_1,x_2,\cdots ,x_n$，则他们的平均值即为：<br>$$\bar{x}&#x3D;\frac{x_1+x_2+\cdots +x_n}{n}$$<br>加入我们给这些数一个权值$w_1,w_2,\cdots ,w_n$，则令</p>
<p>$$\bar{x}&#x3D;\sum\limits_{i&#x3D;1}^n w_ix_i$$<br>称为这$n$个样本的加权平均。</p>
<p>$Def$：设$X$为一离散型随机变量，它取值$x_1,x_2,\cdots $对应概率为$p_1,p_2,\cdots$，如果级数<br>$$\sum_{i&#x3D;1}^\infty x_ip_i$$<br>绝对收敛，则将其称为$X$的数学期望，简称期望，或均值，记为$EX$。</p>
<p>注记：当$\sum\limits_{i&#x3D;1}^\infty |x_i|p_i$发散时，则说$X$的期望不存在。（此时即使$\sum\limits_{i&#x3D;1}^\infty x_ip_i$条件收敛，我们也可以通过调换顺序让其和为任意值。）</p>
<p>$Def2$：设$X$设连续型随机变量，当积分$\int_{-\infty}^\infty x p(x)dx$绝对收敛时，我们称它为$X$的数学期望，记做$EX$</p>
<p>从Riemann-Stieltjes积分的角度可以这么定义：<br>$Def3$：若$X$的分布函数为$F(x)$，则定义<br>$$EX&#x3D;\int_{-\infty}^\infty xdF(x)$$<br>为$X$的数学期望（我们这里还要求上述积分绝对收敛）。</p>
<h3 id="随机变量函数的数学期望"><a href="#随机变量函数的数学期望" class="headerlink" title="随机变量函数的数学期望"></a>随机变量函数的数学期望</h3><p>$Th$：若$g(x)$是一元博雷尔函数，且$\eta &#x3D; g(\xi)$，则<br>$$\int_{-\infty}^{\infty}ydF_\eta(y)&#x3D;\int_{-\infty}^{\infty}g(x)dF_\xi(x)$$</p>
<p>注记：等式左端是$\eta$的数学期望的计算公式，而右边是将$x$替换成了$g(x)$所得到的，我们可以证明这两者相等。</p>
<p>在离散型场合，我们有<br>$$Eg(\xi)&#x3D;\sum\limits_{i&#x3D;1}^\infty g(x_i)p(x_i)$$<br>在连续型场合，我们有<br>$$Eg(\xi)&#x3D;\int_{-\infty}^{\infty}g(x)p(x)dx$$</p>
<h3 id="数学期望的性质"><a href="#数学期望的性质" class="headerlink" title="数学期望的性质"></a>数学期望的性质</h3><p>性质1：设$a,b,c$为常数，若$a\leq \xi \leq b$，则$a\leq E\xi \leq b$，特别的$Ec&#x3D;c$。</p>
<p>性质2：线性性：对任一常数$c_i ~ i&#x3D;1,2,\cdots n$和$b$有<br>$$E(\sum\limits_{i&#x3D;1}^n c_iX_i+b)&#x3D;\sum\limits_{i&#x3D;1}^n c_iEX_i+b$$<br>特别地<br>$$E(\sum\limits_{i&#x3D;1}^n X_i)&#x3D;\sum\limits_{i&#x3D;1}^n EX_i$$</p>
<h3 id="数学期望的求法"><a href="#数学期望的求法" class="headerlink" title="数学期望的求法"></a>数学期望的求法</h3><p>我们在这里介绍几种分布的数学期望的求法。</p>
<p>1.二项分布$X\sim b(n,p)$</p>
<p>$$Ex&#x3D;\sum\limits_{k&#x3D;0}^n kC_n^kp^kq^{n-k}&#x3D;np\sum\limits_{k&#x3D;1}^nC_{n-1}^{k-1}p^{k-1}q^{n-k}&#x3D; np(p+q)^{n-1}&#x3D;np$$<br>注记：我们用到了组合恒等式$k\cdot C_n^k&#x3D;n\cdot C_{n-1}^{k-1}$和二项式定理。</p>
<p>2.柯西分布$p(x)&#x3D;\frac{1}{\pi}\cdot \frac{1}{1+x^2}$<br>由于$$\int_{-\infty}^{\infty}|x|\frac{1}{\pi \cdot (1+x^2)}&#x3D;\infty$$<br>因此柯西分布的数学期望不存在。<br>注记：事实上，上述积分甚至不条件收敛，但是其有柯西主值0。</p>
<p>3.正态分布$N(\mu,\sigma^2)$<br>令$Y&#x3D;\frac{X-\mu}{\sigma}$，则$Y\sim N(0,1)$我们有<br>$$EY&#x3D;\int_{-\infty}^{\infty}\frac{1}{\sqrt{2\pi}}\cdot xe^\frac{-x^2}{2}dx&#x3D;0$$<br>那么$EX&#x3D;E(\sigma Y+\mu)&#x3D;\mu$<br>注记：正态分布的第一个分量是其数学期望。</p>
<p>4.超几何分布的数学期望<br>设想一个不放回的抽样，令<br>$$<br>x_i&#x3D;\begin{cases}<br>1 &amp; 第i次抽得次品 \\<br>0 &amp; 第i次抽得好品<br>\end{cases}<br>$$<br>则$P(x_i&#x3D;1)&#x3D;\frac{M}{N}$，因此$EX_i&#x3D;\frac{M}{N}$，而$X&#x3D;X_1+\cdots + X_n$，表示$n$次不放回抽样中抽出的次品数。他服从上述超几何分布，则有<br>$$EX&#x3D;EX_1+\cdots EX_n&#x3D;\frac{nM}{N}$$</p>
<h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><p>$Def$：设随机变量$X$的$EX^2$存在，则称偏差$X-EX$平方的数学期望$E[X-EX]^2$为随机变量$X$的方差，记为$DX$或者$Var(X)$。</p>
<p>注记：<br>$$E(X-EX)^2&#x3D;E(X^2-2X\cdot EX+(EX)^2)&#x3D;EX^2-2EX\cdot EX+(EX)^2&#x3D;EX^2-(EX)^2$$<br>在实际计算的时候我们可以用此公式$来计算</p>
<h3 id="方差的性质"><a href="#方差的性质" class="headerlink" title="方差的性质"></a>方差的性质</h3><p>性质1:常数的方差为0<br>性质2:$D(X+c)&#x3D;DX$，这里$c$是常数<br>性质3:$D(cX)&#x3D;c^2DX$，这里$c$是常数<br>性质4:若$c\neq EX$，则$DX&lt;E(X-c)^2$<br>$Proof$:因为<br>$$DX&#x3D;E(X-EX)^2&#x3D;E((X-c)-(EX-c))^2&#x3D;E(X-c)^2-(EX-c)^2$$<br>所以$EX\neq c$时，$DX&gt;E(X-c)^2$.<br>注记：对于随机变量$X$,若他的数学期望$EX$和方差$DX$都存在，且$DX&gt;0$，我们有时可以考虑标准化随机变量$X^*&#x3D;\frac{X-EX}{\sqrt{DX}}$，显然$EX^*&#x3D;0,DX^*&#x3D;1$，这正是称$X^*$为标准化随机变量的理由。</p>
<h3 id="切比雪夫不等式"><a href="#切比雪夫不等式" class="headerlink" title="切比雪夫不等式"></a>切比雪夫不等式</h3><p>$Th$：对于任何具有有限方差的随机变量$X$，都有<br>$$P(|X-EX|\geq \epsilon)\leq \frac{DX}{\epsilon^2}$$</p>
<p>$Proof$：设$F(x)$是$X$的分布函数，则显然有<br>$$DX&#x3D;\int_{-\infty}^\infty(x-EX)^2dF(x)\geq \int\limits_{|x-EX|\geq \epsilon}(x-EX)^2dF(x)\geq \int\limits_{|x-EX|\geq \epsilon}\epsilon^2 dF(x)$$<br>$$&#x3D;\epsilon^2 P(|X-EX|\geq \epsilon)$$</p>
<p>注记：我们这里的积分仍然是$Riemann-Stieltjes$积分</p>
<h2 id="常见分布的数学期望和方差"><a href="#常见分布的数学期望和方差" class="headerlink" title="常见分布的数学期望和方差"></a>常见分布的数学期望和方差</h2><p>下面给出一些最常见的分布的数学期望和方差</p>
<h3 id="离散型"><a href="#离散型" class="headerlink" title="离散型"></a>离散型</h3><table>
<thead>
<tr>
<th>分布名称</th>
<th>概率分布或密度函数$p(x)$</th>
<th>数学期望</th>
<th>方差</th>
</tr>
</thead>
<tbody><tr>
<td>退化分布</td>
<td>$p_c&#x3D;1$ $(c$为常数$)$</td>
<td>$c$</td>
<td>$0$</td>
</tr>
<tr>
<td>两点分布</td>
<td>$p_k&#x3D;\begin{cases}q &amp; k&#x3D;0 \\ p &amp; k&#x3D;1 \end{cases},$     $~~~~ 0&lt;p&lt;1,q&#x3D;1-p$</td>
<td>$p$</td>
<td>$pq$</td>
</tr>
<tr>
<td>二项分布</td>
<td>$b(k;n,p)&#x3D;C_n^kp^kq^{n-k} ~~~ k&#x3D;0,1,\cdots n, ~~~ 0&lt;p&lt;1, ~~~ q&#x3D;1-p$</td>
<td>$np$</td>
<td>$npq$</td>
</tr>
<tr>
<td>泊松分布</td>
<td>$p(k;\lambda)&#x3D;\frac{\lambda^k}{k!}e^{-\lambda}, ~~~ k&#x3D;0,1,\cdots, ~~~ \lambda &gt;0$</td>
<td>$\lambda$</td>
<td>$\lambda$</td>
</tr>
<tr>
<td>几何分布</td>
<td>$g(k;p)&#x3D;q^{k-1}p, ~~~ k&#x3D;1,2,\cdots,~~~ 0&lt;p&lt;1, ~~~ q&#x3D;1-p$</td>
<td>$\frac{1}{p}$</td>
<td>$\frac{q}{p^2}$</td>
</tr>
<tr>
<td>超几何分布</td>
<td>$p_k&#x3D;\frac{C_M^k C_{N-M}^{n-k}}{C_N^n}, ~~~ M\leq N,n\leq N, ~~~ k&#x3D;0,1,\cdots min(M,n)$</td>
<td>$ \frac{nM}{N}$</td>
<td>$\frac{nM}{N}(1-\frac{M}{N})\cdot \frac{N-n}{N-1}$</td>
</tr>
</tbody></table>
<h3 id="连续型"><a href="#连续型" class="headerlink" title="连续型"></a>连续型</h3><table>
<thead>
<tr>
<th>分布名称</th>
<th>概率分布或密度函数$p(x)$</th>
<th>数学期望</th>
<th>方差</th>
</tr>
</thead>
<tbody><tr>
<td>正态分布$N(\mu,\sigma^2)$</td>
<td>$p(x)&#x3D;\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}, ~~~ -\infty &lt; x &lt; \infty , ~~~ \mu ,\sigma &gt;0$</td>
<td>$\mu$</td>
<td>$\sigma^2$</td>
</tr>
<tr>
<td>均匀分布 $U[a,b]$</td>
<td>$p(x)&#x3D;\begin{cases}\frac{1}{b-a} &amp; a\leq x \leq b \\ 0 &amp; otherwise \end{cases}, ~~~ a&lt;b$</td>
<td>$\frac{a+b}{2}$</td>
<td>$\frac{(b-a)^2}{12}$</td>
</tr>
<tr>
<td>指数分布$Exp(\lambda)$</td>
<td>$p(x)&#x3D;\begin{cases}\lambda e^{-\lambda x} &amp; x\geq 0 \\ 0 &amp; x&lt;0 \end{cases} ~~~ \lambda &gt;0$</td>
<td>$\frac{1}{\lambda}$</td>
<td>$\frac{1}{\lambda^2}$</td>
</tr>
<tr>
<td>$\chi^2$分布</td>
<td>$p(x)&#x3D;\begin{cases}\frac{1}{2^{n&#x2F;2}\Gamma(\frac{n}{2})}x^{\frac{n}{2}-1}e^{-\frac{x}{2}} &amp; x\geq 0 \\ 0 &amp; x&lt;0 \end{cases} ~~~ n\in \mathbb{Z}$</td>
<td>$n$</td>
<td>$2n$</td>
</tr>
<tr>
<td>柯西分布</td>
<td>$p(x)&#x3D;\frac{1}{\pi}\cdot \frac{\lambda}{\lambda^2+(x-\mu)^2},~~~ -\infty &lt; x &lt; \infty, ~~~ \lambda&gt;0 $</td>
<td>不存在</td>
<td>不存在</td>
</tr>
</tbody></table>
<h2 id="其他数学特征"><a href="#其他数学特征" class="headerlink" title="其他数学特征"></a>其他数学特征</h2><h3 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h3><p>$Def$：设$X$为随机变量，$c$为常数，$k$为正整数，则量$E(X-c)^k$（假如它存在）称为<font color="#dd0000">$X$分布关于$c$的$k$阶矩</font>。若$c&#x3D;0$，则量$EX^k$成为$X$分布的<font color="#dd0000">$k$阶原点矩</font>，记为$\mu_k$，若$c&#x3D;EX$，则量$E(X-EX)^k$称为$X$分布的<font color="#dd0000">$k$阶中心矩</font>，记为$\nu_k$。<br>注记1:一阶原点矩就是数学期望，二阶中心矩就是方差。在实际应用中很少应用四阶以上的矩。<br>注记2:由于$|X|^{k-1}\leq |X|^k+1$故$k$阶矩存在时，$k-1$阶矩也存在，从而低于$k$阶的矩都存在。<br>注记3:原点矩和中心矩可以互相表出。<br>$$\nu_k&#x3D;E(X-EX)^k&#x3D;E(X-\mu_1)^k&#x3D;\sum_{i&#x3D;0}^k C_k^i\mu_i(-\mu_1)^{k-i}$$<br>$$\mu_k&#x3D;EX^k&#x3D;E((X-\nu_1)+\nu_1)^k&#x3D;\sum_{i&#x3D;0}^k C_k^i \nu_{k-i}\mu_1^i$$</p>
<h3 id="分位数和中位数"><a href="#分位数和中位数" class="headerlink" title="分位数和中位数"></a>分位数和中位数</h3><p>$Def$：对$0&lt;p&lt;1$，若$F(x_p)\leq p \leq F(x_p^+)$，则称$x_p$为分布函数$F(x)$的$p$分位数。其中$x_{0.5}$称为中位数。</p>
<h3 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h3><p>$Def$：设$X$是离散型随机变量，则$X$的最可能取的值称为$X$分布的众数。</p>
]]></content>
      <categories>
        <category>概率论</category>
        <category>随机变量及其分布</category>
      </categories>
      <tags>
        <tag>方差</tag>
        <tag>数学期望</tag>
        <tag>矩</tag>
        <tag>分位数</tag>
      </tags>
  </entry>
  <entry>
    <title>高等代数拾遗</title>
    <url>/2022/09/05/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>查漏补缺前五章</p>
<p>参考书：高等代数北大第四版</p>
<span id="more"></span>

<p>这里讨论的多项式，向量组，矩阵都是在数域$P$上的。</p>
<h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><p>这里列出两个重要的定理：</p>
<p>$Th1:$如果不可约多项式$p(x)$是$f(x)$的$k$重因式$(k\geq 1)$，那么他是微商$f’(x)$的$k-1$重因式。</p>
<p>$Cor:$多项式$f(x)$没有重因式的充分必要条件是$f(x)$与$f’(x)$互素。</p>
<p>$Th2:$设$f(x)&#x3D;a_nx^n+a_{n-1}x^{n-1}+\cdots + a_0$是一个整系数多项式。如果有一个素数$p$，使得<br>$(1):p \nmid a_n$<br>$(2):p|a_{n-1},a_{n-2},\cdots, a_0$<br>$(3):p^2 \nmid a_0$<br>那么$f(x)$在有理数域上不可约。</p>
<p>一个经典的例子是$x^n+2$在有理数域上不可约，从而任意次多项式都可能再有理数域上不可约。</p>
<h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>本章主要是如何计算行列式，下面列出几个经典例子：</p>
<p>1.计算：<br>$$<br>D_n&#x3D;\begin{vmatrix}<br>        a_1-b_1 &amp; a_1-b_2 &amp; \cdots &amp; a_1-b_n \\<br>        a_2-b_1 &amp; a_2-b_2 &amp; \cdots &amp; ya_2-b_n \\<br>        \vdots &amp; \vdots &amp; &amp;  \vdots \\<br>        a_n-b_1 &amp; a_n-b_2 &amp; \cdots &amp; a_n-b_n \\<br>\end{vmatrix}<br>$$</p>
<p>在这里不列出详细过程，只列出答案：</p>
<p>$n&#x3D;1$时，行列式值为$a_1-b_1$</p>
<p>$n&#x3D;2$时，行列式值为$(a_1-a_2)(b_1-b_2)$</p>
<p>$n\geq 3$时，行列式值为 $0$</p>
<p>注记：计算行列式时，注意是否需要分类讨论。</p>
<br>
<br>

<p>2.计算：<br>$$<br>D_n&#x3D;\begin{vmatrix}<br>        x &amp; y &amp; y &amp; \cdots &amp; y &amp; y \\<br>        z &amp; x &amp; y &amp; \cdots &amp; y &amp; y \\<br>        z &amp; z &amp; x &amp; \cdots &amp; y &amp; y \\<br>        \vdots &amp; \vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots \\<br>        z &amp; z &amp; z &amp; \cdots &amp; x &amp; y \\<br>        z &amp; z &amp; z &amp; \cdots &amp; z &amp; x<br>\end{vmatrix}<br>$$</p>
<p>解：$x&#x3D;y$时，可以得到$D_n&#x3D;(x+(n-1)y)(x-y)^{n-1}$</p>
<p>$x\neq y$时，一个很经典的算法是将行列式化为$<br>\begin{vmatrix}<br>        x-y &amp; y &amp; y &amp; \cdots &amp; y &amp; y \\<br>        z-x &amp; x &amp; y &amp; \cdots &amp; y &amp; y \\<br>        0 &amp; z &amp; x &amp; \cdots &amp; y &amp; y \\<br>        \vdots &amp; \vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots \\<br>        0 &amp; z &amp; z &amp; \cdots &amp; x &amp; y \\<br>        0 &amp; z &amp; z &amp; \cdots &amp; z &amp; x<br>\end{vmatrix}<br>$后按照第一列展开，得到递推式：$D_n&#x3D;(x-y)D_{n-1}-y<br>\begin{vmatrix}<br>        1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \\<br>        z &amp; x &amp; \cdots &amp; y &amp; y \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots \\<br>        z &amp; z &amp; \cdots &amp; x &amp; y \\<br>        z &amp; z &amp; \cdots &amp; z &amp; x<br>\end{vmatrix}<br>$<br>$&#x3D;<br>(x-y)D_{n-1}-y<br>\begin{vmatrix}<br>        1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \\<br>        0 &amp; x-z &amp; \cdots &amp; y-z &amp; y-z \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots \\<br>        0 &amp; 0 &amp; \cdots &amp; x-z &amp; y-z \\<br>        0 &amp; 0 &amp; \cdots &amp; 0 &amp; x-z<br>\end{vmatrix}<br>$</p>
<p>$&#x3D;(x-y)D_{n-1}-y(x-z)^{n-1}$</p>
<p>用同样的方法还可得到$D_n&#x3D;(x-z)D_{n-1}-z(x-y)^{n-1}$</p>
<p>化简即有$D_n&#x3D;\frac{y(x-z)^n-z(x-y)^n}{y-z}$</p>
<br>
<br>

<p>3.计算</p>
<p>$$D_1&#x3D;\begin{vmatrix}<br>        1 &amp; 1 &amp; \cdots &amp; 1 \\<br>        x_1 &amp; x_2 &amp; \cdots &amp; x_{n} \\<br>        x_1^2 &amp; x_2^2 &amp; \cdots &amp; x_n^2 \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots \\<br>        x_1^{n-2} &amp; x_2^{n-2} &amp; \cdots &amp; x_n^{n-2} \\<br>        x_1^{n} &amp; x_2^{n} &amp; \cdots &amp; x_n^{n}<br>\end{vmatrix}$$</p>
<p>解：将其扩充为</p>
<p>$D&#x3D;\begin{vmatrix}<br>        1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \\<br>        x_1 &amp; x_2 &amp; \cdots &amp; x_{n} &amp; x_{n+1} \\<br>        x_1^2 &amp; x_2^2 &amp; \cdots &amp; x_n^2 &amp; x_{n+1}^2 \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots \\<br>        x_1^{n-2} &amp; x_2^{n-2} &amp; \cdots &amp; x_n^{n-2} &amp; x_{n+1}^{n-2} \\<br>        x_1^{n-1} &amp; x_2^{n-1} &amp; \cdots &amp; x_n^{n-1} &amp; x_{n+1}^{n-1} \\<br>        x_1^{n} &amp; x_2^{n} &amp; \cdots &amp; x_n^{n} &amp; x_{n+1}^{n}<br>\end{vmatrix}$</p>
<p>此行列式的值为$\prod\limits_{1\leq i &lt; j \leq n+1} (x_j-x_i)&#x3D;\prod\limits_{1\leq i &lt; j \leq n} (x_j-x_i) \times \prod\limits_{k&#x3D;1}^n(x_{n+1}-x_k)$<br>将扩充后的行列式按照最后一列展开，有<br>$D&#x3D;(-1)^{1+n+1}d_{1,n+1}+(-1)^{2+n+1}d_{2,n+1}+\cdots + (-1)^{n+1+n+1}d_{n+1,n+1}$<br>比较两边系数，有$(-1)^{n+n+1}D_1&#x3D;[x_{n+1}^{n-1}]D$，其中$[x^k]$表示$x^k$的系数。<br>$D_1&#x3D;(-1)^{n+n+1}\prod\limits_{1\leq i &lt; j \leq n} (x_j-x_i)\sum\limits_{k&#x3D;1}^n(-x_k)&#x3D;\prod\limits_{1\leq i &lt; j \leq n} (x_j-x_i)\sum\limits_{k&#x3D;1}^n x_k$</p>
<p>注记：对于一个不熟悉的行列式来说，我们要将其往我们熟悉的行列式上靠。</p>
<h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><p>这一章关于向量组的零碎的定理与推论较多，下面列出一些重要的和容易遗忘的：</p>
<p>1.设$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$与$\pmb{\beta}_1,\pmb{\beta}_2,\cdots,\pmb{\beta}_s$是两个向量组，如果<br>(1):向量组$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$可由$\pmb{\beta}_1,\pmb{\beta}_2,\cdots,\pmb{\beta}_s$线性表出<br>(2):$r&gt;s$<br>则$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$一定线性相关。</p>
<p>Cor1:如果向量组$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$可由$\pmb{\beta}_1,\pmb{\beta}_2,\cdots,\pmb{\beta}_s$线性表出，且$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$线性无关，则$r\leq s$</p>
<p>Cor2:任意$n+1$个$n$维向量一定线性相关。</p>
<p>Cor3:两个线性无关的等价向量组一定含有相同个数的向量。</p>
<p>Cor4:假设向量$\pmb{\beta}$可以经向量组$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$线性表出，则表示法唯一的充要条件为$\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots, \pmb{\alpha}_r$线性无关。</p>
<p>注记：如果一个向量组成的向量组线性相关，那么它一定是零向量。</p>
<br>

<p>2.一个向量组的极大线性无关组都含有相同个数的向量。</p>
<p>据此我们可以定义向量组的秩：向量组的极大无关组所含的向量个数称为此向量组的秩。</p>
<br>

<p>3.矩阵的行秩就是将矩阵行向量组的秩，类似的可以定义矩阵的列秩。</p>
<p>Th1:矩阵的行秩与列秩相等，统称为矩阵的秩。</p>
<p>Th2:一个$n\times n$的方阵的行列式为0的充要条件是其秩小于$n$</p>
<p>3.5:在一个$s\times n$的矩阵$\pmb{A}$中任意选定$k$行和$k$列，位于这些选定的行和列的交点上的$k^2$个元素按照原来的次序所组成的$k$级行列式，称为$\pmb{A}$的一个$k$级子式。</p>
<p>Th3:一个矩阵秩为$r$的充要条件为矩阵中有一个$r$级子式不为0，但是所有$r+1$级子式全为0。</p>
<p>Th4:线性方程组$\pmb{Ax}&#x3D;\pmb{b}$有解的充要条件是$rank(\pmb{A})&#x3D;rank(\bar{\pmb{A}})$，这里的$\bar{\pmb{A}}$为$A$的增广矩阵。</p>
<br>

<p>4.线性方程组$\pmb{Ax}&#x3D;\pmb{b}$的导出组定义为$\pmb{Ax}&#x3D;\pmb{0}$</p>
<p>定义其次线性方程组$\pmb{Ax}&#x3D;\pmb{0}$的基础解系$\pmb{\eta}_1,\pmb{\eta}_2,\cdots,\pmb{\eta}_r$如下：<br>(1):$\pmb{Ax}&#x3D;\pmb{0}$的任意一个解都可以表示为$\pmb{\eta}_1,\pmb{\eta}_2,\cdots,\pmb{\eta}_r$的线性组合。<br>(2):$\pmb{\eta}_1,\pmb{\eta}_2,\cdots,\pmb{\eta}_r$线性无关。</p>
<p>Th1:其次线性方程组基础解系中的向量个数等于$n-rank(\pmb{A})$</p>
<p>Cor1:与基础解系等价的线性无关的向量组也是基础解系。</p>
<p>Th2:如果 $\pmb{\gamma}_0$ 是 $\pmb{Ax}&#x3D;\pmb{b}$ 的一个特解，那么 $\pmb{Ax}&#x3D;\pmb{b}$ 的任一解可表示为 $\pmb{\gamma}&#x3D;\pmb{\gamma}_0+\pmb{\eta}$ ，其中 $\pmb{\eta}$ 为导出组一解。因此当 $\pmb{\eta}$ 取遍导出组的全部解时，上式就取遍了 $\pmb{Ax}&#x3D;\pmb{b}$ 的全部解。</p>
<p>Cor2：方程组 $\pmb{Ax}&#x3D;\pmb{b}$ 有解时，解是唯一的充要条件时它的导出组只有零解。</p>
<p>下面列出两个习题：</p>
<p>1.线性方程组 $\pmb{Ax}&#x3D;\pmb{0}$ 的系数矩阵为：</p>
<p>$$\pmb{A}&#x3D;\begin{pmatrix}<br>        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br>        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots \\<br>        a_{n-1,1} &amp; a_{n-1,2} &amp; \cdots &amp; a_{n-1,n}<br>\end{pmatrix}$$</p>
<p>设$M_i$时从矩阵 $\pmb{A}$ 中划第 $i$ 列所剩下的 $(n-1)\times(n-1)$ 矩阵的行列式，证明：<br>(1): $(M_1,-M_2,\cdots (-1)^{n-1}M_n)$ 是方程组的一个解。<br>(2):如果$\pmb{A}$的秩为$n-1$，那么方程组的解全是 $(M_1,-M_2,\cdots (-1)^{n-1}M_n)$ 的倍数。</p>
<p>证明：<br>(1):考虑行列式<br>$$A_i&#x3D;\begin{vmatrix}<br>        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br>        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots \\<br>        a_{n-1,1} &amp; a_{n-1,2} &amp; \cdots &amp; a_{n-1,n} \\<br>        a_{i1} &amp; a_{i2} &amp; \cdots &amp; a_{in}<br>\end{vmatrix}&#x3D;0,i&#x3D;1,2,\cdots, n$$<br>按照最后一行展开，就有 $a_{i1}M_1-a_{i2}M_2+\cdots + (-1)^{n-1}a_{in}M_n&#x3D;0$<br>即 $(M_1,-M_2,\cdots (-1)^{n-1}M_n)$ 是原方程的一个解。<br>(2):若 $r(\pmb{A})&#x3D;n-1$，则其基础解系里只有一个解，所有解都为其倍数。所以只需证明(1)中求的一解非零即可。注意到 $r(\pmb{A})&#x3D;n-1$，则 $\pmb{A}$有一个$n-1$级子式不为 $0$，即(1)求的的解为非零解。<br><br></p>
<p>2.设<br>$$A&#x3D;\begin{pmatrix}<br>        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br>        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br>        \vdots &amp; \vdots &amp; &amp; \vdots \\<br>        a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}<br>\end{pmatrix}$$<br>为一实数域上的矩阵，证明：<br>(1):如果 $|a_{ii}|&gt;\sum\limits_{j\neq i} |a_{ij}|, i&#x3D;1,2,\cdots,n $，那么 $|A|\neq 0$<br>(2):如果 $a_{ii}&gt;\sum\limits_{j\neq i} |a_{ij}|, i&#x3D;1,2,\cdots,n$ ，那么 $|A| &gt; 0$</p>
<p>证明：<br>(1)只需证明 $\pmb{Ax}&#x3D;\pmb{0}$ 的解只有零解即可。<br>对于上述方程任一非零解 $\pmb{c}&#x3D;(c_1,c_2,\cdots,c_n)$ ，总可以选出 $c_i&gt;0$ 使得 $|c_i|\geq |c_j| , j&#x3D;1,2,\cdots,n$，那么 $|a_{i1}c_1+a_{i2}c_2+\cdots + a_{in}c_n| \geq |a_{ii}||c_i| - \sum\limits_{j\neq i}|a_{ij}c_i|  \geq |c_i|(|a_{ii}|-\sum\limits_{j\neq i}|a_{ij}|)&gt;0$<br>所以$\pmb{Ax}&#x3D;\pmb{0}$只有零解，这就证明了我们的结论。</p>
<p>(2)运用数学归纳法证明。<br>$n&#x3D;1$ 时， $|\pmb{A}|&#x3D;a_{11}&gt;0$ ，结论对 $n&#x3D;1$ 成立。<br>假设结论对 $n-1$ 成立，下面我们对 $n$ 证明结论。<br>取$A$的第一行$n$个代数余子式$A_{11},A_{12},\cdots,A_{1n}$，则有<br>$$a_{11}A_{11}+a_{12}A_{12}+\cdots+a_{1n}A_{1n}&#x3D;|\pmb{A}|$$<br>$$a_{i1}A_{11}+a_{i2}A_{12}+\cdots+a_{in}A_{1n}&#x3D;0, i\neq 1$$<br>由(1)有： $|A|\neq 0$ ，所以 $A_{11},\cdots,A_{1n}$ 至少有一个不为0。<br>下面我们证明 $|A_{11}|\geq|A_{1i}|,i&#x3D;1,2,3,\cdots n$。<br>事实上，假若存在 $i\neq 1$ ，使得 $|A_{1i}|\geq |A_{1j}|, j&#x3D;1,2,\cdots, n$，此时必然有$|A_{1i}|&gt;0$，则<br>$$0&#x3D;|a_{i1}A_{11}+a_{i2}A_{12}+\cdots+a_{in}A_{1n}| $$<br>$$\geq |a_{ii}||A_{1i}|-\sum\limits_{j\neq i}|a_{ij}||A_{1j}|$$<br>$$\geq |a_{ii}||A_{1i}|-\sum\limits_{j\neq i}|a_{ij}||A_{1i}|$$<br>$$&#x3D; |A_{1i}|-(|a_{ii}|-\sum\limits_{j\neq i}|a_{ij}|)&gt;0$$<br>矛盾了，所以 $|A_{11}|\geq|A_{1i}|,i&#x3D;1,2,3,\cdots n$。<br>由归纳假设有$A_{11}&gt;0$，故$a_{11}A_{11}&gt;0$，于是<br>所以 $|\pmb{A}|&#x3D;a_{11}A_{11}+\sum\limits_{i&#x3D;2}^n a_{1i}A_{1i}\geq a_{11}A_{11}-\sum\limits_{i&#x3D;2}^n|a_{1i}||A_{1i}|\geq (a_{11}-\sum\limits{i&#x3D;2}^n|a_{1i}|)A_{11}&gt;0$<br>这就完成了归纳法。</p>
<p>注记：形如(1)类型的矩阵称为严格对角占优矩阵，事实上，对于对称的严格对角占优的矩阵，我们可以证明其一定是正定矩阵。<br>这类矩阵在数值分析中也有重要的作用，例如其可以进行LU分解，也可以进行Jacobi迭代和G-S迭代和$0 &lt;\omega \leq 1$的松弛迭代等。</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>这一章关于矩阵的零碎的定理与推论较多，下面列出一些重要的和容易遗忘的：</p>
<p>1.关于矩阵的秩：<br>(1):$rank(\pmb{A}+\pmb{B})\leq rank(\pmb{A})+rank(\pmb{B})$<br>(2):$rank(\pmb{AB})\leq min(rank(\pmb{A}),rank(\pmb{B}))$<br>(3):如果 $\pmb{A} &#x3D; \pmb{A_1} \pmb{A_2} \cdots  \pmb{A_t}$，那么 $rank(\pmb{A})\leq \min\limits_{1\leq j\leq t }rank(\pmb{A}_j)$<br>(4):设$\pmb{A}$是$s\times n$矩阵，如果$\pmb{P}$是$s\times s$可逆矩阵，$\pmb{Q}$是$n\times n$可逆矩阵，那么$rank(\pmb{A})&#x3D;rank(\pmb{PA})&#x3D;rank(\pmb{AQ})$<br>(5):设$\pmb{A}$,$\pmb{B}$是$n\times n$矩阵，如果$\pmb{AB}&#x3D;\pmb{0}$，那么$rank(\pmb{A})+rank(\pmb{B}) \leq n$<br>(6):设$\pmb{A}$是$s\times n$矩阵，$\pmb{B}$是$n\times m$矩阵，则$rank(\pmb{AB})\geq rank(\pmb{A})+rank(\pmb{B})-n$<br>(7):$rank(\pmb{A}^*)&#x3D;\begin{cases}<br>n&amp; rank(\pmb{A})&#x3D;n \\<br>1&amp; rank(\pmb{A})&#x3D;n-1 \\<br>0&amp; rank(\pmb{A})&lt; n-1 \\<br>\end{cases}<br>$</p>
<br>

<p>2.关于逆矩阵：下面均假设矩阵可逆<br>(1):如果$|\pmb{A}|&#x3D;d$，那么$|\pmb{A}^{-1}|&#x3D;d^{-1}$<br>(2):如果矩阵$\pmb{A},\pmb{B}$可逆，那么$\pmb{A}’$和$\pmb{AB}$也可逆，且成立$(\pmb{A}’)^{-1}&#x3D;(\pmb{A}^{-1})’$，$(\pmb{AB})^{-1}&#x3D;\pmb{B}^{-1}\pmb{A}^{-1}$<br>(3): $\pmb{A}^{-1}&#x3D;\frac{1}{d}\pmb{A}^*$<br>(4): $|\pmb{A}^*|&#x3D;|\pmb{A}|^{n-1}$<br>(5): $(\pmb{A}^*)^*&#x3D;|\pmb{A}|^{n-2}\pmb{A}$</p>
<br>

<p>3.关于初等矩阵<br>(1):矩阵$\pmb{A}$与$\pmb{B}$称作等价的，如果$\pmb{B}$可以由$\pmb{A}$经过一系列初等变换得到。<br>(2):任何一$s\times n$矩阵都与一形式为 $\begin{pmatrix}<br>        \pmb{E}_r &amp;  0 \\<br>        0 &amp; 0 \\<br>\end{pmatrix}$等价，其中$r$是矩阵的秩。<br>(3):矩阵$\pmb{A}$与$\pmb{B}$等价的充要条件是有初等矩阵$\pmb{P}_1, \pmb{P}_2, \cdots, \pmb{P}_l, \pmb{Q}_1,\pmb{Q}_2\cdots,\pmb{Q}_t$，使得$\pmb{A}&#x3D;\pmb{P}_1 \pmb{P}_2 \cdots \pmb{P}_l \pmb{B} \pmb{Q}_1 \pmb{Q}_2 \cdots \pmb{Q}_t$<br>(4):两个$s\times n$矩阵$\pmb{A},\pmb{B}$等价的充要条件为，存在可逆的$s$级矩阵$\pmb{P}$和可逆的$n$级矩阵$\pmb{Q}$，使得$\pmb{A}&#x3D;\pmb{PBQ}$<br>(5):$n$级矩阵$\pmb{A}$可逆的充要条件为他能成一系列初等矩阵的乘积。</p>
<br>

<p>4.经典结论<br>(1):设$\pmb{A},\pmb{B}$分别是$n\times m, m\times n$矩阵，则：<br>$$\begin{vmatrix}<br>        \pmb{E}_m &amp;  \pmb{B} \\<br>        \pmb{A} &amp; \pmb{E}_n \\<br>\end{vmatrix}&#x3D;|\pmb{E}_n-\pmb{AB}|&#x3D;|\pmb{E}_m-\pmb{BA}|$$</p>
<p>Cor:设$\pmb{A},\pmb{B}$分别是$n\times m, m\times n$矩阵，则：<br>$$|\lambda \pmb{E}_n-\pmb{AB}|&#x3D;\lambda^{n-m}|\lambda\pmb{E}_m-\pmb{BA}|$$<br>提示：考虑$|\pmb{E}_n-(\frac{\pmb{A}}{\lambda})\pmb{B}|$，再用(1).</p>
<p>(2):设$\pmb{A}$为$2\times 2$矩阵，证明：如果$\exists l \geq 2,s.t. \pmb{A}^l&#x3D;\pmb{0}$，那么$\pmb{A}^2&#x3D;\pmb{0}$</p>
<p>提示：分$rank(\pmb{A})&#x3D;0$或者$1$讨论，注意$rank(\pmb{A})&#x3D;1$时，有$\pmb{A}^2&#x3D;k\pmb{A}$</p>
<p>注记：本题有许多种做法，一个经典的做法是使用Jordan型，由此可以推出$n$阶幂零矩阵的幂零指数不超过$n$。</p>
<p>(3):设$\pmb{A}$为$n\times n$矩阵，证明：如果$\pmb{A}^2&#x3D;\pmb{E}$，那么$rank(\pmb{A}+\pmb{E})+rank(\pmb{A}-\pmb{E})&#x3D;n$</p>
<p>提示：考虑$(\pmb A-\pmb{E})(\pmb{A}+\pmb{E})&#x3D;\pmb{0}$以及$(\pmb{A}+\pmb{E})+(\pmb{A}-\pmb{E})&#x3D;2\pmb{A}$</p>
<h2 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h2><p>我们用对称矩阵的角度来看二次型。</p>
<p>(1):合同关系<br>两个$n\times n$矩阵$\pmb A, \pmb B$称作合同的，如果有可逆的$n\times n$矩阵$\pmb{C}$，使得$\pmb{B}&#x3D;\pmb{C}’\pmb{AC}$。<br>合同关系是一个等价关系。<br>任意一个对称矩阵都合同于一个对角矩阵，即$\exists \pmb{C}$，使得$\pmb{C}’\pmb{AC}$是对角型矩阵。<br>注记：进一步的，我们可以要求$C$是正交的。</p>
<br>

<p>(2):规范形<br>任意一个复系数的对称矩阵$\pmb{A}$合同于一个形式为 $\begin{pmatrix}<br>        \pmb{E}_r &amp;  0 \\<br>        0 &amp; 0 \\<br>\end{pmatrix}$的对角矩阵，从而有任意两个复数对称矩阵合同的充要条件是他们的秩相等。</p>
<p>任意一个实系数的对称矩阵$\pmb{A}$合同于一个形式为 $\begin{pmatrix}<br>        \pmb{E_p} &amp;  0 &amp; 0 \\<br>        0 &amp; -\pmb{E_{r-p}} &amp; 0 \\<br>        0 &amp; 0 &amp; 0 \\\end{pmatrix}$的对角矩阵，其中对角线上$1$的个数$p$和$-1$的个数$r-p$都是唯一确定的，分别称为$\pmb{A}$的正、负惯性指数，它们的差$2p-r$称做$A$的符号差。</p>
<br>
(3):正定性

<p>1.实二次型$\pmb{X}’\pmb{AX}$是正定的充要条件是矩阵$A$的顺序主子式全大于零。</p>
<p>2.实二次型$\pmb{X}’\pmb{AX}$，其中$A$是对称矩阵，则下面命题等价：<br>(1)$\pmb{X}’\pmb{AX}$ 是半正定的；<br>(2)它的正惯性指数与秩相等；<br>(3)有可逆实矩阵$\pmb{C}$，使得$\pmb{C}’\pmb{AC}&#x3D;diag\{d_1,d_2,\cdots, d_n\},d_i \geq 0, i&#x3D;1,2,\cdots n$；<br>(4)有实矩阵$\pmb{C}$，使得$\pmb{A}&#x3D;\pmb{C}’\pmb{C}$；<br>(5)$\pmb{A}$的所有主子式皆大于零或等于零。</p>
<p>注记：在(5)中，不能只要求顺序主子式全大于或等于零。</p>
<p>列出几个习题：</p>
<p>(1):设$\pmb{A}$是反对称矩阵，证明：$\pmb{A}$合同于</p>
<p>$$\begin{pmatrix}<br>        0  &amp; 1 \\<br>        -1 &amp; 0 \\<br>           &amp;   &amp; 0 &amp; 1 \\<br>           &amp;   &amp; -1&amp; 0 \\<br>           &amp;   &amp;   &amp;  &amp; \ddots \\<br>           &amp;   &amp;   &amp;  &amp;       &amp; 0 &amp; 1 \\<br>           &amp;   &amp;   &amp;  &amp;       &amp; -1&amp; 0 \\<br>           &amp;   &amp;   &amp;  &amp;       &amp;   &amp;  &amp; 0 \\<br>           &amp;   &amp;   &amp;  &amp;       &amp;   &amp;  &amp;  &amp; \ddots \\<br>           &amp;   &amp;   &amp;  &amp;       &amp;   &amp;  &amp;  &amp; &amp; 0\\<br>\end{pmatrix}$$</p>
<p>提示：可以使用归纳法证明。</p>
<br>

<p>(2):证明$rank(\pmb{A}’\pmb{A})&#x3D;rank(\pmb{A})$</p>
<p>提示：可以从$\pmb{A}’\pmb{A}\pmb{X}&#x3D;0$和$\pmb{AX}&#x3D;\pmb{0}$的解的角度考虑。</p>
<br>
<br>

<p>先写这么多吧，后面五章看看有没有时间，有时间再写吧。</p>
]]></content>
      <categories>
        <category>高等代数</category>
      </categories>
      <tags>
        <tag>高等代数</tag>
      </tags>
  </entry>
</search>
