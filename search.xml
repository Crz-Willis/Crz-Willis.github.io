<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ICPC 2021 昆明站游记</title>
    <url>/2022/04/16/kunming2021/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>拿到了人生的第一块“精神”金牌。</p>
<span id="more"></span>
<h1 id="inf-Days-before-Day-inf"><a href="#inf-Days-before-Day-inf" class="headerlink" title="inf Days before Day -inf"></a>inf Days before Day -inf</h1><p>lzc要去实习，zh和wzx说想为ec热手，于是就叫上了我和他们一起打昆明站。</p>
<h1 id="Day-inf"><a href="#Day-inf" class="headerlink" title="Day -inf"></a>Day -inf</h1><p>学校封校，去不了软件园校区，以为要被迫周烜双排了。</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>收到了昆明打星队伍可以远程打比赛的消息，于是赶紧和周烜协调了一下准备线上打昆明站。</p>
<h1 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h1><p>因为板子都在软件园，热身赛前三个小时紧急打了板子，-11.35</p>
<p>三人两机，远程参赛。晚上试了下场地，调了下环境就下线了。</p>
<p>主办方没提供热身赛题面，我还以为在大群里，折腾了半天最后才发现热身没有题面，只有正赛才有。</p>
<p>半夜12点半电脑突然响了，以为电脑出问题了，等了半个小时后发现是装更新？？？</p>
<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>早上9点半起床，发现志愿者已经在催核验身份了，于是光速起床洗漱，在宿舍调试好环境后准备开始比赛</p>
<p>拿到题面的过程还算顺利，决定我从头读，wzx从末尾读，zh在中间挑短的签到。</p>
<p>开比赛后我发现A题是一个大模拟，于是放到了一边转去读B。</p>
<p>B读完了之后发现B，G，K都有人过了，于是我给zh报了B的题意，wzx去想K，我去读了G。</p>
<p>wzx过了K以后，我给wzx讲了下我并没有什么思路的G，然后wzx秒了，过了一会就过了。</p>
<p>我：？？？？</p>
<p>此时D，E，F都有不少队过了，我读完F之后转化了下题意，发现$\frac{\sum\limits_{u\in V} b_u}{|V|}$这个东西不会求，于是找了wzx。</p>
<p>wzx：经典模型，然后等zh过了G之后就上去写了写。</p>
<p>写完交完发现wa了，于是下机想。最后发现分子上的东西可能能取到负的，最后wzx调了下之后就过了。</p>
<p>过了之后我觉得我已经无事可做了后开始写A，然后zh和wzx在另一边写B和D。在我写的过程中他们把D过了，然后开始调B。</p>
<p>我把A写完了之后不出意外出现了很多bug，而且还有tle的可能，于是我在枚举的时候加了个剪枝，本地测试极限数据跑了2秒后。</p>
<p>我：我写完A了，你们帮我交一下，要是没过我就下班了。</p>
<p>zh：好。</p>
<p>（30秒后）</p>
<p>zh：nb</p>
<p>我：过了？</p>
<p>zh：过了。</p>
<p>我：nb</p>
<p>然后我要了zh的B题代码之后没看几眼。</p>
<p>zh：我memset写错了。</p>
<p>然后他们就过了B。</p>
<p>然后最后对着C，E，L罚坐到了最后。</p>
<p>最后rk23，拿到了一块“金牌”。</p>
<p>说好不秃rk20，也恭喜张哥吴哥门哥拿到第一块金牌。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本身以为要0贡献了，结果写了个A还报了个F的做法，也算还行吧。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>polya</title>
    <url>/2022/04/16/polya/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.luogu.com.cn/problem/P4980">传送门</a></p>
<span id="more"></span>


<p>题目描述：</p>
<p>给你$n$种颜色，再给你一个正$n$边形的项链，问你有多少种本质不同的染色方案。</p>
<p>注意本题的本质不同，定义为：<strong>只需要不能通过旋转与别的染色方案相同</strong>。</p>
<p>输入格式：第一行一个正整数$t$，表示数据组数，之后每一行一个数，代表$n$</p>
<p>输出格式：对于每一组数据，输出一个数，代表答案对$1e9+7$取模的结果。</p>
<p>样例输入：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>样例输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">11</span><br><span class="line">70</span><br><span class="line">629</span><br></pre></td></tr></table></figure>

<p>数据规模约定：$n\leq10^9,t\leq10^3$</p>
<p>在这里就不介绍Poyla定理的具体内容了，讲一讲应该如何优化。<br>我们不难求得答案是$ans&#x3D;\sum\limits_{i&#x3D;1}^nn^{gcd(i,n)}$</p>
<p>但是直接枚举复杂度是$O(tnlg^2n)$的，我们想办法优化。</p>
<p>我们可以发现对于$n$的每一个因子进行枚举可以发现，对于$n$的每一个因子$d$，我们有$n^d$种染色方案，又有$\varphi(\frac{n}{d})$个$gcd(i,n)&#x3D;d$的情况。<br>所以对于每一个$d$，我们将答案加上$n^d\varphi(\frac{n}{d})$</p>
<p>所以我们枚举$n$的因子即可，这样的复杂度可以变为$O(t(n\sqrt{n})^\frac{1}{2}lgn)$的，但这还不够，我们要继续优化。</p>
<p>我们可以先筛出每个质因子，然后再求欧拉函数的过程中，直接枚举质数即可。这样的复杂度可以变为$O(t(n^\frac{1}{2}lgn)^\frac{1}{2}lgn)$，就可以过了。</p>
<p>Code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pause system(<span class="string">&quot;pause&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e4</span>;</span><br><span class="line"><span class="type">int</span> prime[maxn + <span class="number">10</span>], tot;</span><br><span class="line"><span class="type">bool</span> vis[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getprime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * prime[j] &lt;= maxn; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a %= mod;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getphi</span><span class="params">(ll t, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1ll</span> * prime[i] * prime[i] &lt;= <span class="number">1ll</span> * t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t % prime[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * (prime[i] - <span class="number">1</span>) / prime[i];</span><br><span class="line">            <span class="keyword">while</span> (t % prime[i] == <span class="number">0</span>)</span><br><span class="line">                t /= prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans * (t - <span class="number">1</span>) / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">getprime</span>();</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n, ans = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * i == n)</span><br><span class="line">                ans += <span class="built_in">qp</span>(n, i - <span class="number">1</span>, mod) * <span class="built_in">getphi</span>(i, mod) % mod, ans %= mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += <span class="built_in">qp</span>(n, n / i - <span class="number">1</span>, mod) * <span class="built_in">getphi</span>(i, mod) % mod;</span><br><span class="line">                ans += <span class="built_in">qp</span>(n, i - <span class="number">1</span>, mod) * <span class="built_in">getphi</span>(n / i, mod) % mod;</span><br><span class="line">                ans %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt;(ans%mod+mod)%mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>群论</category>
      </categories>
      <tags>
        <tag>polya</tag>
      </tags>
  </entry>
  <entry>
    <title>随机事件复习笔记</title>
    <url>/2022/04/22/%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>推免复习概率论，写写笔记</p>
<span id="more"></span>

<h3 id="概率的公理化定义"><a href="#概率的公理化定义" class="headerlink" title="概率的公理化定义"></a>概率的公理化定义</h3><p>在一个随机现象中，用来表示任一个随机事件$A$发生可能性大小的实数成为该事件的概率，并规定：<br>（1）非负性公理：对任一事件$A$，必有$P(A)\geq 0$<br>（2）正则化公理：必然事件的概率$P(\Omega)&#x3D;1$<br>（3）可列可加性公理：若$A_1,A_2,\cdots$是一列互不相容事件，则有：$P(\bigcup\limits_{n&#x3D;1}^\infty A_i)&#x3D;\sum\limits_{i&#x3D;1}^\infty P(A_i)$</p>
<p>不过这样的定义有些主观，我们下面给出一个更加严谨的定义。</p>
<h3 id="概率空间"><a href="#概率空间" class="headerlink" title="概率空间"></a>概率空间</h3><h4 id="事件域"><a href="#事件域" class="headerlink" title="事件域"></a>事件域</h4><p>设$\Omega$是试验$S$样本空间，$\mathcal{F}$是由$\Omega$子集组成的集合类，若$\mathcal{F}$满足以下性质：<br>（1）$\Omega \in \mathcal{F}$<br>（2）如果$A \in \mathcal{F}$，则$\bar{A} \in \mathcal{F}$<br>（3）如果$A_j \in \mathcal{F}$，则$\bigcup\limits_{j&#x3D;1}^\infty \in \mathcal{F}$<br>则我们称$\mathcal{F}$为$Borel$事件域，或者$\sigma$域，称$\mathcal{F}$中的元素为事件，称$(\Omega,\mathcal{F})$是可测空间。</p>
<p>如果对测度论感兴趣可以翻阅实变函数教材。</p>
<h4 id="在概率空间上定义概率"><a href="#在概率空间上定义概率" class="headerlink" title="在概率空间上定义概率"></a>在概率空间上定义概率</h4><p>设$(\Omega,\mathcal{F})$是可测空间，$P$是定义在$\mathcal{F}$上的函数，如果$P$满足下列条件：<br>（1）非负性：对$A\in \mathcal{F}$，$P(A)\geq0$<br>（2）完全性：$P(\Omega)&#x3D;1$<br>（3）可列可加性：对于$\mathcal{F}$中互不相容的事件$A_1,A_2,\cdots$，$P(\bigcup\limits_{n&#x3D;1}^\infty A_i)&#x3D;\sum\limits_{i&#x3D;1}^\infty P(A_i)$<br>我们就称$P$为$\mathcal{F}$上的概率测度，简称为概率，称$(\Omega,\mathcal{F},P)$为概率空间。</p>
<p>从这个定义我们可以看出概率其实是定义在事件域上的一个函数，将每一个事件赋予一个值，就叫做概率。</p>
<p>在以后我们所有模型都是建立在概率空间的基础上，所遇到的$\Omega$的子集都假定是事件。</p>
<h3 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h3><p>古典概型所满足的要求为：<br>（1）所涉及的随机现象只有有限个基本结果。<br>（2）每个基本结果出现的可能性是相通的（简称等可能性）<br>（3）假如被考察的事件$A$含有$k$个基本结果，则事件$A$的概率就是：$P(A)&#x3D;\frac{k}{n}&#x3D;\frac{A中包含基本结果的个数}{\Omega中基本结果的个数}$</p>
<p>在计算概率的时候还有频率方法和主观方法。</p>
<h3 id="概率的性质"><a href="#概率的性质" class="headerlink" title="概率的性质"></a>概率的性质</h3><p>1.不可能事件$\phi$的概率为0.<br>$Proof$：因为$\Omega&#x3D;\Omega \cup\phi\cup\phi\cdots$<br>由可列可加性公理有：$P(\Omega)&#x3D;P(\Omega)+\sum\limits_{n&#x3D;2}^\infty P(\phi)$，又因为$P(\Omega)&#x3D;1$，所以$P(\phi)&#x3D;0$。</p>
<p>2.对任一事件$A$，有$P(A)&#x3D;1-P(\bar{A})$<br>$Proof$：因为$A\cup \bar{A}&#x3D;\Omega$，$\Omega&#x3D;A\cup \bar{A} \cup \phi \cup \phi \cdots$<br>由可列可加性公理及性质1有：$P(\Omega)&#x3D;P(A)+P(\bar{A})+P(\phi)+P(\phi)+\cdots$<br>即$1&#x3D;P(A)+P(\bar{A})$</p>
<p>3.对于$n$个互不相容的事件$A_1,A_2,\cdots A_n$，有$P(\bigcup\limits_{i&#x3D;1}^{n}A_i)&#x3D;\sum\limits_{i&#x3D;1}^nP(A_i)$</p>
<p>$Proof$：利用数学归纳法。</p>
<p>4.对任意两个事件$A$和$B$，若$A\supset B$，则<br>（1）$P(A-B)&#x3D;P(A)-P(B)$<br>（2）$P(A)\geq P(B)$（概率的单调性）</p>
<p>$Proof$：将$A$分为两个互不相容事件$B$与$A-B$的并，由可列可加性公理得：$P(A)&#x3D;P(B)+P(A-B)$<br>再有非负性公理：$P(A-B)\geq 0$，即可得到（2）。</p>
<p>5.对任一事件$A$，有$0\leq P(A) \leq 1$<br>$Proof$：对任一事件$A$，总有:$\phi \subset A \subset \Omega$，由概率的单调性知$P(\phi)\leq P(A) \leq P(\Omega)$则有$0\leq P(A) \leq 1$。</p>
<p>6.对任意两个事件$A$和$B$，有：<br>（1）$P(A\cup B)&#x3D; P(A)+P(B)-P(AB)$<br>（2）$P(A\cup B)\leq P(A)+P(B)$</p>
<p>$Proof$：由于并事件可以写成两个互不相容的事件$A$与$B-AB$的并，从可加性公理有$P(A)&#x3D;P(B)+P(B-AB)$，又因为$B \supset AB$，则由性质4（1）有：$P(B-AB)&#x3D;P(B)-P(AB)$，带回即有（1）。再由$P(AB)\geq 0$立即得到（2）。</p>
<p>注记：将集合拆成几个不相交集合的并是集合论证明中常用的方法。</p>
<p>$Ex$：对任意两个事件A与B，证明$P(A)&#x3D;P(AB)+P(A\bar{B})$</p>
<p>$Ex2$：对任一三个事件$A,B,C$有：<br>（1）$P(A\cup B\cup C)&#x3D;P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)$<br>（2）$P(A\cup B\cup C)\geq P(A)+P(B)+P(C)$</p>
<br />

<p>$Eg$：设$P(A)&#x3D;1&#x2F;3,P(B)&#x3D;1&#x2F;2$<br>（1）：若事件$A$和$B$互不相容，求$P(B\bar{A})$<br>（2）：若$A\subset B$求$P(B\bar{A})$<br>（3）：若$P(AB)&#x3D;1&#x2F;8$，求$P(B\bar{A})$</p>
<p>$Sol$：<br>（1）因为$A$，$B$互不相容，所以$A\cap B &#x3D; \phi$，即$B \subset \bar{A}$，即有$\bar{A}&#x3D;B$，故$P(B\bar{A})&#x3D;P(B)&#x3D;1&#x2F;2$<br>（2）因为$P(B)&#x3D;P(AB)+P(B\bar{A})$且$A\subset B$，所以$P(AB)&#x3D;P(A)&#x3D;1&#x2F;3$，则有<br>$P(B\bar{A})&#x3D;$ $P(B)-P(AB)&#x3D;1&#x2F;6$<br>（3）同（2），有$P(B\bar{A})&#x3D;P(B)-P(AB)&#x3D;1&#x2F;2-1&#x2F;8&#x3D;3&#x2F;8$</p>
<br />

<p>$eg2$：某人对事件$A,B$及其并$A\cup B$分别给出主观概率如下：$P(A)&#x3D;1&#x2F;3,P(B)&#x3D;1&#x2F;3,P(A\cup B)&#x3D;3&#x2F;4$<br>按概率性质，应有$P(A\cup B)\leq P(A)+P(B)$，然而现在$P(A\cup B)&#x3D;3&#x2F;4$，$P(A)+P(B)&#x3D;2&#x2F;3$这个性质不满足。问题是出在了主管概率给定不恰当引起的。例如将$P(A\cup B)$修整成$3&#x2F;5$即可。</p>
<h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><p>$Def$：对任意两个事件$A,B$，若有$P(AB)&#x3D;P(A)+P(B)$，则称事件$A$与事件$B$相互独立，简称$A$和$B$独立。否则称事件$A$和$B$不独立。</p>
<p>注记：独立与互不相容没有必然联系，独立表示两件事件之间没有关系，而互不相容表示两件事件之间不可能同时发生。</p>
<p>$Th$：若事件$A$和$B$独立，则$A$与$\bar{B}$独立，$\bar{A}$与$B$独立，$\bar{A}$与$\bar{B}$独立。</p>
<p>$Proof$：$A\bar{B}&#x3D;A-AB$，又因为$AB\subset A$，再由A与B的独立性知：<br>$P(A\bar{B})&#x3D;P(A)-P(AB)&#x3D;P(A)-P(A)P(B)&#x3D;P(A)(1-P(B))&#x3D;P(A)P(\bar{B})$<br>其余的类似可证。</p>
<h4 id="多个事件的独立性"><a href="#多个事件的独立性" class="headerlink" title="多个事件的独立性"></a>多个事件的独立性</h4><p>设有$n$个事件$A_1,A_2,\cdots A_n$，假如对所有可能的$1\leq i&lt;j&lt;k&lt;\cdots \leq n$以下等式均成立：</p>
<p>$<br>\begin{cases}<br>P(A_iA_j)&#x3D;P(A_i)P(A_j) \\<br>P(A_iA_jA_k)&#x3D;P(A_i)P(A_j)P(A_k) \\<br>\cdots \\<br>P(A_1A_2\cdots A_n)&#x3D;P(A_1)P(A_2)\cdots P(A_n) \\<br>\end{cases}<br>$</p>
<p>则称这$n$个事件相互独立。</p>
<p>注记：只满足$P(A_iA_j)&#x3D;P(A_i)P(A_j)$是不可以的，我们有伯恩斯坦反例：</p>
<p>一个均匀的正四面体，第一面染上红色，第二面染上白色，第三面染上黑色，第四面同时染上红，白，黑三种颜色。记事件 $A,B,C$分别表示投一次均匀的正四面体出现红，白，黑颜色的事件。则$P(A)&#x3D;P(B)&#x3D;P(C)&#x3D;1&#x2F;2$，$P(AB)&#x3D;P(AC)&#x3D;P(BC)&#x3D;1&#x2F;4$，但是$P(ABC)&#x3D;1&#x2F;4$</p>
<p>本质是因为只有两两独立我们推不出$AB$和$C$独立、$A\cup B$和$C$独立。</p>
<p>有一个更直观的例子是波罗梅奥环，可以自行查阅。</p>
<h4 id="试验的独立性"><a href="#试验的独立性" class="headerlink" title="试验的独立性"></a>试验的独立性</h4><p>假设有$n$个试验$E_1,E_2,\cdots E_n$，假设$E_1$的任一结果，$E_2$的任一结果，$\cdots $  $ E_n$的任一结果都是相互独立的事件，则称试验  $E_1,E_2,\cdots E_n$是相互独立。如果这$n$次试验是相同的，则称其为$n$次独立重复试验。</p>
<p>$eg$：扔一枚硬币和扔一颗骰子是相互独立试验。</p>
<h3 id="n重伯努利试验"><a href="#n重伯努利试验" class="headerlink" title="n重伯努利试验"></a>n重伯努利试验</h3><p>$Def($伯努利试验$)$：只有两个结果$(A$和$\bar{A})$的试验称为伯努利试验。</p>
<p>在一次伯努利试验中，设发生$A$的概率为$p$，则有$P(A)&#x3D;p,P(\bar{A})&#x3D;1-p$</p>
<p>$Def(n$重伯努利试验$)$：由$n$次相同的，独立的伯努利试验组成的多随机试验成为$n$重伯努利试验。</p>
<p>$n$重伯努利试验可以用长度为$n$的$A$和$\bar{A}$的序列表示。</p>
<h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>$Def($条件概率$)$：设$A$和$B$是样本空间$\Omega$中的两个事件，且$P(B)&gt;0$，在事件$B$已经发生的条件下，事件$A$的条件概率$P(A|B)$定义为$\frac{P(AB)}{P(B)}$。</p>
<h4 id="条件概率的性质："><a href="#条件概率的性质：" class="headerlink" title="条件概率的性质："></a>条件概率的性质：</h4><p>1.条件概率是概率，即满足概率的$3$条公理。</p>
<p>2.（乘法公式）：对任意两个事件$A$和$B$，有：<br>$$P(AB)&#x3D;P(A|B)P(B)&#x3D;P(B|A)P(A)$$其中第一个等式要求$P(B)&gt;0$，第二个等式要求$P(A)&gt;0$</p>
<p>怎么理解？<br>通俗的来说，以第一个等式为例：$P(B)$表示将样本空间$\Omega$限制在了集合$B$上，$P(A|B)$代表将集合$A$限制在了集合$B$上。</p>
<p>2的结论还可以推广到多个事件</p>
<p>3.（一般乘法公式）：对任意$3$个事件$A,B,C$，假若$P(BC)&gt;0$，则有：$$P(ABC)&#x3D;P(A)P(B|A)P(C|AB)$$</p>
<p>$Def$：把样本空间$\Omega$分为$n$个事件$B_1,B_2,\cdots, B_n$，假如：<br>（1）$P(B_i)&gt;0,i&#x3D;1,2,\cdots, n$<br>（2）$B_1,B_2,\cdots B_n$互不相容<br>（3）$\bigcup\limits_{i&#x3D;1}^n B_i&#x3D;\Omega$<br>则称事件组$B_1,B_2,\cdots B_n$为样本空间$\Omega$的一个分割。</p>
<p>4.（全概率公式）：设$B_1,B_2,\cdots B_n$是样本空间$\Omega$的一个分割，则对$\Omega$的任意一事件$A$，有<br>$$P(A)&#x3D;\sum\limits_{i&#x3D;1}^nP(A|B_i)P(B_i)$$</p>
<p>怎么理解？<br>把$B_i$看成每个小空间，讲$B_i$上$A$发生的概率加起来就是$A$在$\Omega$上发生的概率。</p>
<p>5.（贝叶斯公式）：设事件$B_1,B_2,\cdots, B_n$是样本空间$\Omega$的一个分割，且他们各自的概率皆已知且为正，又设$A$是$\Omega$中的一个事件，$P(A)&gt;0$，且在$B_i$给定下事件$A$的条件概率$P(A|B_1),P(A|B_2),\cdots,P(A|B_n)$已知。则在$A$给定下，事件$B_k$的条件概率为：<br>$$P(B_k|A)&#x3D;\frac{P(A|B_k)P(B_k)}{P(A)}&#x3D;\frac{P(A|B_k)P(B_k)}{\sum\limits_{i&#x3D;1}^n P(A|B_i)P(B_i)}$$</p>
<p>我们称$P(B_k|A)$为后验概率，而$P(B_k)$为先验概率。</p>
<p>怎么理解？<br>我们把$B_i$看成一个人的决策集合，$P(B_i)$代表做$B_i$的决策的概率，现在通过试验我们得到了一个结果$A$，利用$A$我们可以得到$A$发生的时候$B_i$发生的概率，这样为做决策得到了试验的依据，可以根据试验情况改变决策。</p>
<h4 id="条件概率的例子"><a href="#条件概率的例子" class="headerlink" title="条件概率的例子"></a>条件概率的例子</h4><p>下面对于三个公式各给出一个例子</p>
<p>$eg1$（波利亚坛子模型）：设摊子内有$b$个黑球和$r$个红球，每次随机取出一个球， 把原球放回，还加进（与取出的球）同色的$c$个和异色球$d$个，这里$c$和$d$都是已知的整数。设$B_i$表示“第$i$次取出的是黑球”这一事件，$R_j$表示“第$j$次取出的是红球”这一事件，我们来研究下面几个事件的概率：<br>$$ P(B_1R_2R_3)&#x3D;P(B_1)P(R_2|B_1)P(R_3|R_2B_1)&#x3D;\frac{b}{b+r}\cdot\frac{r+d}{(b+c)+(r+d)}\cdot\frac{r+d+c}{(b+c+d)+(r+d+c)}$$</p>
<p>$$P(R_1B_2R_3)&#x3D;P(R_1)P(B_2|R_1)P(R_3|B_2R_1)&#x3D;\frac{r}{b+r}\cdot\frac{b+d}{(b+d)+(r+c)}\cdot\frac{r+c+d}{(b+d+c)+(r+c+d)} $$</p>
<p>$$ P(R_1R_2B_3)&#x3D;P(R_1)P(R_2|R_1)P(B_3|R_2R_1)&#x3D;\frac{r}{b+r}\cdot\frac{r+c}{(b+d)+(r+c)}\cdot\frac{b+2d}{(b+d+d)+(r+c+c)}$$</p>
<p>可以发现，这三个概率不一样，表明黑球出现的次序在影响着概率。</p>
<p>我们研究几个特殊的情况：</p>
<p>（1）$c&gt;0,d&#x3D;0$。这意味着每次取出球后会增加下一次也取到同色球的概率，这是一个传染病模型。每次发现一个传染病患者，以后都会增加再传染的概率。在这种情况下，上面三个概率分别为：</p>
<p>$$ P(B_1R_2R_3)&#x3D;\frac{b}{b+r}\cdot\frac{r}{(b+c)+(r)}\cdot\frac{r+c}{(b+c)+(r+c)}$$</p>
<p>$$P(R_1B_2R_3)&#x3D;\frac{r}{b+r}\cdot\frac{b}{(b)+(r+c)}\cdot\frac{r+c}{(b+c)+(r+c)} $$</p>
<p>$$ P(R_1R_2B_3)&#x3D;\frac{r}{b+r}\cdot\frac{r+c}{(b)+(r+c)}\cdot\frac{b}{(b)+(r+c+c)}$$</p>
<p>可以发现这三个概率相同，这表明在$d&#x3D;0$的时候，上述概率只与黑球和红球的次数有关，而与次序无关。</p>
<p>（2）$c&#x3D;0,d&gt;0$这是一个安全模型，每当发生事故（抓出红球）的时候安全工作就抓紧一些（放入黑球），否则就放松一些（放入红球），在这种情况下，上述三个概率分别为：</p>
<p>$$ P(B_1R_2R_3)&#x3D;\frac{b}{b+r}\cdot\frac{r+d}{(b)+(r+d)}\cdot\frac{r+d}{(b+d)+(r+d)}$$</p>
<p>$$P(R_1B_2R_3)&#x3D;\frac{r}{b+r}\cdot\frac{b+d}{(b+d)+(r)}\cdot\frac{r+d}{(b+d)+(r+d)} $$</p>
<p>$$ P(R_1R_2B_3)&#x3D;\frac{r}{b+r}\cdot\frac{r+c}{(b+d)+(r)}\cdot\frac{b+2d}{(b+d+d)+(r)}$$</p>
<p>这三个概率不相同，说明出事故的顺序影响着第$k$次出事故的概率。</p>
<p>（3）$c&#x3D;0,d&#x3D;0$，这是放回模型，抽$n$次抽出红球的次数这一随机变量服从二项分布$B(n,r&#x2F;(b+r))$<br>（4）$c&#x3D;-1,d&#x3D;0$，这是不放回模型，抽$n$次抽出红球的次数这一随机变量服从超几何分布。</p>
<br />

<p>$eg2$（敏感问题调查模型）：调查敏感问题时，有些人不愿如实回答，这时我们可以设计两个问题：</p>
<p>A：你的生日是否在7月1日以前？<br>B为敏感问题。</p>
<p>在问卷上我们只有是和否两个选项，同时设置一个包含红球和黑球的罐子，若抽出红球则回答A，否则回答B。且设罐中有红球$r$个，有黑球$b$个。（我们认为这个过程没有人监督，即所有填写问卷的人都如实回答。）<br>在调查后，我们可以得到问卷中填是的频率是$f&#x3D;\frac{k}{n}$，我们用频率估计概率得到$P(是)&#x3D;\frac{k}{n}$。<br>这里回答“是”有两种情况。一种是摸到红球回答“是”，一种是摸到黑球回答“是”。<br>对于第一种情况我们认为$P(是|红球)&#x3D;0.5$，而对于第二种情况，我们想知道的就是$P(是|黑球)$，设为$p$。<br>我们可以得到：<br>$$P(是)&#x3D;P(红球)\cdot P(是|红球)+P(黑球)\cdot P(是|黑球)$$<br>即：<br>$$\frac{k}{n}&#x3D;\frac{r}{r+b}\cdot 0.5 + \frac{b}{b+r}\cdot p$$<br>由此我们可以直接解出$p$。</p>
<br />

<p>$eg3$：为提高公司产品的质量，公司经理经过考虑后增加投资来改进生产设备，但从投资效果来看，下属部门有两种意见：<br>$$B_1：改进生产设备后，高质量产品可以占90\%$$<br>$$B_2：改进生产设备后，高质量产品可以占70\%$$<br>经理认为两种事件发生的概率为等可能的，即$P(B_1)&#x3D;P(B_2)&#x3D;0.5$。<br>经过试验一次试验$A$，试验结果为：试制了五个产品，全是高质量产品。<br>经理希望用此结果去改变其对最初观点的看法。我们由贝叶斯公式可以知道：<br>$$P(B_1|A)&#x3D;\frac{P(A|B_1)P(B_1)}{P(B_1)P(A|B_1)+P(B_2)P(A|B_2)}&#x3D;\frac{0.5\cdot 0.9^5}{0.5\cdot 0.9^5+0.5\cdot 0.7^5}$$</p>
<p>$$P(B_2|A)&#x3D;\frac{P(A|B_2)P(B_2)}{P(B_1)P(A|B_1)+P(B_2)P(A|B_2)}&#x3D;\frac{0.5\cdot 0.7^5}{0.5\cdot 0.9^5+0.5\cdot 0.7^5}$$</p>
<p>显然$P(B_1|A)&gt;P(B_2|A)$，所以经理对$B_1$更加信任。</p>
<p>注记：这个例子反映了机器学习中贝叶斯学习的过程。在机器学习中，试验$A$即为训练集中各个标签的频率，然后我们得到了后验概率后就可以在验证集中每个元素的分类。</p>
]]></content>
      <categories>
        <category>概率论</category>
        <category>随机事件及概率</category>
      </categories>
      <tags>
        <tag>条件概率</tag>
        <tag>贝叶斯公式</tag>
        <tag>概率</tag>
        <tag>独立性</tag>
      </tags>
  </entry>
</search>
