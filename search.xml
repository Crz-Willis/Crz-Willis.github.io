<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ICPC 2021 昆明站游记</title>
    <url>/2022/04/16/kunming2021/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>拿到了人生的第一块“精神”金牌。</p>
<span id="more"></span>
<h1 id="inf-Days-before-Day-inf"><a href="#inf-Days-before-Day-inf" class="headerlink" title="inf Days before Day -inf"></a>inf Days before Day -inf</h1><p>lzc要去实习，zh和wzx说想为ec热手，于是就叫上了我和他们一起打昆明站。</p>
<h1 id="Day-inf"><a href="#Day-inf" class="headerlink" title="Day -inf"></a>Day -inf</h1><p>学校封校，去不了软件园校区，以为要被迫周烜双排了。</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>收到了昆明打星队伍可以远程打比赛的消息，于是赶紧和周烜协调了一下准备线上打昆明站。</p>
<h1 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h1><p>因为板子都在软件园，热身赛前三个小时紧急打了板子，-11.35</p>
<p>三人两机，远程参赛。晚上试了下场地，调了下环境就下线了。</p>
<p>主办方没提供热身赛题面，我还以为在大群里，折腾了半天最后才发现热身没有题面，只有正赛才有。</p>
<p>半夜12点半电脑突然响了，以为电脑出问题了，等了半个小时后发现是装更新？？？</p>
<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>早上9点半起床，发现志愿者已经在催核验身份了，于是光速起床洗漱，在宿舍调试好环境后准备开始比赛</p>
<p>拿到题面的过程还算顺利，决定我从头读，wzx从末尾读，zh在中间挑短的签到。</p>
<p>开比赛后我发现A题是一个大模拟，于是放到了一边转去读B。</p>
<p>B读完了之后发现B，G，K都有人过了，于是我给zh报了B的题意，wzx去想K，我去读了G。</p>
<p>wzx过了K以后，我给wzx讲了下我并没有什么思路的G，然后wzx秒了，过了一会就过了。</p>
<p>我：？？？？</p>
<p>此时D，E，F都有不少队过了，我读完F之后转化了下题意，发现$\frac{\sum\limits_{u\in V} b_u}{|V|}$这个东西不会求，于是找了wzx。</p>
<p>wzx：经典模型，然后等zh过了G之后就上去写了写。</p>
<p>写完交完发现wa了，于是下机想。最后发现分子上的东西可能能取到负的，最后wzx调了下之后就过了。</p>
<p>过了之后我觉得我已经无事可做了后开始写A，然后zh和wzx在另一边写B和D。在我写的过程中他们把D过了，然后开始调B。</p>
<p>我把A写完了之后不出意外出现了很多bug，而且还有tle的可能，于是我在枚举的时候加了个剪枝，本地测试极限数据跑了2秒后。</p>
<p>我：我写完A了，你们帮我交一下，要是没过我就下班了。</p>
<p>zh：好。</p>
<p>（30秒后）</p>
<p>zh：nb</p>
<p>我：过了？</p>
<p>zh：过了。</p>
<p>我：nb</p>
<p>然后我要了zh的B题代码之后没看几眼。</p>
<p>zh：我memset写错了。</p>
<p>然后他们就过了B。</p>
<p>然后最后对着C，E，L罚坐到了最后。</p>
<p>最后rk23，拿到了一块“金牌”。</p>
<p>说好不秃rk20，也恭喜张哥吴哥门哥拿到第一块金牌。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本身以为要0贡献了，结果写了个A还报了个F的做法，也算还行吧。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P5300 [GXOI/GZOI2019]与或和</title>
    <url>/2022/04/26/luogu-P5300/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单调栈好题</p>
<span id="more"></span>

<p><a href="https://www.luogu.com.cn/problem/P5300">传送门</a></p>
<p>大致题意：给你$n\times n$的矩阵$A$，让你求矩阵中所有子矩阵的与$\&amp;$和或$|$的和。<br>数据范围：$n\leq 2000,a_{i,j}\leq 2^{31}-1$</p>
<p>大致题解：拆位考虑，对于与运算，我们对每一个$a_{i,j}$计算以它为右下角的全1子矩阵个数，对于或运算，我们计算以$a_{i,j}$为右下角的全0子矩阵个数，然后用$i\times j$减去全0子矩阵的个数即可。</p>
<p>下面讨论怎么使用单调栈来维护以$a_{i,j}$为右下角的全1&#x2F;0子矩阵个数。</p>
<p>预处理$s_{i,j}$为以$a_{i,j}$上方连续的1&#x2F;0的个数，然后我们依次枚举一个点，计算以它为右下角的全1&#x2F;0的子矩阵的个数。</p>
<p>我们设$f_{i,j}$是以$a_{i,j}$为右下角的全1&#x2F;0子矩阵的个数，维护一个单调递增的栈，当未发生弹栈的时候，我们有</p>
<p>$$f_{i,j}&#x3D;f_{i,j-1}+s_{i,j}$$</p>
<p>其中第一部分是从左边延伸过来的，第二部分是从$a_{i,j}$向上延伸的。</p>
<p>具体见图：<img src="/2022/04/26/luogu-P5300/image.png"></p>
<p>当发生弹栈的时候，意味着左边的延伸不过去了，需要减掉，我们有</p>
<p>$$f_{i,j}&#x3D;f_{i,j}-(s_{i,j}-s_{i,st.top()})*(st.top()-st.(top-1)())$$</p>
<p>其中$st.(top-1)()$表示栈顶的下一个元素。</p>
<p>具体见图（3弹栈的时候）：</p>
<p><img src="/2022/04/26/luogu-P5300/image2.png"></p>
<p>这样就维护了答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(a,x) memset(a, x, sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; P;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">2e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">qp</span> <span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">			ans = ans * a % mod;</span><br><span class="line">		a = a * a % mod;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[maxn][maxn];</span><br><span class="line"><span class="type">int</span> up[maxn][maxn];</span><br><span class="line">ll ans1,ans2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IOS;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			cin&gt;&gt;a[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">31</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">mem</span>(up[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i][j]&amp;(<span class="number">1</span>&lt;&lt;k))</span><br><span class="line">					up[i][j]=up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					up[i][j]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">			s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">			up[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">			up[i][n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">			ll bns=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				bns+=up[i][j];</span><br><span class="line">				<span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;up[i][j]&lt;up[i][s.<span class="built_in">top</span>()])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> x = s.<span class="built_in">top</span>();</span><br><span class="line">					s.<span class="built_in">pop</span>();</span><br><span class="line">					bns=bns-(x-s.<span class="built_in">top</span>())*(up[i][x]-up[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				s.<span class="built_in">push</span>(j);</span><br><span class="line">				ans1=(ans1+(bns&lt;&lt;k))%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">mem</span>(up[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>((a[i][j]&amp;(<span class="number">1</span>&lt;&lt;k))==<span class="number">0</span>)</span><br><span class="line">					up[i][j]=up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					up[i][j]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">			up[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">			up[i][n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">			s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">			ll bns=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				bns=bns+up[i][j];</span><br><span class="line">				<span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;up[i][j]&lt;up[i][s.<span class="built_in">top</span>()])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> x = s.<span class="built_in">top</span>();</span><br><span class="line">					s.<span class="built_in">pop</span>();</span><br><span class="line">					bns=bns-(x-s.<span class="built_in">top</span>())*(up[i][x]-up[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				s.<span class="built_in">push</span>(j);</span><br><span class="line">				ans2=(ans2+((<span class="number">1ll</span>*i*j-bns)&lt;&lt;k))%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>polya</title>
    <url>/2022/04/16/polya/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.luogu.com.cn/problem/P4980">传送门</a></p>
<span id="more"></span>


<p>题目描述：</p>
<p>给你$n$种颜色，再给你一个正$n$边形的项链，问你有多少种本质不同的染色方案。</p>
<p>注意本题的本质不同，定义为：<strong>只需要不能通过旋转与别的染色方案相同</strong>。</p>
<p>输入格式：第一行一个正整数$t$，表示数据组数，之后每一行一个数，代表$n$</p>
<p>输出格式：对于每一组数据，输出一个数，代表答案对$1e9+7$取模的结果。</p>
<p>样例输入：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>样例输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">11</span><br><span class="line">70</span><br><span class="line">629</span><br></pre></td></tr></table></figure>

<p>数据规模约定：$n\leq10^9,t\leq10^3$</p>
<p>在这里就不介绍Poyla定理的具体内容了，讲一讲应该如何优化。<br>我们不难求得答案是$ans&#x3D;\sum\limits_{i&#x3D;1}^nn^{gcd(i,n)}$</p>
<p>但是直接枚举复杂度是$O(tnlg^2n)$的，我们想办法优化。</p>
<p>我们可以发现对于$n$的每一个因子进行枚举可以发现，对于$n$的每一个因子$d$，我们有$n^d$种染色方案，又有$\varphi(\frac{n}{d})$个$gcd(i,n)&#x3D;d$的情况。<br>所以对于每一个$d$，我们将答案加上$n^d\varphi(\frac{n}{d})$</p>
<p>所以我们枚举$n$的因子即可，这样的复杂度可以变为$O(t(n\sqrt{n})^\frac{1}{2}lgn)$的，但这还不够，我们要继续优化。</p>
<p>我们可以先筛出每个质因子，然后再求欧拉函数的过程中，直接枚举质数即可。这样的复杂度可以变为$O(t(n^\frac{1}{2}lgn)^\frac{1}{2}lgn)$，就可以过了。</p>
<p>Code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pause system(<span class="string">&quot;pause&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e4</span>;</span><br><span class="line"><span class="type">int</span> prime[maxn + <span class="number">10</span>], tot;</span><br><span class="line"><span class="type">bool</span> vis[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getprime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * prime[j] &lt;= maxn; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a %= mod;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getphi</span><span class="params">(ll t, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1ll</span> * prime[i] * prime[i] &lt;= <span class="number">1ll</span> * t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t % prime[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * (prime[i] - <span class="number">1</span>) / prime[i];</span><br><span class="line">            <span class="keyword">while</span> (t % prime[i] == <span class="number">0</span>)</span><br><span class="line">                t /= prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans * (t - <span class="number">1</span>) / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">getprime</span>();</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n, ans = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * i == n)</span><br><span class="line">                ans += <span class="built_in">qp</span>(n, i - <span class="number">1</span>, mod) * <span class="built_in">getphi</span>(i, mod) % mod, ans %= mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += <span class="built_in">qp</span>(n, n / i - <span class="number">1</span>, mod) * <span class="built_in">getphi</span>(i, mod) % mod;</span><br><span class="line">                ans += <span class="built_in">qp</span>(n, i - <span class="number">1</span>, mod) * <span class="built_in">getphi</span>(n / i, mod) % mod;</span><br><span class="line">                ans %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt;(ans%mod+mod)%mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>群论</category>
      </categories>
      <tags>
        <tag>polya</tag>
      </tags>
  </entry>
  <entry>
    <title>线性系统理论第一章复习笔记</title>
    <url>/2022/05/21/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一章：线性定常系统的状态空间描述及运动分析</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>线性系统理论</category>
        <category>线性定常系统的状态空间描述及运动分析</category>
      </categories>
      <tags>
        <tag>线性系统理论</tag>
      </tags>
  </entry>
  <entry>
    <title>随机事件复习笔记</title>
    <url>/2022/04/22/%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>随机事件复习笔记</p>
<span id="more"></span>

<h3 id="概率的公理化定义"><a href="#概率的公理化定义" class="headerlink" title="概率的公理化定义"></a>概率的公理化定义</h3><p>在一个随机现象中，用来表示任一个随机事件$A$发生可能性大小的实数成为该事件的概率，并规定：<br>（1）非负性公理：对任一事件$A$，必有$P(A)\geq 0$<br>（2）正则化公理：必然事件的概率$P(\Omega)&#x3D;1$<br>（3）可列可加性公理：若$A_1,A_2,\cdots$是一列互不相容事件，则有：$P(\bigcup\limits_{n&#x3D;1}^\infty A_i)&#x3D;\sum\limits_{i&#x3D;1}^\infty P(A_i)$</p>
<p>不过这样的定义有些主观，我们下面给出一个更加严谨的定义。</p>
<h3 id="概率空间"><a href="#概率空间" class="headerlink" title="概率空间"></a>概率空间</h3><h4 id="事件域"><a href="#事件域" class="headerlink" title="事件域"></a>事件域</h4><p>设$\Omega$是试验$S$样本空间，$\mathcal{F}$是由$\Omega$子集组成的集合类，若$\mathcal{F}$满足以下性质：<br>（1）$\Omega \in \mathcal{F}$<br>（2）如果$A \in \mathcal{F}$，则$\bar{A} \in \mathcal{F}$<br>（3）如果$A_j \in \mathcal{F}$，则$\bigcup\limits_{j&#x3D;1}^\infty \in \mathcal{F}$<br>则我们称$\mathcal{F}$为$Borel$事件域，或者$\sigma$域，称$\mathcal{F}$中的元素为事件，称$(\Omega,\mathcal{F})$是可测空间。</p>
<p>如果对测度论感兴趣可以翻阅实变函数教材。</p>
<h4 id="在概率空间上定义概率"><a href="#在概率空间上定义概率" class="headerlink" title="在概率空间上定义概率"></a>在概率空间上定义概率</h4><p>设$(\Omega,\mathcal{F})$是可测空间，$P$是定义在$\mathcal{F}$上的函数，如果$P$满足下列条件：<br>（1）非负性：对$A\in \mathcal{F}$，$P(A)\geq0$<br>（2）完全性：$P(\Omega)&#x3D;1$<br>（3）可列可加性：对于$\mathcal{F}$中互不相容的事件$A_1,A_2,\cdots$，$P(\bigcup\limits_{n&#x3D;1}^\infty A_i)&#x3D;\sum\limits_{i&#x3D;1}^\infty P(A_i)$<br>我们就称$P$为$\mathcal{F}$上的概率测度，简称为概率，称$(\Omega,\mathcal{F},P)$为概率空间。</p>
<p>从这个定义我们可以看出概率其实是定义在事件域上的一个函数，将每一个事件赋予一个值，就叫做概率。</p>
<p>在以后我们所有模型都是建立在概率空间的基础上，所遇到的$\Omega$的子集都假定是事件。</p>
<h3 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h3><p>古典概型所满足的要求为：<br>（1）所涉及的随机现象只有有限个基本结果。<br>（2）每个基本结果出现的可能性是相通的（简称等可能性）<br>（3）假如被考察的事件$A$含有$k$个基本结果，则事件$A$的概率就是：$P(A)&#x3D;\frac{k}{n}&#x3D;\frac{A中包含基本结果的个数}{\Omega中基本结果的个数}$</p>
<p>在计算概率的时候还有频率方法和主观方法。</p>
<h3 id="概率的性质"><a href="#概率的性质" class="headerlink" title="概率的性质"></a>概率的性质</h3><p>1.不可能事件$\phi$的概率为0.<br>$Proof$：因为$\Omega&#x3D;\Omega \cup\phi\cup\phi\cdots$<br>由可列可加性公理有：$P(\Omega)&#x3D;P(\Omega)+\sum\limits_{n&#x3D;2}^\infty P(\phi)$，又因为$P(\Omega)&#x3D;1$，所以$P(\phi)&#x3D;0$。</p>
<p>2.对任一事件$A$，有$P(A)&#x3D;1-P(\bar{A})$<br>$Proof$：因为$A\cup \bar{A}&#x3D;\Omega$，$\Omega&#x3D;A\cup \bar{A} \cup \phi \cup \phi \cdots$<br>由可列可加性公理及性质1有：$P(\Omega)&#x3D;P(A)+P(\bar{A})+P(\phi)+P(\phi)+\cdots$<br>即$1&#x3D;P(A)+P(\bar{A})$</p>
<p>3.对于$n$个互不相容的事件$A_1,A_2,\cdots A_n$，有$P(\bigcup\limits_{i&#x3D;1}^{n}A_i)&#x3D;\sum\limits_{i&#x3D;1}^nP(A_i)$</p>
<p>$Proof$：利用数学归纳法。</p>
<p>4.对任意两个事件$A$和$B$，若$A\supset B$，则<br>（1）$P(A-B)&#x3D;P(A)-P(B)$<br>（2）$P(A)\geq P(B)$（概率的单调性）</p>
<p>$Proof$：将$A$分为两个互不相容事件$B$与$A-B$的并，由可列可加性公理得：$P(A)&#x3D;P(B)+P(A-B)$<br>再有非负性公理：$P(A-B)\geq 0$，即可得到（2）。</p>
<p>5.对任一事件$A$，有$0\leq P(A) \leq 1$<br>$Proof$：对任一事件$A$，总有:$\phi \subset A \subset \Omega$，由概率的单调性知$P(\phi)\leq P(A) \leq P(\Omega)$则有$0\leq P(A) \leq 1$。</p>
<p>6.对任意两个事件$A$和$B$，有：<br>（1）$P(A\cup B)&#x3D; P(A)+P(B)-P(AB)$<br>（2）$P(A\cup B)\leq P(A)+P(B)$</p>
<p>$Proof$：由于并事件可以写成两个互不相容的事件$A$与$B-AB$的并，从可加性公理有$P(A)&#x3D;P(B)+P(B-AB)$，又因为$B \supset AB$，则由性质4（1）有：$P(B-AB)&#x3D;P(B)-P(AB)$，带回即有（1）。再由$P(AB)\geq 0$立即得到（2）。</p>
<p>注记：将集合拆成几个不相交集合的并是集合论证明中常用的方法。</p>
<p>$Ex$：对任意两个事件A与B，证明$P(A)&#x3D;P(AB)+P(A\bar{B})$</p>
<p>$Ex2$：对任一三个事件$A,B,C$有：<br>（1）$P(A\cup B\cup C)&#x3D;P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)$<br>（2）$P(A\cup B\cup C)\geq P(A)+P(B)+P(C)$</p>
<br />

<p>$Eg$：设$P(A)&#x3D;1&#x2F;3,P(B)&#x3D;1&#x2F;2$<br>（1）：若事件$A$和$B$互不相容，求$P(B\bar{A})$<br>（2）：若$A\subset B$求$P(B\bar{A})$<br>（3）：若$P(AB)&#x3D;1&#x2F;8$，求$P(B\bar{A})$</p>
<p>$Sol$：<br>（1）因为$A$，$B$互不相容，所以$A\cap B &#x3D; \phi$，即$B \subset \bar{A}$，即有$\bar{A}&#x3D;B$，故$P(B\bar{A})&#x3D;P(B)&#x3D;1&#x2F;2$<br>（2）因为$P(B)&#x3D;P(AB)+P(B\bar{A})$且$A\subset B$，所以$P(AB)&#x3D;P(A)&#x3D;1&#x2F;3$，则有<br>$P(B\bar{A})&#x3D;$ $P(B)-P(AB)&#x3D;1&#x2F;6$<br>（3）同（2），有$P(B\bar{A})&#x3D;P(B)-P(AB)&#x3D;1&#x2F;2-1&#x2F;8&#x3D;3&#x2F;8$</p>
<br />

<p>$eg2$：某人对事件$A,B$及其并$A\cup B$分别给出主观概率如下：$P(A)&#x3D;1&#x2F;3,P(B)&#x3D;1&#x2F;3,P(A\cup B)&#x3D;3&#x2F;4$<br>按概率性质，应有$P(A\cup B)\leq P(A)+P(B)$，然而现在$P(A\cup B)&#x3D;3&#x2F;4$，$P(A)+P(B)&#x3D;2&#x2F;3$这个性质不满足。问题是出在了主管概率给定不恰当引起的。例如将$P(A\cup B)$修整成$3&#x2F;5$即可。</p>
<h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><p>$Def$：对任意两个事件$A,B$，若有$P(AB)&#x3D;P(A)+P(B)$，则称事件$A$与事件$B$相互独立，简称$A$和$B$独立。否则称事件$A$和$B$不独立。</p>
<p>注记：独立与互不相容没有必然联系，独立表示两件事件之间没有关系，而互不相容表示两件事件之间不可能同时发生。</p>
<p>$Th$：若事件$A$和$B$独立，则$A$与$\bar{B}$独立，$\bar{A}$与$B$独立，$\bar{A}$与$\bar{B}$独立。</p>
<p>$Proof$：$A\bar{B}&#x3D;A-AB$，又因为$AB\subset A$，再由A与B的独立性知：<br>$P(A\bar{B})&#x3D;P(A)-P(AB)&#x3D;P(A)-P(A)P(B)&#x3D;P(A)(1-P(B))&#x3D;P(A)P(\bar{B})$<br>其余的类似可证。</p>
<h4 id="多个事件的独立性"><a href="#多个事件的独立性" class="headerlink" title="多个事件的独立性"></a>多个事件的独立性</h4><p>设有$n$个事件$A_1,A_2,\cdots A_n$，假如对所有可能的$1\leq i&lt;j&lt;k&lt;\cdots \leq n$以下等式均成立：</p>
<p>$<br>\begin{cases}<br>P(A_iA_j)&#x3D;P(A_i)P(A_j) \\<br>P(A_iA_jA_k)&#x3D;P(A_i)P(A_j)P(A_k) \\<br>\cdots \\<br>P(A_1A_2\cdots A_n)&#x3D;P(A_1)P(A_2)\cdots P(A_n) \\<br>\end{cases}<br>$</p>
<p>则称这$n$个事件相互独立。</p>
<p>注记：只满足$P(A_iA_j)&#x3D;P(A_i)P(A_j)$是不可以的，我们有伯恩斯坦反例：</p>
<p>一个均匀的正四面体，第一面染上红色，第二面染上白色，第三面染上黑色，第四面同时染上红，白，黑三种颜色。记事件 $A,B,C$分别表示投一次均匀的正四面体出现红，白，黑颜色的事件。则$P(A)&#x3D;P(B)&#x3D;P(C)&#x3D;1&#x2F;2$，$P(AB)&#x3D;P(AC)&#x3D;P(BC)&#x3D;1&#x2F;4$，但是$P(ABC)&#x3D;1&#x2F;4$</p>
<p>本质是因为只有两两独立我们推不出$AB$和$C$独立、$A\cup B$和$C$独立。</p>
<p>有一个更直观的例子是波罗梅奥环，可以自行查阅。</p>
<h4 id="试验的独立性"><a href="#试验的独立性" class="headerlink" title="试验的独立性"></a>试验的独立性</h4><p>假设有$n$个试验$E_1,E_2,\cdots E_n$，假设$E_1$的任一结果，$E_2$的任一结果，$\cdots $  $ E_n$的任一结果都是相互独立的事件，则称试验  $E_1,E_2,\cdots E_n$是相互独立。如果这$n$次试验是相同的，则称其为$n$次独立重复试验。</p>
<p>$eg$：扔一枚硬币和扔一颗骰子是相互独立试验。</p>
<h3 id="n重伯努利试验"><a href="#n重伯努利试验" class="headerlink" title="n重伯努利试验"></a>n重伯努利试验</h3><p>$Def($伯努利试验$)$：只有两个结果$(A$和$\bar{A})$的试验称为伯努利试验。</p>
<p>在一次伯努利试验中，设发生$A$的概率为$p$，则有$P(A)&#x3D;p,P(\bar{A})&#x3D;1-p$</p>
<p>$Def(n$重伯努利试验$)$：由$n$次相同的，独立的伯努利试验组成的多随机试验成为$n$重伯努利试验。</p>
<p>$n$重伯努利试验可以用长度为$n$的$A$和$\bar{A}$的序列表示。</p>
<h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>$Def($条件概率$)$：设$A$和$B$是样本空间$\Omega$中的两个事件，且$P(B)&gt;0$，在事件$B$已经发生的条件下，事件$A$的条件概率$P(A|B)$定义为$\frac{P(AB)}{P(B)}$。</p>
<h4 id="条件概率的性质："><a href="#条件概率的性质：" class="headerlink" title="条件概率的性质："></a>条件概率的性质：</h4><p>1.条件概率是概率，即满足概率的$3$条公理。</p>
<p>2.（乘法公式）：对任意两个事件$A$和$B$，有：<br>$$P(AB)&#x3D;P(A|B)P(B)&#x3D;P(B|A)P(A)$$其中第一个等式要求$P(B)&gt;0$，第二个等式要求$P(A)&gt;0$</p>
<p>怎么理解？<br>通俗的来说，以第一个等式为例：$P(B)$表示将样本空间$\Omega$限制在了集合$B$上，$P(A|B)$代表将集合$A$限制在了集合$B$上。</p>
<p>2的结论还可以推广到多个事件</p>
<p>3.（一般乘法公式）：对任意$3$个事件$A,B,C$，假若$P(BC)&gt;0$，则有：$$P(ABC)&#x3D;P(A)P(B|A)P(C|AB)$$</p>
<p>$Def$：把样本空间$\Omega$分为$n$个事件$B_1,B_2,\cdots, B_n$，假如：<br>（1）$P(B_i)&gt;0,i&#x3D;1,2,\cdots, n$<br>（2）$B_1,B_2,\cdots B_n$互不相容<br>（3）$\bigcup\limits_{i&#x3D;1}^n B_i&#x3D;\Omega$<br>则称事件组$B_1,B_2,\cdots B_n$为样本空间$\Omega$的一个分割。</p>
<p>4.（全概率公式）：设$B_1,B_2,\cdots B_n$是样本空间$\Omega$的一个分割，则对$\Omega$的任意一事件$A$，有<br>$$P(A)&#x3D;\sum\limits_{i&#x3D;1}^nP(A|B_i)P(B_i)$$</p>
<p>怎么理解？<br>把$B_i$看成每个小空间，讲$B_i$上$A$发生的概率加起来就是$A$在$\Omega$上发生的概率。</p>
<p>5.（贝叶斯公式）：设事件$B_1,B_2,\cdots, B_n$是样本空间$\Omega$的一个分割，且他们各自的概率皆已知且为正，又设$A$是$\Omega$中的一个事件，$P(A)&gt;0$，且在$B_i$给定下事件$A$的条件概率$P(A|B_1),P(A|B_2),\cdots,P(A|B_n)$已知。则在$A$给定下，事件$B_k$的条件概率为：<br>$$P(B_k|A)&#x3D;\frac{P(A|B_k)P(B_k)}{P(A)}&#x3D;\frac{P(A|B_k)P(B_k)}{\sum\limits_{i&#x3D;1}^n P(A|B_i)P(B_i)}$$</p>
<p>我们称$P(B_k|A)$为后验概率，而$P(B_k)$为先验概率。</p>
<p>怎么理解？<br>我们把$B_i$看成一个人的决策集合，$P(B_i)$代表做$B_i$的决策的概率，现在通过试验我们得到了一个结果$A$，利用$A$我们可以得到$A$发生的时候$B_i$发生的概率，这样为做决策得到了试验的依据，可以根据试验情况改变决策。</p>
<h4 id="条件概率的例子"><a href="#条件概率的例子" class="headerlink" title="条件概率的例子"></a>条件概率的例子</h4><p>下面对于三个公式各给出一个例子</p>
<p>$eg1$（波利亚坛子模型）：设摊子内有$b$个黑球和$r$个红球，每次随机取出一个球， 把原球放回，还加进（与取出的球）同色的$c$个和异色球$d$个，这里$c$和$d$都是已知的整数。设$B_i$表示“第$i$次取出的是黑球”这一事件，$R_j$表示“第$j$次取出的是红球”这一事件，我们来研究下面几个事件的概率：<br>$$ P(B_1R_2R_3)&#x3D;P(B_1)P(R_2|B_1)P(R_3|R_2B_1)&#x3D;\frac{b}{b+r}\cdot\frac{r+d}{(b+c)+(r+d)}\cdot\frac{r+d+c}{(b+c+d)+(r+d+c)}$$</p>
<p>$$P(R_1B_2R_3)&#x3D;P(R_1)P(B_2|R_1)P(R_3|B_2R_1)&#x3D;\frac{r}{b+r}\cdot\frac{b+d}{(b+d)+(r+c)}\cdot\frac{r+c+d}{(b+d+c)+(r+c+d)} $$</p>
<p>$$ P(R_1R_2B_3)&#x3D;P(R_1)P(R_2|R_1)P(B_3|R_2R_1)&#x3D;\frac{r}{b+r}\cdot\frac{r+c}{(b+d)+(r+c)}\cdot\frac{b+2d}{(b+d+d)+(r+c+c)}$$</p>
<p>可以发现，这三个概率不一样，表明黑球出现的次序在影响着概率。</p>
<p>我们研究几个特殊的情况：</p>
<p>（1）$c&gt;0,d&#x3D;0$。这意味着每次取出球后会增加下一次也取到同色球的概率，这是一个传染病模型。每次发现一个传染病患者，以后都会增加再传染的概率。在这种情况下，上面三个概率分别为：</p>
<p>$$ P(B_1R_2R_3)&#x3D;\frac{b}{b+r}\cdot\frac{r}{(b+c)+(r)}\cdot\frac{r+c}{(b+c)+(r+c)}$$</p>
<p>$$P(R_1B_2R_3)&#x3D;\frac{r}{b+r}\cdot\frac{b}{(b)+(r+c)}\cdot\frac{r+c}{(b+c)+(r+c)} $$</p>
<p>$$ P(R_1R_2B_3)&#x3D;\frac{r}{b+r}\cdot\frac{r+c}{(b)+(r+c)}\cdot\frac{b}{(b)+(r+c+c)}$$</p>
<p>可以发现这三个概率相同，这表明在$d&#x3D;0$的时候，上述概率只与黑球和红球的次数有关，而与次序无关。</p>
<p>（2）$c&#x3D;0,d&gt;0$这是一个安全模型，每当发生事故（抓出红球）的时候安全工作就抓紧一些（放入黑球），否则就放松一些（放入红球），在这种情况下，上述三个概率分别为：</p>
<p>$$ P(B_1R_2R_3)&#x3D;\frac{b}{b+r}\cdot\frac{r+d}{(b)+(r+d)}\cdot\frac{r+d}{(b+d)+(r+d)}$$</p>
<p>$$P(R_1B_2R_3)&#x3D;\frac{r}{b+r}\cdot\frac{b+d}{(b+d)+(r)}\cdot\frac{r+d}{(b+d)+(r+d)} $$</p>
<p>$$ P(R_1R_2B_3)&#x3D;\frac{r}{b+r}\cdot\frac{r+c}{(b+d)+(r)}\cdot\frac{b+2d}{(b+d+d)+(r)}$$</p>
<p>这三个概率不相同，说明出事故的顺序影响着第$k$次出事故的概率。</p>
<p>（3）$c&#x3D;0,d&#x3D;0$，这是放回模型，抽$n$次抽出红球的次数这一随机变量服从二项分布$B(n,r&#x2F;(b+r))$<br>（4）$c&#x3D;-1,d&#x3D;0$，这是不放回模型，抽$n$次抽出红球的次数这一随机变量服从超几何分布。</p>
<br />

<p>$eg2$（敏感问题调查模型）：调查敏感问题时，有些人不愿如实回答，这时我们可以设计两个问题：</p>
<p>A：你的生日是否在7月1日以前？<br>B为敏感问题。</p>
<p>在问卷上我们只有是和否两个选项，同时设置一个包含红球和黑球的罐子，若抽出红球则回答A，否则回答B。且设罐中有红球$r$个，有黑球$b$个。（我们认为这个过程没有人监督，即所有填写问卷的人都如实回答。）<br>在调查后，我们可以得到问卷中填是的频率是$f&#x3D;\frac{k}{n}$，我们用频率估计概率得到$P(是)&#x3D;\frac{k}{n}$。<br>这里回答“是”有两种情况。一种是摸到红球回答“是”，一种是摸到黑球回答“是”。<br>对于第一种情况我们认为$P(是|红球)&#x3D;0.5$，而对于第二种情况，我们想知道的就是$P(是|黑球)$，设为$p$。<br>我们可以得到：<br>$$P(是)&#x3D;P(红球)\cdot P(是|红球)+P(黑球)\cdot P(是|黑球)$$<br>即：<br>$$\frac{k}{n}&#x3D;\frac{r}{r+b}\cdot 0.5 + \frac{b}{b+r}\cdot p$$<br>由此我们可以直接解出$p$。</p>
<br />

<p>$eg3$：为提高公司产品的质量，公司经理经过考虑后增加投资来改进生产设备，但从投资效果来看，下属部门有两种意见：<br>$$B_1：改进生产设备后，高质量产品可以占90\%$$<br>$$B_2：改进生产设备后，高质量产品可以占70\%$$<br>经理认为两种事件发生的概率为等可能的，即$P(B_1)&#x3D;P(B_2)&#x3D;0.5$。<br>经过试验一次试验$A$，试验结果为：试制了五个产品，全是高质量产品。<br>经理希望用此结果去改变其对最初观点的看法。我们由贝叶斯公式可以知道：<br>$$P(B_1|A)&#x3D;\frac{P(A|B_1)P(B_1)}{P(B_1)P(A|B_1)+P(B_2)P(A|B_2)}&#x3D;\frac{0.5\cdot 0.9^5}{0.5\cdot 0.9^5+0.5\cdot 0.7^5}$$</p>
<p>$$P(B_2|A)&#x3D;\frac{P(A|B_2)P(B_2)}{P(B_1)P(A|B_1)+P(B_2)P(A|B_2)}&#x3D;\frac{0.5\cdot 0.7^5}{0.5\cdot 0.9^5+0.5\cdot 0.7^5}$$</p>
<p>显然$P(B_1|A)&gt;P(B_2|A)$，所以经理对$B_1$更加信任。</p>
<p>注记：这个例子反映了机器学习中贝叶斯学习的过程。在机器学习中，试验$A$即为训练集中各个标签的频率，然后我们得到了后验概率后就可以在验证集中每个元素的分类。</p>
]]></content>
      <categories>
        <category>概率论</category>
        <category>随机事件及概率</category>
      </categories>
      <tags>
        <tag>条件概率</tag>
        <tag>贝叶斯公式</tag>
        <tag>概率</tag>
        <tag>独立性</tag>
      </tags>
  </entry>
  <entry>
    <title>随机变量及其分布复习笔记</title>
    <url>/2022/04/23/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>随机变量及其分布复习笔记</p>
<span id="more"></span>

<h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><h3 id="什么是随机变量"><a href="#什么是随机变量" class="headerlink" title="什么是随机变量"></a>什么是随机变量</h3><p>用来表示随机现象结果的变量就是随机变量，常用大写字母$X,Y,Z$表示，而随机变量所取的值常用小写字母 $x,y,z$表示。若用等号或不等号把$X$和$x$联系起来就能表示事件，比如“$X&#x3D;x$”,“$Y\leq y$” , “$z_1&lt; Z \leq z_2$”都是事件。</p>
<p>怎么用数学语言表示？</p>
<p>$Def:$定义在样本空间$\Omega$上的实值函数$X&#x3D;X(\omega)$称为随机变量。在实数集上仅取有限个或可列个孤立点的随机变量成为离散型随机变量，可能取值在实数轴上的一个区间$(a,b)$的随机变量称为连续型随机变量，其中$a$可以是$-\infty$，$b$可以是$+\infty$。</p>
<p>可以看到，随机变量就是将样本空间上的每一个事件映射到一个实数的函数。</p>
<p>例如抛出$n(n\geq3)$枚硬币，设随机变量$X$为硬币正面朝上的次数，再设$\omega&#x3D;$朝上的硬币次数为$3$次。则我们可以令$X(\omega)&#x3D;3$。这是非常符合直觉的。</p>
<h3 id="随机变量的分布函数"><a href="#随机变量的分布函数" class="headerlink" title="随机变量的分布函数"></a>随机变量的分布函数</h3><p>$Def$：设$X$是一个随机变量，对任意实数$x$，事件$X\leq x$的概率是$x$的函数，记为：$F(x)&#x3D;P(X\leq x)$这个函数称为$X$的累积分布函数，简称分布函数。</p>
<p>分布函数的一些基本性质：<br>（1）$0\leq F(x)\leq 1$（因为$F(x)$是概率）<br>（2）$\lim\limits_{x\rightarrow -\infty} F(x)&#x3D;0$（事件$X&lt;-\infty$是不可能事件）<br>（3）$\lim\limits_{x\rightarrow +\infty} F(x)&#x3D;1$（事件$X&lt;+\infty$是必然事件）<br>（4）$F(x)$是非降函数，即对$\forall x_1&lt;x_2$，有$F(x_1)\leq F(x_2)$。这是因为事件$X\leq x_2$包含$X\leq x_1$。<br>（5）$F(x)$右连续，即$\lim\limits_{x-&gt;x_0^+}F(x)&#x3D;F(x_0)$<br>对（5）的极限成立做一个简要证明。<br>$Proof$：令$A_n&#x3D;{X \leq x_0 +  \frac{1}{n}}$，则$\bigcap\limits_{n&#x3D;1}^\infty A_n&#x3D;{X\leq x_0}$，则<br>$$\lim\limits_{x-&gt;x_0^+}F(x)&#x3D;\lim\limits_{n\rightarrow \infty}F(x_0+\frac{1}{n})&#x3D;\lim\limits_{n\rightarrow \infty}P(A_n)&#x3D;P(\lim\limits_{n\rightarrow \infty}A_n)&#x3D;P(\bigcap\limits_{n&#x3D;1}^\infty A_n)&#x3D;P(X\leq x_0)&#x3D;F(x_0)$$</p>
<p>注记：上面的推到不严谨，其中第3，4个等号需要证明，感兴趣的读者可以翻阅实变函数中的集合论部分。<br>注记2：对于上面的（3）（4）（5），需要证明极限的存在性，其中（3）（4）的极限存在性可以类似于上面的证明给出，（5）的极限存在性可以用确界定理给出。（这几部分的证明都可以去翻阅实变函数的教材）<br>注记3：分布函数并不是左连续的，反例很容易给出。</p>
<h2 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h2><h3 id="分布列"><a href="#分布列" class="headerlink" title="分布列"></a>分布列</h3><p>$Def$：设$X$是离散随机变量，它的所有可能取值为$x_1,x_2,\cdots , x_n , \cdots$，假如$X$取$x_i$的概率为：$P(X&#x3D;x_i)&#x3D;p(x_i)$，且满足<br>（1）非负性：$p(x_i)\geq 0$<br>（2）正则性：$\sum\limits_{i&#x3D;1}^\infty p(x_i)&#x3D;1$<br>则称这组概率${p(x_i)}$为随机变量$X$的分布列，或$X$的概率分布。</p>
<p>若已知$X$的分布列，则可以很容易的写出$X$的分布函数：$F(x_0)&#x3D;\sum\limits_{x_i\leq x} p(x_i)$</p>
<p>离散型随机变量的分布列还可以用如下表格来表示：</p>
<table>
<thead>
<tr>
<th>$X$</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$\cdots$</th>
<th>$x_n$</th>
<th>$\cdots$</th>
</tr>
</thead>
<tbody><tr>
<td>$P$</td>
<td>$p_1$</td>
<td>$p_2$</td>
<td>$\cdots$</td>
<td>$p_n$</td>
<td>$\cdots$</td>
</tr>
</tbody></table>
<p>除了表格，其还可以用线条图或者概率分布直方图来表示一个随机变量。</p>
<h3 id="伯努利概型中的一些分布"><a href="#伯努利概型中的一些分布" class="headerlink" title="伯努利概型中的一些分布"></a>伯努利概型中的一些分布</h3><h4 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h4><p>$Def$：令$X$为$n$重伯努利试验中成功出现的次数，则$X$是一个随机变量。用$B_{n,k}$表示$n$重伯努利试验中成功出现$k$次，则有$B_{n,k}&#x3D;$“$X&#x3D;k$”，其中$X$的可能取值为$0,1,\cdots ,n$，它取这些值的概率为：$$P(X&#x3D;k)&#x3D;C_n^k\cdot p^k\cdot (1-p)^{(n-k)},k&#x3D;0,1,\cdots ,n$$我们称这个概率分布为二项分布，记为$b(n,p)$。在概率论中“随机变量$X$的概率分布为二项分布$b(n,p)$”常被说成“随机变量$X$服从二项分布$b(n,p)$，<font color="#dd0000">记做$X\sim b(n,p)$</font>。</p>
<h4 id="两点分布"><a href="#两点分布" class="headerlink" title="两点分布"></a>两点分布</h4><p>$n&#x3D;1$的二项分布$b(1,p)$就称为两点分布（也称伯努利分布或者0-1分布）。其概率分布为：<br>$$<br>P(X&#x3D;k)&#x3D;\begin{cases}<br>p &amp; k&#x3D;1 \\<br>(1-p) &amp; k&#x3D;0<br>\end{cases}<br>$$</p>
<h4 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h4><p>我们讨论在伯努利试验中首次出现成功出现在第$k$次的概率，记成功的概率为$p$。若想第$k$次试验首次出现成功，我们需要在前$k-1$次试验中均失败，并且恰好在第$k$次试验出现成功。记$$g(k,p)&#x3D;(1-p)^{k-1}p ~~~~ k&#x3D;1,2,\cdots$$<br>我们称这个分布为几何分布</p>
<p>注记：这个分布的样本空间不是有限的。</p>
<p>注记2：几何分布具有无记忆性，即$$P(X &#x3D; s+t|X\geq s)&#x3D;\frac{P(x &#x3D;  s+t)}{P(X \geq s)}&#x3D;\frac{(1-p)^{s+t-1}\cdot p}{(1-p)^{s}} &#x3D; (1-p)^{t-1} \cdot p $$<br>这说明假定前$s$次没有出现成功，那么再经过$t$次试验成功的概率和直接进行$t$次试验成功的概率是相同的。与此同时，离散型随机变量中，只有几何分布有无记忆性。</p>
<h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>如果随机变量$X$有如下的概率分布：</p>
<p>$$P(X&#x3D;k)&#x3D;\frac{\lambda^k}{k!}e^{-\lambda}$$</p>
<p>就称$X$服从参数设$\lambda$的泊松分布。<font color="#dd0000">记做$X\sim P(\lambda)$</font>。</p>
<p>泊松分布的由来？</p>
<p>先看一个例子：<br>$eg$：某年龄段的保险者中，一年中每个人死亡的概率为$0.005$，现有$10000$个这类人参加保险，保险公司想知道在未来一年中有$40$个人死亡的概率</p>
<p>我们从二项分布可以知道$b(40;10000,0,005)&#x3D;C_{10000}^{40}(0.005)^{40}(0.995)^{9960}$（<font color="#dd0000">我们用$b(k,n,p)$表示$n$重伯努利试验中$A$出现$k$次的概率</font>）而直接计算这个数值相当困难，我们需要有更好的计算方法。</p>
<p>于是我们有泊松逼近定理：</p>
<p>$Th$：在独立试验中，以$p_n$代表事件$A$在试验中出现的概率。它与试验总数$n$有关，如果$np_n\rightarrow\lambda$，则当$n\rightarrow \infty$是，</p>
<p>$$b(k;n,p_n)\rightarrow\frac{\lambda^k}{k!}e^{-\lambda}$$</p>
<p>$Proof$：记$\lambda_n&#x3D;np_n$，则<br>$b(k;n,p_n)&#x3D;C_n^kp_n^k(1-p)^{n-k}&#x3D;\frac{n(n-1)\cdots(n-k+1)}{k!}(\frac{\lambda_n}{n})^k(1-\frac{\lambda_n}{n})^{n-k} $<br>$&#x3D;\frac{\lambda_n^k}{k!}(1-\frac{1}{n})\cdots (1-\frac{k-1}{n})(1-\frac{\lambda_n}{n})^{n-k}$</p>
<p>对于固定的$k$有<br>$$\lim\limits_{n\rightarrow\infty}\lambda_n^k&#x3D;\lambda^k，~~ \lim\limits_{n\rightarrow\infty}(1-\frac{\lambda_n}{n}^{n-k})&#x3D;e^{-\lambda}$$<br>和<br>$$\lim\limits_{n\rightarrow\infty}(1-\frac{1}{n})\cdots (1-\frac{k-1}{n})&#x3D;1$$</p>
<p>因此$$\lim\limits_{n\rightarrow\infty}b(k;n,p_n)&#x3D;\frac{\lambda^k}{k!}e^{-\lambda}$$</p>
<p>在应用中，当$p$相当小（一般当$p\leq0.1$时）我们用如下的近似公式：$$b(k;n,p)\approx\frac{(np)^k}{k!}e^{-np}$$</p>
<p>这就解决了上面二项分布不容易算的问题。</p>
<p>泊松分布发明不止是用来逼近二项分布的，我们还有如下的泊松过程：</p>
<p>考虑来到某交换装置的电话呼叫数，假定它具有下面三个性质：<br>（1）平稳性：在$[t_0,t_0+t)$中来到的呼叫数只与时间间隔长度$t$有关而与时间起点$t_0$无关。<br>（2）独立增量性：在$[t_0,t_0+t)$内来到$k$个呼叫这一事件与$t_0$之前发生的事件独立。<br>（3）普通性：在充分晓得时间间隔中，最多来一个呼叫。若记$\psi(t)&#x3D;1-P_0(t)-P_1(t)&#x3D;\sum\limits_{i&#x3D;2}^\infty P_i(t)$，则应有$\lim\limits_{t\rightarrow 0}\frac{\psi(t)}{t}&#x3D;0$</p>
<p>在这个过程中，可以求得$P_k(t)&#x3D;\frac{(\lambda t)^k}{k!}e^{-\lambda t}$，这正是泊松分布。</p>
<p>详细证明可以参考概率论教材。</p>
<h3 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h3><p>假设有$N$个产品组成的总体，其中含有$M$个不合格品，若丛中随机不放回地抽取$n$个，则其中含有不合格品的个数$X$是一个离散随机变量。假如$n\leq M$，则$X$可以取$0,1,\cdots , n$；若$n&gt;M$，则$X$可能取$0,1,\cdots M$。由古典概型可以计算得：<br>$$P(X&#x3D;x)&#x3D;\frac{C_M^xC_{N-M}^{n-x}}{C_N^n} ~~ x&#x3D;0,1,\cdots r$$<br>其中$r&#x3D;min(n,M)$。<font color="#dd0000">这个分布称为超几何分布，它有三个参数$N,M,n$，记为$h(n,N,M)$</font></p>
<h2 id="连续型随机变量"><a href="#连续型随机变量" class="headerlink" title="连续型随机变量"></a>连续型随机变量</h2><h3 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h3><p>$Def$：设$p(x)$设定义在整个实数轴上的一个函数，假如它满足如下两个性质：<br>（1）非负性：$p(x)\geq 0$<br>（2）正则性：$\int_{-\infty}^{\infty}p(x)dx&#x3D;1$<br>则称$p(x)$是概率密度函数，或密度函数。若随机变量$X$取值的统计规律性可用某个概率密度函数$p(x)$描述，则称$p(x)$为$X$的概率分布，记为$X\sim p(x)$</p>
<p>有了概率密度函数之后，随机变量$X$的分布函数就可以写成如下形式：</p>
<p>$$F(x)&#x3D;\int_{-\infty}^x p(x)dx$$</p>
<p>注记1：概率密度函数不是概率，即$P(X&#x3D;x)\neq p(x)$，事实上，对于$\forall x$,$$P(X&#x3D;x)&#x3D;\lim_{\Delta x \rightarrow 0}P(x+\Delta x)-P(x) &#x3D; \lim_{\Delta x \rightarrow 0} \int_x^{x+\Delta x}p(x)dx &#x3D; 0$$但是我们在$(x,x+\Delta x)$的概率密度可以用$\int_{x}^{x+\Delta x}p(x)dx$来求。类似的，$P(a\leq X \leq b)&#x3D;\int_{a}^{b}p(x)dx$</p>
<p>注记2：我们将概率为零的事件称为零概率事件，但是零概率小事件和不可能事件是有差距的：不可能事件一定是零概率事件，但是零概率事件不一定是不可能事件。同样的，必然事件发生的概率为1，但是发生概率为1的事件不一定是必然事件，我们一般称概率为1的事件为几乎必然发生的事件。</p>
<h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><p>$Def$：若$a,b(b&gt;a)$为有限数，则由下列函数给定的分布称为均匀分布：<br>$$<br>p(x)&#x3D;\begin{cases}<br>\frac{1}{b-a} &amp; a\leq x \leq b\\<br>0 &amp; otherwise<br>\end{cases}<br>$$</p>
<p>对应的分布函数为：<br>$$<br>F(x)&#x3D;\begin{cases}<br>0 &amp; x \leq a\\<br>\frac{x-a}{b-a} &amp; a &lt; x \leq b \\<br>1 &amp; b \leq x<br>\end{cases}<br>$$</p>
<p>注记：我们仍需令其满足分布函数的右连续性，有些课本上将第二个条件写成$a\leq x \leq b$，其实这是不严谨的。</p>
<h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><p>分布密度函数为</p>
<p>$$<br>p(x)&#x3D;\begin{cases}<br>\lambda e^{-\lambda x} &amp; x \geq 0 \\<br>0 &amp; x&lt;0<br>\end{cases}<br>$$</p>
<p>分布函数为</p>
<p>$$<br>F(x)&#x3D;\begin{cases}<br>1- e^{-\lambda x} &amp; x \geq 0 \\<br>0 &amp; x&lt;0<br>\end{cases}<br>$$</p>
<p>其中$\lambda &gt;0$，是参数，这种分布称为指数分布，简记为$Exp(\lambda)$</p>
<p>指数分布有重要的应用，我们常用它来做各种“寿命”的近似，例如电子元器件的寿命等。</p>
<p>指数分布还有类似于几何分布的无记忆性，设$X$服从指数分布，则对$\forall x&gt;0,t&gt;0$，<br>$$P\{X\geq s+t|X\geq s \} &#x3D; \frac{P\{ X\geq s+t\}}{P\{ X\geq s\}} &#x3D; \frac{e^{-\lambda(s+t)}}{e^{-\lambda s}} &#x3D; e^{-\lambda t}$$</p>
<h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p>密度函数为<br>$$p(x)&#x3D;\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}} ~~~ -\infty &lt; x &lt; \infty$$<br>其中$\sigma &gt; 0$，$\mu$和$\sigma$都为常数，相应的分布函数为<br>$$F(x)&#x3D;\int_{-\infty}^x \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(y-\mu)^2}{2\sigma^2}} ~~~ -\infty &lt; y &lt; \infty$$</p>
<p>这种分布称为正态分布，简记为$N(\mu,\sigma ^2)$</p>
<p>特别的，当$\mu&#x3D;0,\sigma&#x3D;1$的时候，这个分布称为标准正态分布，记为$N(0,1)$，相应的密度函数和概率分布函数分解记为$\phi(x)$和$\Phi(x)$</p>
<p>注记：若$X \sim N(\mu,\sigma^2)$，则$U&#x3D;\frac{X-\mu}{\sigma} \sim N(0,1)$。称这样的变换为$X$的标准化变换，称$U$为$X$的标准化随机变量。</p>
<p>注记2：设$X\sim N(\mu,\sigma^2)$，则<br>$$P(a&lt;X&lt;b)&#x3D;\Phi(\frac{b-\mu}{\sigma})-\Phi(\frac{a-\mu}{\sigma})$$</p>
<p>注记3：设$X\sim N(0,1)$，则</p>
<p>$$<br>P(|X-\mu|&lt;k\sigma)&#x3D;\begin{cases}<br>0.6826 &amp; k&#x3D;1 \\<br>0.9544 &amp; k&#x3D;2 \\<br>0.9973 &amp; k&#x3D;3<br>\end{cases}<br>$$<br>我们可以看到落在$3$倍标准差外的样本设很少的，在数据处理的时候一般将其剔除。我们称其为$3\sigma$原则。</p>
]]></content>
      <categories>
        <category>概率论</category>
        <category>随机变量及其分布</category>
      </categories>
      <tags>
        <tag>随机变量</tag>
      </tags>
  </entry>
  <entry>
    <title>随机变量的数学特征复习笔记</title>
    <url>/2022/05/03/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%A6%E7%89%B9%E5%BE%81%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简要介绍数学期望，方差，矩，分位数</p>
<span id="more"></span>

<h2 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h2><p>在日常生活中，求平均值是一个很常见的一种运算，例如求平均分，平均工资等。假设我们有$n$个样本，取值分别为$x_1,x_2,\cdots ,x_n$，则他们的平均值即为：<br>$$\bar{x}&#x3D;\frac{x_1+x_2+\cdots +x_n}{n}$$<br>加入我们给这些数一个权值$w_1,w_2,\cdots ,w_n$，则令</p>
<p>$$\bar{x}&#x3D;\sum\limits_{i&#x3D;1}^n w_ix_i$$<br>称为这$n$个样本的加权平均。</p>
<p>$Def$：设$X$为一离散型随机变量，它取值$x_1,x_2,\cdots $对应概率为$p_1,p_2,\cdots$，如果级数<br>$$\sum_{i&#x3D;1}^\infty x_ip_i$$<br>绝对收敛，则将其称为$X$的数学期望，简称期望，或均值，记为$EX$。</p>
<p>注记：当$\sum\limits_{i&#x3D;1}^\infty |x_i|p_i$发散时，则说$X$的期望不存在。（此时即使$\sum\limits_{i&#x3D;1}^\infty x_ip_i$条件收敛，我们也可以通过调换顺序让其和为任意值。）</p>
<p>$Def2$：设$X$设连续型随机变量，当积分$\int_{-\infty}^\infty x p(x)dx$绝对收敛时，我们称它为$X$的数学期望，记做$EX$</p>
<p>从Riemann-Stieltjes积分的角度可以这么定义：<br>$Def3$：若$X$的分布函数为$F(x)$，则定义<br>$$EX&#x3D;\int_{-\infty}^\infty xdF(x)$$<br>为$X$的数学期望（我们这里还要求上述积分绝对收敛）。</p>
<h3 id="随机变量函数的数学期望"><a href="#随机变量函数的数学期望" class="headerlink" title="随机变量函数的数学期望"></a>随机变量函数的数学期望</h3><p>$Th$：若$g(x)$是一元博雷尔函数，且$\eta &#x3D; g(\xi)$，则<br>$$\int_{-\infty}^{\infty}ydF_\eta(y)&#x3D;\int_{-\infty}^{\infty}g(x)dF_\xi(x)$$</p>
<p>注记：等式左端是$\eta$的数学期望的计算公式，而右边是将$x$替换成了$g(x)$所得到的，我们可以证明这两者相等。</p>
<p>在离散型场合，我们有<br>$$Eg(\xi)&#x3D;\sum\limits_{i&#x3D;1}^\infty g(x_i)p(x_i)$$<br>在连续型场合，我们有<br>$$Eg(\xi)&#x3D;\int_{-\infty}^{\infty}g(x)p(x)dx$$</p>
<h3 id="数学期望的性质"><a href="#数学期望的性质" class="headerlink" title="数学期望的性质"></a>数学期望的性质</h3><p>性质1：设$a,b,c$为常数，若$a\leq \xi \leq b$，则$a\leq E\xi \leq b$，特别的$Ec&#x3D;c$。</p>
<p>性质2：线性性：对任一常数$c_i ~ i&#x3D;1,2,\cdots n$和$b$有<br>$$E(\sum\limits_{i&#x3D;1}^n c_iX_i+b)&#x3D;\sum\limits_{i&#x3D;1}^n c_iEX_i+b$$<br>特别地<br>$$E(\sum\limits_{i&#x3D;1}^n X_i)&#x3D;\sum\limits_{i&#x3D;1}^n EX_i$$</p>
<h3 id="数学期望的求法"><a href="#数学期望的求法" class="headerlink" title="数学期望的求法"></a>数学期望的求法</h3><p>我们在这里介绍几种分布的数学期望的求法。</p>
<p>1.二项分布$X\sim b(n,p)$</p>
<p>$$Ex&#x3D;\sum\limits_{k&#x3D;0}^n kC_n^kp^kq^{n-k}&#x3D;np\sum\limits_{k&#x3D;1}^nC_{n-1}^{k-1}p^{k-1}q^{n-k}&#x3D; np(p+q)^{n-1}&#x3D;np$$<br>注记：我们用到了组合恒等式$k\cdot C_n^k&#x3D;n\cdot C_{n-1}^{k-1}$和二项式定理。</p>
<p>2.柯西分布$p(x)&#x3D;\frac{1}{\pi}\cdot \frac{1}{1+x^2}$<br>由于$$\int_{-\infty}^{\infty}|x|\frac{1}{\pi \cdot (1+x^2)}&#x3D;\infty$$<br>因此柯西分布的数学期望不存在。<br>注记：事实上，上述积分甚至不条件收敛，但是其有柯西主值0。</p>
<p>3.正态分布$N(\mu,\sigma^2)$<br>令$Y&#x3D;\frac{X-\mu}{\sigma}$，则$Y\sim N(0,1)$我们有<br>$$EY&#x3D;\int_{-\infty}^{\infty}\frac{1}{\sqrt{2\pi}}\cdot xe^\frac{-x^2}{2}dx&#x3D;0$$<br>那么$EX&#x3D;E(\sigma Y+\mu)&#x3D;\mu$<br>注记：正态分布的第一个分量是其数学期望。</p>
<p>4.超几何分布的数学期望<br>设想一个不放回的抽样，令<br>$$<br>x_i&#x3D;\begin{cases}<br>1 &amp; 第i次抽得次品 \\<br>0 &amp; 第i次抽得好品<br>\end{cases}<br>$$<br>则$P(x_i&#x3D;1)&#x3D;\frac{M}{N}$，因此$EX_i&#x3D;\frac{M}{N}$，而$X&#x3D;X_1+\cdots + X_n$，表示$n$次不放回抽样中抽出的次品数。他服从上述超几何分布，则有<br>$$EX&#x3D;EX_1+\cdots EX_n&#x3D;\frac{nM}{N}$$</p>
<h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><p>$Def$：设随机变量$X$的$EX^2$存在，则称偏差$X-EX$平方的数学期望$E[X-EX]^2$为随机变量$X$的方差，记为$DX$或者$Var(X)$。</p>
<p>注记：<br>$$E(X-EX)^2&#x3D;E(X^2-2X\cdot EX+(EX)^2)&#x3D;EX^2-2EX\cdot EX+(EX)^2&#x3D;EX^2-(EX)^2$$<br>在实际计算的时候我们可以用此公式$来计算</p>
<h3 id="方差的性质"><a href="#方差的性质" class="headerlink" title="方差的性质"></a>方差的性质</h3><p>性质1:常数的方差为0<br>性质2:$D(X+c)&#x3D;DX$，这里$c$是常数<br>性质3:$D(cX)&#x3D;c^2DX$，这里$c$是常数<br>性质4:若$c\neq EX$，则$DX&lt;E(X-c)^2$<br>$Proof$:因为<br>$$DX&#x3D;E(X-EX)^2&#x3D;E((X-c)-(EX-c))^2&#x3D;E(X-c)^2-(EX-c)^2$$<br>所以$EX\neq c$时，$DX&gt;E(X-c)^2$.<br>注记：对于随机变量$X$,若他的数学期望$EX$和方差$DX$都存在，且$DX&gt;0$，我们有时可以考虑标准化随机变量$X^*&#x3D;\frac{X-EX}{\sqrt{DX}}$，显然$EX^*&#x3D;0,DX^*&#x3D;1$，这正是称$X^*$为标准化随机变量的理由。</p>
<h3 id="切比雪夫不等式"><a href="#切比雪夫不等式" class="headerlink" title="切比雪夫不等式"></a>切比雪夫不等式</h3><p>$Th$：对于任何具有有限方差的随机变量$X$，都有<br>$$P(|X-EX|\geq \epsilon)\leq \frac{DX}{\epsilon^2}$$</p>
<p>$Proof$：设$F(x)$是$X$的分布函数，则显然有<br>$$DX&#x3D;\int_{-\infty}^\infty(x-EX)^2dF(x)\geq \int\limits_{|x-EX|\geq \epsilon}(x-EX)^2dF(x)\geq \int\limits_{|x-EX|\geq \epsilon}\epsilon^2 dF(x)$$<br>$$&#x3D;\epsilon^2 P(|X-EX|\geq \epsilon)$$</p>
<p>注记：我们这里的积分仍然是$Riemann-Stieltjes$积分</p>
<h2 id="常见分布的数学期望和方差"><a href="#常见分布的数学期望和方差" class="headerlink" title="常见分布的数学期望和方差"></a>常见分布的数学期望和方差</h2><p>下面给出一些最常见的分布的数学期望和方差</p>
<h3 id="离散型"><a href="#离散型" class="headerlink" title="离散型"></a>离散型</h3><table>
<thead>
<tr>
<th>分布名称</th>
<th>概率分布或密度函数$p(x)$</th>
<th>数学期望</th>
<th>方差</th>
</tr>
</thead>
<tbody><tr>
<td>退化分布</td>
<td>$p_c&#x3D;1$ $(c$为常数$)$</td>
<td>$c$</td>
<td>$0$</td>
</tr>
<tr>
<td>两点分布</td>
<td>$p_k&#x3D;\begin{cases}q &amp; k&#x3D;0 \\ p &amp; k&#x3D;1 \end{cases},$     $~~~~ 0&lt;p&lt;1,q&#x3D;1-p$</td>
<td>$p$</td>
<td>$pq$</td>
</tr>
<tr>
<td>二项分布</td>
<td>$b(k;n,p)&#x3D;C_n^kp^kq^{n-k} ~~~ k&#x3D;0,1,\cdots n, ~~~ 0&lt;p&lt;1, ~~~ q&#x3D;1-p$</td>
<td>$np$</td>
<td>$npq$</td>
</tr>
<tr>
<td>泊松分布</td>
<td>$p(k;\lambda)&#x3D;\frac{\lambda^k}{k!}e^{-\lambda}, ~~~ k&#x3D;0,1,\cdots, ~~~ \lambda &gt;0$</td>
<td>$\lambda$</td>
<td>$\lambda$</td>
</tr>
<tr>
<td>几何分布</td>
<td>$g(k;p)&#x3D;q^{k-1}p, ~~~ k&#x3D;1,2,\cdots,~~~ 0&lt;p&lt;1, ~~~ q&#x3D;1-p$</td>
<td>$\frac{1}{p}$</td>
<td>$\frac{q}{p^2}$</td>
</tr>
<tr>
<td>超几何分布</td>
<td>$p_k&#x3D;\frac{C_M^k C_{N-M}^{n-k}}{C_N^n}, ~~~ M\leq N,n\leq N, ~~~ k&#x3D;0,1,\cdots min(M,n)$</td>
<td>$ \frac{nM}{N}$</td>
<td>$\frac{nM}{N}(1-\frac{M}{N})\cdot \frac{N-n}{N-1}$</td>
</tr>
</tbody></table>
<h3 id="连续型"><a href="#连续型" class="headerlink" title="连续型"></a>连续型</h3><table>
<thead>
<tr>
<th>分布名称</th>
<th>概率分布或密度函数$p(x)$</th>
<th>数学期望</th>
<th>方差</th>
</tr>
</thead>
<tbody><tr>
<td>正态分布$N(\mu,\sigma^2)$</td>
<td>$p(x)&#x3D;\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}, ~~~ -\infty &lt; x &lt; \infty , ~~~ \mu ,\sigma &gt;0$</td>
<td>$\mu$</td>
<td>$\sigma^2$</td>
</tr>
<tr>
<td>均匀分布 $U[a,b]$</td>
<td>$p(x)&#x3D;\begin{cases}\frac{1}{b-a} &amp; a\leq x \leq b \\ 0 &amp; otherwise \end{cases}, ~~~ a&lt;b$</td>
<td>$\frac{a+b}{2}$</td>
<td>$\frac{(b-a)^2}{12}$</td>
</tr>
<tr>
<td>指数分布$Exp(\lambda)$</td>
<td>$p(x)&#x3D;\begin{cases}\lambda e^{-\lambda x} &amp; x\geq 0 \\ 0 &amp; x&lt;0 \end{cases} ~~~ \lambda &gt;0$</td>
<td>$\frac{1}{\lambda}$</td>
<td>$\frac{1}{\lambda^2}$</td>
</tr>
<tr>
<td>$\chi^2$分布</td>
<td>$p(x)&#x3D;\begin{cases}\frac{1}{2^{n&#x2F;2}\Gamma(\frac{n}{2})}x^{\frac{n}{2}-1}e^{-\frac{x}{2}} &amp; x\geq 0 \\ 0 &amp; x&lt;0 \end{cases} ~~~ n\in \mathbb{Z}$</td>
<td>$n$</td>
<td>$2n$</td>
</tr>
<tr>
<td>柯西分布</td>
<td>$p(x)&#x3D;\frac{1}{\pi}\cdot \frac{\lambda}{\lambda^2+(x-\mu)^2},~~~ -\infty &lt; x &lt; \infty, ~~~ \lambda&gt;0 $</td>
<td>不存在</td>
<td>不存在</td>
</tr>
</tbody></table>
<h2 id="其他数学特征"><a href="#其他数学特征" class="headerlink" title="其他数学特征"></a>其他数学特征</h2><h3 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h3><p>$Def$：设$X$为随机变量，$c$为常数，$k$为正整数，则量$E(X-c)^k$（假如它存在）称为<font color="#dd0000">$X$分布关于$c$的$k$阶矩</font>。若$c&#x3D;0$，则量$EX^k$成为$X$分布的<font color="#dd0000">$k$阶原点矩</font>，记为$\mu_k$，若$c&#x3D;EX$，则量$E(X-EX)^k$称为$X$分布的<font color="#dd0000">$k$阶中心矩</font>，记为$\nu_k$。<br>注记1:一阶原点矩就是数学期望，二阶中心矩就是方差。在实际应用中很少应用四阶以上的矩。<br>注记2:由于$|X|^{k-1}\leq |X|^k+1$故$k$阶矩存在时，$k-1$阶矩也存在，从而低于$k$阶的矩都存在。<br>注记3:原点矩和中心矩可以互相表出。<br>$$\nu_k&#x3D;E(X-EX)^k&#x3D;E(X-\mu_1)^k&#x3D;\sum_{i&#x3D;0}^k C_k^i\mu_i(-\mu_1)^{k-i}$$<br>$$\mu_k&#x3D;EX^k&#x3D;E((X-\nu_1)+\nu_1)^k&#x3D;\sum_{i&#x3D;0}^k C_k^i \nu_{k-i}\mu_1^i$$</p>
<h3 id="分位数和中位数"><a href="#分位数和中位数" class="headerlink" title="分位数和中位数"></a>分位数和中位数</h3><p>$Def$：对$0&lt;p&lt;1$，若$F(x_p)\leq p \leq F(x_p^+)$，则称$x_p$为分布函数$F(x)$的$p$分位数。其中$x_{0.5}$称为中位数。</p>
<h3 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h3><p>$Def$：设$X$是离散型随机变量，则$X$的最可能取的值称为$X$分布的众数。</p>
]]></content>
      <categories>
        <category>概率论</category>
        <category>随机变量及其分布</category>
      </categories>
      <tags>
        <tag>方差</tag>
        <tag>数学期望</tag>
        <tag>矩</tag>
        <tag>分位数</tag>
      </tags>
  </entry>
  <entry>
    <title>非线性规划</title>
    <url>/2022/05/26/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>复习非线性规划</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>令$\pmb{x}&#x3D;(x_1,x_2,\cdots，x_n)$是$n$维欧氏空间$\mathbf{R}^n$中的一个点.$f(\pmb{x}),g_i(\pmb{x}), ~ i&#x3D;1,\cdots p ~ $和$ ~ h_j(\pmb{x}), ~ j&#x3D;1,\cdots q$是定义在$\mathbf{R}^n$上的实值函数。我们称如下形式的数学模型为数学规划（Mathematical Programming，简记为MP）<br>$$<br>\begin{cases}<br>\min  &amp; f(\pmb{x}) \\<br>s.t. &amp; g_i(\pmb{x})\leq 0, &amp; i&#x3D;1,\cdots, p \\<br> ~   &amp; h_j(\pmb{x})&#x3D;0, &amp; j&#x3D;1,\cdots, q \\<br>\end{cases}<br>$$<br>令<br>$$X&#x3D;\{x\in \mathbf{R}^n | g_i(\pmb{x})\leq 0 , ~ h_j(\pmb{x})&#x3D;0 \}$$<br>称$X$为（MP）的约束集或可行域，对任意的$\pmb{x}\in X$，称$\pmb{x}$为（MP）的可行解或可行点。故（MP）可简记为</p>
<p>$$\min_{\pmb{x}\in X}f(\pmb{x})$$</p>
<p>当$f(\pmb{x}),g_i(\pmb{x}),h_j(\pmb{x})$都为$\pmb{x}$的线性函数的时候，（MP）即为线性规划，否则称为非线性规划。</p>
<p><font color="#dd0000"> 以下讨论都针对的是非线性规划。</font><br /></p>
<p>当$X&#x3D;\mathbf{R}^n$时，将其简记为</p>
<p>$$\min f(\pmb{x})$$</p>
<p>称其为无约束线性规划，否则称为约束非线性规划。</p>
<p>$Def$：对于非线性规划（MP），若$\pmb{x}^{*} \in X$并且有$$f(\pmb{x}^*)\leq f(\pmb{x}), ~~ \forall \pmb{x} \in X$$</p>
<p>则称$\pmb{x}^{*}$是（MP）的整体最优解，称$f(\pmb{x}^{*} ) $为整体最优值。</p>
<p>若有$$f(\pmb{x}^*) &lt; f(\pmb{x}) ,~~ \forall \pmb{x} \in X,\pmb{x} \neq \pmb{x}^*$$</p>
<p>则称$\pmb{x}^{*}$是（MP）的严格整体最优解，称$ f(\pmb{x}^{*} ) $为严格整体最优值。</p>
<p>$Def$：对于非线性规划（MP），若$\pmb{x}^{*} \in X$，并且存在一个邻域$N_{\delta}(\pmb{x}^{*}) &#x3D; \{ \pmb{x} \in   \mathbf{R}^n | ~~ \lVert \pmb{x} - \pmb{x}^{*} \rVert &lt;\delta \}$ （$\delta &gt;0$是实数），使$$f(\pmb{x}^*)\leq f(\pmb{x}), ~~ \forall \pmb{x} \in N_\delta(\pmb{x}^{*}) \cap X$$</p>
<p>则称$\pmb{x}^{*}$是（MP）的局部最优解，称$f(\pmb{x}^{*} ) $为局部最优值。</p>
<p>若有$$f(\pmb{x}^*) &lt; f(\pmb{x}) ,~~ \forall \pmb{x} \in N_\delta(\pmb{x}^{*}) \cap X,\pmb{x} \neq \pmb{x}^*$$</p>
<p>则称$\pmb{x}^{*}$是（MP）的严格局部最优解，称$ f(\pmb{x}^{*} ) $为严格局部最优值。</p>
<h2 id="非线性规划方法概述"><a href="#非线性规划方法概述" class="headerlink" title="非线性规划方法概述"></a>非线性规划方法概述</h2><p>对于无约束的最优化问题，根据lagrange乘数法，我们可以求目标函数$f(x_1,x_2,\cdots x_n)$的驻点，即要求解使$\nabla f(\pmb{x})&#x3D;(\frac{\partial f}{\partial x_1},\frac{\partial f}{\partial x_2},\cdots,\frac{\partial f}{\partial x_n})&#x3D;\pmb{0}$</p>
<p>这样的解法有许多缺点。<br>首先：我们这里要求$f$是连续可微的，但是很多现实问题的函数不保证有这样良好的性质。<br>其次：对于lagrange乘数法所形成的方程组，除非在极简单的情况，一般没有有效的解法。<br>最后：微分学中的条件极值所出现的约束均为等式约束，但实际应用中存在着大量的不等式问题。</p>
<p>我们尝试去用迭代的方法解决最优化问题。</p>
<p>$Def$：设$f:\mathbf{R}^n \rightarrow \mathbf{R},\bar{\pmb{x}}\in \mathbf{R}^n,\pmb{p}\in\mathbf{R}^n, \pmb{p}\neq \pmb{0}$，若存在$\delta &gt;0$，使得<br>$$f(\bar{\pmb{x}}+t\pmb{p}) &lt; f(\bar{\pmb{x}}), ~~ \forall t \in (0,\delta)$$</p>
<p>则称向量$\pmb{p}$是函数在点$\bar{\pmb{x}}$处的下降方向。</p>
<p>注记：若$f(\pmb{x})$在点$\bar{\pmb{x}}$处可导，则$-\nabla f(\bar{\pmb{x}})$就是$f(\pmb{x})$在$\bar{\pmb{x}}$处下降最快的方向。</p>
<p>$Def$：设$X\subset \mathbf{R}^n$，$\bar{\pmb{x}} \in X , ~~ \pmb{p}\in \mathbf{R}^n, ~~ \pmb{p} \neq \pmb{0}$，若存在$t&gt;0$，使得<br>$$\bar{\pmb{x}}+t\pmb{p}\in X$$<br>则称向量$\pmb{p}$是点$\bar{\pmb{x}}$关于$X$的可行方向。</p>
<p>若一个向量$\pmb{p}$既是目标函数$f$在点$\bar{\pmb{x}}$处的下降方向，又是该点关于可行区域$X$的可行方向，则叫做函数$f$在$\bar{\pmb{x}}$处关于区域$X$的可行下降方向。</p>
<p>现在给出用基本迭代格式求解（MP）的一般步骤<br>step1：选取初始点$\pmb{x}^0, ~~ k:&#x3D;0$；<br>step2：构造搜索方向$\pmb{p}^k$；<br>step3：根据$\pmb{p}^k$，确定步长$t_k$；<br>step4：令$\pmb{x}^{k+1}&#x3D;\pmb{x}^k+t_k\pmb{p}^k$。</p>
<p>若$x^{k+1}$已满足某种终止条件，停止迭代，输出近似最优解$\pmb{x}^{k+1}$，否则令$k:&#x3D;k+1$，转回第2步。</p>
<p>对无约束最优化问题一般要求$\pmb{p}^k$是下降方向，在约束最优化问题一般要求$\pmb{p}^k$是可行下降方向。</p>
<p>注记：常用停止规则：</p>
<p>$1.\lVert x^{k+1}-x^k \rVert &lt; \epsilon$<br>$2.\frac{\lVert x^{k+1}-x^k \rVert}{\lVert x^k \rVert} &lt; \epsilon$<br>$3.\lVert \nabla f(x^k) \rVert &lt; \epsilon$<br>$4.|f(x^{k+1})-f(x^k)| &lt; \epsilon$</p>
<p>其中1，2称为绝对误差和相对误差</p>
<h2 id="凸规划理论"><a href="#凸规划理论" class="headerlink" title="凸规划理论"></a>凸规划理论</h2><h3 id="凸函数及其性质"><a href="#凸函数及其性质" class="headerlink" title="凸函数及其性质"></a>凸函数及其性质</h3><p>设$S \subset \mathbf{R}^n$是非空凸集，$f:S \rightarrow \mathbf{R}$。如果对任意的$\alpha \in (0,1)$，有<br>$$f(\alpha \pmb{x}^1 + (1-\alpha)\pmb{x}^2) \leq \alpha f(\pmb{x}^1)+(1-\alpha)f(\pmb{x}^2), ~~~ \forall \pmb{x}^1,\pmb{x}^2 \in S$$</p>
<p>则称$f$是$S$上的凸函数。</p>
<p>如果对于任意的$\alpha \in (0,1)$，有<br>$$f(\alpha \pmb{x}^1 + (1-\alpha)\pmb{x}^2) &lt; \alpha f(\pmb{x}^1)+(1-\alpha)f(\pmb{x}^2), ~~~ \forall \pmb{x}^1,\pmb{x}^2 \in S， ~~ \pmb{x}^1 \neq \pmb{x}^2$$</p>
<p>则称$f$是$S$上的严格凸函数。</p>
<p>若$-f$上$S$上的（严格）凸函数，则称$f$是$S$上的（严格）凹函数。</p>
<p>$eg$：线性函数$f(\pmb{x})&#x3D;\pmb{\alpha}^T\pmb{x} + \beta$，其中$\pmb{\alpha},\pmb{x}\in \mathbf{R}^n, \beta \in \mathbf{R}$，在$\mathbf{R}^n$上即是凸函数也是凹函数。</p>
<p>$Th$：设$S\subset \mathbf{R}^n$是非空凸集<br>（1）若$f:\mathbf{R}^n \rightarrow \mathbf{R}$是$S$上的凸函数，$\alpha\geq 0$，则$\alpha f$是$S$上的凸函数；<br>（2）若$f_1,f_2:\mathbf{R}^n \rightarrow\mathbf{R}$都是$S$上的凸函数，则$f_1+f_2$是$S$上的凸函数。</p>
<p>$Th$：设$S\subset \mathbf{R}^n$是非空凸集，$f:S\rightarrow \mathbf{R}$是凸函数，$c\in \mathbf{R}$，则集合<br>$$H_s(f,c)&#x3D;\{ \pmb{x} \in S | f(\pmb{x}) \leq c\}$$<br>是凸集。</p>
<p>一般地说，上述定理的逆定理并不成立。我们称集合$H_s(f,c)$为函数$f$在集合$S$上关于数$c$的水平集。</p>
<p>$Th$:设$S \subset \mathbf{R}^n$是非空开凸集，$f:s\rightarrow \mathbf{R}$可微，则<br>（1）$f$是$S$上的凸函数的充分必要条件是：<br>$$\nabla f(\pmb{x}^1)^T(\pmb{x}^2-\pmb{x}^1) \leq f(\pmb{x}^2)-f(\pmb{x}^1), ~~~ \forall \pmb{x}^1, \pmb{x}^2 \in S$$<br>（2）$f$是$S$上的严格凸函数的充分必要条件是：<br>$$\nabla f(\pmb{x}^1)^T(\pmb{x}^2-\pmb{x}^1)  &lt; f(\pmb{x}^2)-f(\pmb{x}^1), ~~~ \forall \pmb{x}^1, \pmb{x}^2 \in S， \pmb{x}^1 \neq \pmb{x}^2$$</p>
<p>$Proof$：（1）必要性：设$f$设$S$上的凸函数，根据凸函数的定义，对$\forall \alpha \in (0,1)$，有</p>
<p>$$f(\alpha\pmb{x}^2+(1-\alpha)\pmb{x}^1)\leq \alpha f(\pmb{x}^2) +(1-\alpha)f(\pmb{x}^1), ~~~ \forall \pmb{x}^1,\pmb{x}^2 \in S$$</p>
<p>故 $$\frac{f(\pmb{x}^1+\alpha(\pmb{x}^2-\pmb{x}^1))-f(\pmb{x}^1)}{\alpha} \leq  f(\pmb{x}^2)-f(\pmb{x}^1)$$</p>
<p>由多元函数的Taylor公式知：</p>
<p>$$f(\pmb{x}^1+\alpha(\pmb{x}^2-\pmb{x}^1))-f(\pmb{x}^1) &#x3D; \alpha \nabla f(\pmb{x}^1)^T(\pmb{x}^2-\pmb{x}^1) + o(\lVert \alpha(\pmb{x}^2-\pmb{x}^1)\rVert)$$</p>
<p>代入上式有：</p>
<p>$$ \nabla f(\pmb{x}^1)^T(\pmb{x}^2-\pmb{x}^1) + \frac{o(\lVert \alpha(\pmb{x}^2-\pmb{x}^1)\rVert)}{\alpha} \leq  f(\pmb{x}^2)-f(\pmb{x}^1)$$</p>
<p>令$\alpha \rightarrow 0^+$，便得到</p>
<p>$$\nabla f(\pmb{x}^1)^T(\pmb{x}^2-\pmb{x}^1) \leq f(\pmb{x}^2)-f(\pmb{x}^1)$$</p>
<p>充分性：设</p>
<p>$$\nabla f(\pmb{x}^1)^T(\pmb{x}^2-\pmb{x}^1) \leq f(\pmb{x}^2)-f(\pmb{x}^1), ~~~ \forall \pmb{x}^1, \pmb{x}^2 \in S$$</p>
<p>对任意的$\alpha \in (0,1)$，取$\pmb{x}&#x3D;\alpha\pmb{x}^1+(1-\alpha)\pmb{x}^2$，则因为$S$是凸的，故$\pmb{x}\in S$，则对于$\pmb{x}^1,\pmb{x} \in S$,$\pmb{x}^2,\pmb{x} \in S$，分别有：</p>
<p>$$f(\pmb{x})+\nabla f(\pmb{x})^T(\pmb{x}^1-\pmb{x})\leq f(\pmb{x}^1), ~~~\forall \pmb{x}^1 \in S$$</p>
<p>$$f(\pmb{x})+\nabla f(\pmb{x})^T(\pmb{x}^2-\pmb{x})\leq f(\pmb{x}^2), ~~~\forall \pmb{x}^2 \in S$$</p>
<p>做其线性组合，有</p>
<p>$$f(\alpha \pmb{x}^1+(1-\alpha)\pmb{x}^2)&#x3D;f(\pmb{x})&#x3D;f(\pmb{x})+\nabla f(\pmb{x})^T(\alpha(\pmb{x}^1-\pmb{x})+(1-\alpha)(\pmb{x}^2-\pmb{x}))$$</p>
<p>$$ \leq \alpha f(\pmb{x}^1)+(1-\alpha)f(\pmb{x}^2), ~~~ \forall \pmb{x}^1,\pmb{x}^2 \in S$$</p>
<p>因为上式对$\forall \alpha \in(0,1)$成立，则$f$是凸函数。</p>
<p>（2）证明与（1）类似。</p>
<p>$Def$：一个函数$f:\mathbf{R}^n \rightarrow \mathbf{R}$在一点$\pmb{x} \in \mathbf{R}^n$的Hessian矩阵的定义是：</p>
<p>$$\nabla ^2 f(\pmb{x})&#x3D;<br> \begin{pmatrix}<br>   \frac{\partial^2 f(\pmb{x})}{\partial x_1^2} &amp; \frac{\partial^2 f(\pmb{x})}{\partial x_1 \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f(\pmb{x})}{\partial x_1 \partial x_n} \\<br>   \frac{\partial^2 f(\pmb{x})}{\partial x_2 \partial x_1} &amp;  \frac{\partial^2 f(\pmb{x})}{\partial x_2^2} &amp; \cdots &amp;  \frac{\partial^2 f(\pmb{x})}{\partial x_2 \partial x_n} \\<br>   \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>    \frac{\partial^2 f(\pmb{x})}{\partial x_n \partial x_1}&amp;  \frac{\partial^2 f(\pmb{x})}{\partial x_n \partial x_2}&amp; \cdots &amp; \frac{\partial^2 f(\pmb{x})}{\partial x_n^2}<br>  \end{pmatrix}<br>$$<br>在数学分析中已知$f$在$\pmb{x}$处连续的时候有：<br>$$ \frac{\partial^2 f(\pmb{x})}{\partial x_i \partial x_j} &#x3D;  \frac{\partial^2 f(\pmb{x})}{\partial x_j \partial x_i}$$</p>
<p>那么此时$\nabla ^2 f(\pmb{x})$是一个$n$阶对称矩阵。</p>
<p>$Th$：设$S \subset \mathbf{R}^n$是非空开凸集，$f:S\rightarrow \mathbf{R}$二阶连续可导，则：<br>（1）$f$是$S$上的凸函数的充分必要条件是：$f$的Hessian矩阵在$S$上是半正定的。<br>（1）当$f$的Hessian矩阵在$S$上是正定的时候，$f$是$S$上的严格凸函数（逆命题不成立）。</p>
<p>$eg$：设$f(\pmb{x})&#x3D;\frac{1}{2}\pmb{x}^T\pmb{Ax}+\pmb{b}^T\pmb{x}+c$，其中$\pmb{x}\in \mathbf{R}^n$,$\pmb{A}$是一个$n$阶正定矩阵，$\pmb{b}\in \mathbf{R}^n, ~~ c \in \mathbf{R}$。验证$f(\pmb{x})$是$\mathbf{R}^n$上的凸函数。称它为二次凸函数。</p>
<p>$Sol$：$f(\pmb{x})$的Hessian矩阵为：</p>
<p>$$\nabla ^2 f(\pmb{x})&#x3D;A$$</p>
<p>则$f(\pmb{x})$是$\mathbf{R}^n$上的严格凸函数。</p>
<h3 id="凸规划及其性质"><a href="#凸规划及其性质" class="headerlink" title="凸规划及其性质"></a>凸规划及其性质</h3><p>给定一个非线性规划问题：<br>$$<br>\begin{cases}<br>\min  &amp; f(\pmb{x}) \\<br>s.t. &amp; g_i(\pmb{x})\leq 0, &amp; i&#x3D;1,\cdots, p \\<br> ~   &amp; h_j(\pmb{x})&#x3D;0, &amp; j&#x3D;1,\cdots, q \\<br>\end{cases}<br>$$<br>记（MP）的约束集为：<br>$$X&#x3D;\{x\in \mathbf{R}^n | g_i(\pmb{x})\leq 0 , ~ h_j(\pmb{x})&#x3D;0 \}$$<br>如果（MP）的约束集$X$为凸集，目标函数$f$是$X$上的凸函数，则（MP）叫做非线性凸规划，简称凸规划。</p>
<p>$Th$：对于非线性规划（MP），若$g_i(\pmb{x})(i&#x3D;1,\cdots,p)$皆为$\mathbf{R}^n$上的凸函数，$h_j(\pmb{x})(j&#x3D;1,\cdots, q)$皆为线性函数，并且$f$是$X$上的凸函数，则（MP）是凸规划。</p>
<p>注记：此情况是一个判断凸规划的特殊情况。</p>
<p>对于凸规划，有如下的重要性质：<br>$Th$：凸规划的任一局部睫都是它的整体最优解。</p>
<p>$Proof$：设$\pmb{x}^*$是凸规划（MP）的一个局部最优解，由定义知，存在$\pmb{x}^*$的邻域$N_\delta(\pmb{x}^*)$，使得<br><font color="#dd0000">$$f(\pmb{x}^*) \leq f(\pmb{x}), ~~~ \forall \pmb{x} \in X \cap N_\delta(\pmb{x}^*)$$</font><br></p>
<p>若$\pmb{x}^*$不是（MP）的整体最优解，由定义知，存在$\bar{\pmb{x}}\in X$，使得</p>
<p>$$f(\bar{\pmb{x}}) &lt; f(\pmb{x}^*)$$</p>
<p>又因为$f$是凸函数。因此有</p>
<p><font color="#dd0000">$$f(\alpha \pmb{\bar{x}} + (1-\alpha)\pmb{x}^*) \leq \alpha f(\pmb{\bar{x}}) + (1-\alpha)f(\pmb{x}^*) &lt; \alpha f(\pmb{x}^*)+(1-\alpha)f(\pmb{x}^*)&#x3D;f(\pmb{x}^*)$$</font><br></p>
<p>当$\alpha &gt; 0$充分小时，有</p>
<p>$$\alpha \bar{x} + (1-\alpha) \pmb{x}^* \in X \cap N_\delta(\pmb{x}^*)$$</p>
<p>那么就存在矛盾了。</p>
<p>注记：由此可见，对于凸规划问题，一旦求得了它的一个局部最优解，实际上就得到了它的整体最优解。</p>
<h2 id="一维搜索方法"><a href="#一维搜索方法" class="headerlink" title="一维搜索方法"></a>一维搜索方法</h2><p>一位搜索问题又称为线性搜索问题，是指目标函数为单变量的非线性规划问题，数学模型为：</p>
<p>$$\min_{\begin{matrix}t \geq 0 \\ (0 \leq t \leq t_{max}) \end{matrix}}\varphi(t)$$</p>
<p>其中$t \in \mathbf{R}$。<br>当$t$的取值为$t \geq 0 $的问题称为一维搜索问题。<br>当$t$的取值为$ 0\leq t \leq t_{max} $的问题称为有效一维搜索问题。</p>
<h3 id="0-618法"><a href="#0-618法" class="headerlink" title="0.618法"></a>0.618法</h3><p>本方法是寻找单谷函数的极小值的一种方法。<br>单谷函数是指存在一个$t^* \in [a,b]$，使得$\varphi(t)$在$[a,t^*]$上严格递减，在$[t^*,b]$上严格递增，则称$\varphi(t)$是单谷的，区间$[a,b]$称为$\varphi(t)$的单谷区间。</p>
<p>注记：（1）易知$t^*$是$\varphi(t)$在$[a,b]$上的唯一极小点<br>（2）单谷函数可以不可微，甚至不连续。</p>
<p>我们给定问题</p>
<p>$$\min_{a\leq t \leq b} \varphi(t)$$</p>
<p>其中$[a,b]$是$\varphi(t)$的单谷区间，我们的目的是通过缩小区间$[a,b]$得到一个近似解。</p>
<p>在$[a,b]$上任去两个点$t_1,t_2$。设$t_1 &lt; t_2$，由于$\varphi(t)$设单谷函数，由定义可知</p>
<p>（1）若$\varphi(t_1) \leq \varphi(t_2)$，则$t^* \in [a,t_2]$<br>（2）若$\varphi(t_1) \geq \varphi(t_2)$，则$t^* \in [t_1,b]$</p>
<p>因此，通过比较$\varphi(t_1)$和$\varphi(t_2)$的大小，可将搜索区间缩小为$[a,t_2]$或$[t_1,b]$。在缩小区间的时候我们可以逐渐得到精确解。</p>
<p>我们分析如何去寻找$t_1$和$t_2$</p>
<p>首先，我们不知道缩小后的区间是两个中的哪一个，所以我们令二者长度相等，即</p>
<p>$$t_2-a &#x3D; b-t_1$$</p>
<p>令<br>$$\omega &#x3D; \frac{t_2-a}{b-a} &#x3D; \frac{b-t_1}{b-a}$$</p>
<p>表示搜索区间缩小的比，则有：</p>
<p>$$t_1&#x3D;a+(1-\omega)(b-a)$$<br>$$t_2&#x3D; a+\omega(b-a)$$</p>
<p>我们希望下一次迭代时，区间缩小比例仍为$\omega$。不妨设新的搜索区间为$[a,t_2]$并且$t_1$已经计算过函数值了。在新一轮迭代中，我们去两个探索点$t_{1}’ &lt; t_2’$，要求其中的一点是$t_1$，并且满足：<br>$$\frac{t_2’-a}{t_2-a}&#x3D;\frac{t_2-t_1’}{t_2-a}&#x3D;\omega$$</p>
<p>带入可以得到</p>
<p>$$t_2’ - a &#x3D; \omega^2(b-a), ~~~~~ t_2 - t_1’ &#x3D; \omega ^2 (b-a)$$</p>
<p>令$t_2’ &#x3D; t_1 $，则由$t_1-a &#x3D; \omega^2 (b-a)$以及$t_1&#x3D;a+(1-\omega)(b-a)$ 有：<br>$$\omega ^2 &#x3D; 1- \omega $$</p>
<p>解的方程组的解为：$\omega &#x3D; \frac{\sqrt{5}-1}{2}\approx 0.618$</p>
<p>对搜索区间为$[t_1,b]$的情况，可以同样讨论，这时应取$t_1’&#x3D;t_2$，取$t_2’$为新的探索点。</p>
<p>解问题$\min\limits_{a\leq t \leq b} \varphi(t)$的一般方法如下：</p>
<p>$1.$确定单谷区间$[a,b]$，给定最后区间精度$\epsilon&gt;0$<br>$2.$计算最初两个探索点：<br>$$t_1&#x3D;a+0.382(b-a) &#x3D; b - 0.618(b-a)$$<br>$$t_2 &#x3D; a + 0.618(b-a)$$<br>并计算$\varphi_1 &#x3D; \varphi(t_1),~~~ \varphi_2 &#x3D; \varphi(t_2)$<br>$3.$若$\varphi_1 \leq \varphi_2$，转第四步，否则转第五步<br>$4.$若$t_2-a \leq \epsilon$，停止迭代，输出$t_1$，否则令$$b:&#x3D;t_2,~~~ t_2 :&#x3D;t_1,~~~ t_1 :&#x3D;a+0.382(b-a),~~ \varphi_2:&#x3D;\varphi_1 $$<br>计算$\varphi_1&#x3D;\varphi(t_1)$，转第三步。<br>$5.$若$b-t_1 \leq \epsilon$，停止迭代，输出$t_2$，否则令$$a:&#x3D;t_1,~~~ t_1 :&#x3D;t_2,~~~ t_2 :&#x3D;a+0.618(b-a),~~ \varphi_1:&#x3D;\varphi_2 $$<br>计算$\varphi_2&#x3D;\varphi(t_2)$，转第三步。</p>
<p>$eg$：用0.618法求解<br>$$\min_{t\geq 0 } \varphi(t) &#x3D; t^3-2t+1$$</p>
<p>其中$\varphi(t)$的单谷区间为$[0,3]$，$\epsilon &#x3D; 0.5$</p>
<p>在求解过程中可以用表格求解：</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>$a$</td>
<td>$0$</td>
<td>$0 $</td>
<td>$0 $</td>
<td>$0.438$</td>
<td>$0.708$</td>
</tr>
<tr>
<td>$b$</td>
<td>$3$</td>
<td>$1.854$</td>
<td>$1.146$</td>
<td>$1.146$</td>
<td>$1.146$</td>
</tr>
<tr>
<td>$t_1$</td>
<td>$1.146$</td>
<td>$0.708$</td>
<td>$0.438$</td>
<td>$0.708$</td>
<td></td>
</tr>
<tr>
<td>$t_2$</td>
<td>$1.854$</td>
<td>$1.146$</td>
<td>$0.708$</td>
<td>$0.876$</td>
<td></td>
</tr>
<tr>
<td>$\varphi_1$</td>
<td>$0.2131$</td>
<td>$-0.0611$</td>
<td>$0.2080$</td>
<td>$-0.0611$</td>
<td></td>
</tr>
<tr>
<td>$\varphi_2$</td>
<td>$3.6648$</td>
<td>$0.2131$</td>
<td>$-0.0611$</td>
<td>$-0.0798$</td>
<td></td>
</tr>
<tr>
<td>关系</td>
<td>$\varphi_1 &lt; \varphi_2$</td>
<td>$\varphi_1 &lt; \varphi_2$</td>
<td>$\varphi_1 &gt; \varphi_2$</td>
<td>$\varphi_1 &gt; \varphi_2$</td>
<td></td>
</tr>
<tr>
<td>换$a$</td>
<td></td>
<td></td>
<td>$\surd$</td>
<td>$\surd$</td>
<td></td>
</tr>
<tr>
<td>换$b$</td>
<td>$\surd$</td>
<td>$\surd$</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>第四轮迭代开始有$b-a &#x3D; 1.146-0.708 &lt; 0.5$，停止迭代。</p>
<p>我们考虑用python实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">phi</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> t*t*t-<span class="number">2</span>*t+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">a=<span class="number">0.0</span></span><br><span class="line">b=<span class="number">3.0</span></span><br><span class="line">turn=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(b-a&gt;<span class="number">0.5</span>):</span><br><span class="line">    turn=turn+<span class="number">1</span></span><br><span class="line">    t_1=a+((<span class="number">3</span>-math.sqrt(<span class="number">5</span>))/<span class="number">2</span>)*(b-a)</span><br><span class="line">    t_2=a+((math.sqrt(<span class="number">5</span>)-<span class="number">1</span>)/<span class="number">2</span>)*(b-a)</span><br><span class="line">    phi_1=phi(t_1)</span><br><span class="line">    phi_2=phi(t_2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;turn &#123;&#125;, a = &#123;:.3f&#125;, b = &#123;:.3f&#125;, t_1 = &#123;:.3f&#125;, t_2 = &#123;:.3f&#125;, &quot;</span>.<span class="built_in">format</span>(turn, a, b, t_1, t_2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;phi_1 = &#123;:.4f&#125;, phi_2 = &#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(phi_1, phi_2))</span><br><span class="line">    <span class="keyword">if</span> phi_1 &gt; phi_2:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;phi_1 &gt; phi_2, change a&quot;</span>)</span><br><span class="line">        a=t_1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;phi_1 &lt; phi_2, change b&quot;</span>)</span><br><span class="line">        b=t_2</span><br><span class="line">    <span class="built_in">print</span>()    </span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">turn <span class="number">1</span>, a = <span class="number">0.000</span>, b = <span class="number">3.000</span>, t_1 = <span class="number">1.146</span>, t_2 = <span class="number">1.854</span>, </span><br><span class="line">phi_1 = <span class="number">0.2129</span>, phi_2 = <span class="number">3.6656</span></span><br><span class="line">phi_1 &lt; phi_2, change b</span><br><span class="line"></span><br><span class="line">turn <span class="number">2</span>, a = <span class="number">0.000</span>, b = <span class="number">1.854</span>, t_1 = <span class="number">0.708</span>, t_2 = <span class="number">1.146</span>, </span><br><span class="line">phi_1 = -<span class="number">0.0612</span>, phi_2 = <span class="number">0.2129</span></span><br><span class="line">phi_1 &lt; phi_2, change b</span><br><span class="line"></span><br><span class="line">turn <span class="number">3</span>, a = <span class="number">0.000</span>, b = <span class="number">1.146</span>, t_1 = <span class="number">0.438</span>, t_2 = <span class="number">0.708</span>, </span><br><span class="line">phi_1 = <span class="number">0.2085</span>, phi_2 = -<span class="number">0.0612</span></span><br><span class="line">phi_1 &gt; phi_2, change a</span><br><span class="line"></span><br><span class="line">turn <span class="number">4</span>, a = <span class="number">0.438</span>, b = <span class="number">1.146</span>, t_1 = <span class="number">0.708</span>, t_2 = <span class="number">0.875</span>, </span><br><span class="line">phi_1 = -<span class="number">0.0612</span>, phi_2 = -<span class="number">0.0800</span></span><br><span class="line">phi_1 &gt; phi_2, change a</span><br></pre></td></tr></table></figure>

<p>由于存在精度损失，答案和课本上有些许出入。</p>
<h3 id="Newton法"><a href="#Newton法" class="headerlink" title="Newton法"></a>Newton法</h3><p>考虑如下的一维搜索问题：</p>
<p>$$min ~~ \varphi(t)$$</p>
<p>其中$\varphi(t)$是二次可微的，且$\varphi’’(t) \neq 0$</p>
<p>Newton法的基本思想是：用$\varphi(t)$在探索点$t_k$的二阶Taylor展开式$g(t)$来近似代替$\varphi(t)$,即</p>
<p>$$\varphi(t) \approx g(t)&#x3D; \varphi(t_k) + \varphi’(t_k)(t-t_k)+\frac{\varphi’’(t_k)}{2}(t-t_k)^2$$</p>
<p>然后用$g(t)$的最小点作为新的探索点$t_{k+1}$。据此，令</p>
<p>$$g’(t)&#x3D;\varphi’(t_k)+ \varphi’’(t_k)(t-t_k)&#x3D;0$$</p>
<p>得到解$t_{k+1} &#x3D; t_k - \frac{\varphi’(t_k)}{\varphi’’(t_k)}$</p>
<p>开始设定一个点$t_1$，然后按照上述共识进行迭代计算，当$|\varphi’(t_k)|&lt;\epsilon$时，则迭代结束，此时$t_k$为$\varphi(t)$的最小点近似。</p>
<p>求解Newton法的步骤：</p>
<p>$1.$给定初始点$t_1,~~ \epsilon &gt;0 , ~~~ k:&#x3D;1$<br>$2.$如果$|\varphi’(t_k)|&lt; \epsilon $，停止迭代，输出$t_k$，否则，当$\varphi’’(t_k)&#x3D;0$时，停止，解题失败，当$\varphi’’(t_k)\neq 0$时，转第三步<br>$3.$计算$t_{k+1} &#x3D; t_k - \frac{\varphi’(t_k)}{\varphi’’(t_k)}$，如果$|t_{k+1}-t_k|&lt; \epsilon $，停止迭代，输出$t_{k+1}$；否则，$k:&#x3D;k+1$，转第二步。</p>
<p>$eg$：用Newton法求函数的最优解：</p>
<p>$$\min ~~ \varphi(t) &#x3D; \int_0^t \arctan xdx$$</p>
<p>$Sol $：先求出</p>
<p>$$\varphi’(t) &#x3D;\arctan t , ~~~~~ \varphi’’(t) &#x3D; \frac{1}{1+t^2}$$</p>
<p>取$t_1&#x3D;1$，计算结果列于下表：</p>
<table>
<thead>
<tr>
<th>$k$</th>
<th>$t_k$</th>
<th>$\varphi’(t_k)$</th>
<th>$1&#x2F;\varphi’’(t_k)$</th>
</tr>
</thead>
<tbody><tr>
<td>$1$</td>
<td>$1$</td>
<td>$0.7854$</td>
<td>$2$</td>
</tr>
<tr>
<td>$2$</td>
<td>$-0.5708$</td>
<td>$-0.5187$</td>
<td>$1.3258$</td>
</tr>
<tr>
<td>$3$</td>
<td>$0.1169$</td>
<td>$0.1164$</td>
<td>$1.0137$</td>
</tr>
<tr>
<td>$4$</td>
<td>$-0.0011$</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>易知$t&#x3D;0$为$\varphi(t)$的精确解，用Newton迭代三次后得到的$t_4$已经非常接近近似解了。</p>
<p>注记：Newton法的思想可以直接推广到求多变量函数$f(x_1,\cdots, x_n)$的无约束级值问题，只是将$\varphi’(t_k)$代替为$\nabla f(\pmb{x}^k)$，代替$\frac{1}{\varphi’’(t_k)}$的是$(\nabla ^2f(\pmb{x}^k))^{-1}$</p>
<p>我们考虑用python实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partial_phi</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> np.arctan(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partial_2_phi</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+t*t)</span><br><span class="line"></span><br><span class="line">t=<span class="number">1.0</span></span><br><span class="line">eps=<span class="number">1e-6</span></span><br><span class="line">turn=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">abs</span>(partial_phi(t))&gt;eps):</span><br><span class="line">    turn=turn+<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;turn &#123;&#125;: t = &#123;:.6f&#125;&quot;</span>.<span class="built_in">format</span>(turn,t))</span><br><span class="line">    tmp=t-partial_phi(t)/partial_2_phi(t)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(tmp-t)&lt;eps):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    t=tmp    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;answer = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(t))</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">turn <span class="number">1</span>: t = <span class="number">1.000000</span></span><br><span class="line">turn <span class="number">2</span>: t = -<span class="number">0.570796</span></span><br><span class="line">turn <span class="number">3</span>: t = <span class="number">0.116860</span></span><br><span class="line">turn <span class="number">4</span>: t = -<span class="number">0.001061</span></span><br><span class="line">answer = <span class="number">7.963096044106416e-10</span></span><br></pre></td></tr></table></figure>

<p>但是取$t_1&#x3D;2$迭代的话，结果如下：</p>
<table>
<thead>
<tr>
<th>$k$</th>
<th>$t_k$</th>
<th>$\varphi’(t_k)$</th>
<th>$1&#x2F;\varphi’’(t_k)$</th>
</tr>
</thead>
<tbody><tr>
<td>$1$</td>
<td>$2$</td>
<td>$1.1071$</td>
<td>$5$</td>
</tr>
<tr>
<td>$2$</td>
<td>$-3.5357$</td>
<td>$-1.2952$</td>
<td>$13.50$</td>
</tr>
<tr>
<td>$3$</td>
<td>$13.95$</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>结果是发散的。</p>
<p>从任意初始点开始的Newton迭代法产生的点列$\{ t_k \}$，一般来说，不一定收敛，即使收敛，其极限点也不一定是$\varphi(t)$的极小点，而只能保证它是$\varphi(t)$的驻点，但是当初始点充分接近$t^*$时，可以证明Newton法是收敛的，并且收敛速度很快。</p>
<p>我们将这种性质称为局部收敛性。反之，若对任意的初始点，由方法产生的点列都收敛于最优解，则称该方法具有全局收敛性。</p>
<h2 id="无约束最优化方法"><a href="#无约束最优化方法" class="headerlink" title="无约束最优化方法"></a>无约束最优化方法</h2><p>我们讨论$n$元函数的无约束非线性规划问题（UMP）：</p>
<p>$$\min f(\pmb{x})$$</p>
<p>的求解方法，其中$\pmb{x}&#x3D;(x_1,\cdots, x_n)^T \in \mathbf{R}^n, f:\mathbf{R}^n \rightarrow \mathbf{R}$，这些方法通常称为无约束最优化方法。</p>
<p>无约束最优化方法大体分为两类：解析法和直接法。解析法在计算中需要用到导数信息（梯度，Hessian矩阵等），而直接法则是在计算过程中仅用到函数值的方法。</p>
<h3 id="最优性条件"><a href="#最优性条件" class="headerlink" title="最优性条件"></a>最优性条件</h3><p>$Th$：设$f:\mathbf{R}^n \rightarrow \mathbf{R}$在点$\bar{x}\in \mathbf{R}^n$处可微。若存在$\pmb{p}\in \mathbf{R}^n$，使得</p>
<p>$$\nabla f(\bar{\pmb{x}})^Tp&lt;0$$</p>
<p>则$\pmb{p}$是$f$在点$\bar{\pmb{x}}$处的下降方向。</p>
<p>$Th$：设$f:\mathbf{R}^n\rightarrow\mathbf{R}$在点$\pmb{x}^* \in \mathbf{R}^n$处可微，若$\pmb{x}^*$是（UMP）的局部最优解，则<br>$$\nabla f(\pmb{x}^*) &#x3D; \pmb{0}$$</p>
<p>注记：梯度为0只是最优解的一个必要条件，在数学分析中我们学过，一个函数梯度为0的时候函数可能是极大点，可能是极小点甚至可能什么都不是。</p>
<p>$Th$：设$f:\mathbf{R}^n\rightarrow\mathbf{R}$在点$\pmb{x}^* \in \mathbf{R}^n$处的Hessian矩阵存在，若$\nabla f(\pmb{x}^*) &#x3D; \pmb{0}$且$\nabla ^2 f(\pmb{x}^*)$正定，则$\pmb{x}^*$是（UMP）问题的严格局部最优解。</p>
<p>注记：这样的性质我们只能找到一个局部的最优解。但是在凸函数中，我们有下列良好的性质：</p>
<p>$Th$：$f:\mathbf{R}^n\rightarrow\mathbf{R}$在点$\pmb{x}^* \in \mathbf{R}^n$，$f$是$\mathbf{R}^n$上的可微凸函数。若有<br>$$\nabla f(\bar{\pmb{x}})^Tp&#x3D;0$$<br>则$x^*$是（UMP）的整体最优解。</p>
<p>下面介绍两种解析。</p>
<h3 id="最速下降法"><a href="#最速下降法" class="headerlink" title="最速下降法"></a>最速下降法</h3><p>核心思想是下降方向选负梯度方向时，函数下降的最快。</p>
<p>下面列出步骤：</p>
<p>$1.$选取初始点$\pmb{x}^0$，给定误差$\epsilon&gt;0$，令$k&#x3D;0$<br>$2.$计算$\nabla f(\pmb{x})^k$，若$\lVert \nabla f(\pmb{x}^k)  \rVert \leq \epsilon$，停止迭代，输出$\pmb{x}^k$；否则进行第3步<br>$3.$取$\pmb{p}^k&#x3D;-\nabla f(\pmb{x}^k)$<br>$4.$进行一维搜索，求$t_k$，使得$f(\pmb{x}^k+t_k\pmb{p}^k) &#x3D; \min\limits_{t \geq 0}f(\pmb{x}^k+t\pmb{p}^k)$，令$\pmb{x}^{k+1} &#x3D; \pmb{x}^k + t_k\pmb{p}^k$，$k&#x3D;k+1$，转第2步。</p>
<p>$eg$：用最速下降法求解如下问题：<br>$$\min f(x_1,x_2)&#x3D;x_1^2 + 25 x_2^2$$</p>
<p>其中初始点$\pmb{x}^0 &#x3D; (2,2)^T $，终止误差$\epsilon&#x3D;10^{-6}$</p>
<p>我们使用python实现，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">INF = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grad_f</span>(<span class="params">x</span>): <span class="comment">#求f的梯度</span></span><br><span class="line">    l=[]</span><br><span class="line">    l.append(<span class="number">2</span> * x[<span class="number">0</span>])</span><br><span class="line">    l.append(<span class="number">50</span> * x[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">norm_2</span>(<span class="params">x</span>): <span class="comment">#2范数</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(x[<span class="number">0</span>] ** <span class="number">2</span> + x[<span class="number">1</span>] ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f_t</span>(<span class="params">x, p, t</span>): <span class="comment">#在一维搜索时的函数,即f(x+t*p)</span></span><br><span class="line">    <span class="keyword">return</span> (x[<span class="number">0</span>] + t * p[<span class="number">0</span>]) ** <span class="number">2</span> + <span class="number">25</span> * (x[<span class="number">1</span>] + t * p[<span class="number">1</span>]) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">a, b, x, p, eps</span>): <span class="comment">#对t进行一维搜索</span></span><br><span class="line">    <span class="keyword">while</span>(b - a &gt; eps):</span><br><span class="line">        t_1 = a + ((<span class="number">3</span> - math.sqrt(<span class="number">5</span>)) / <span class="number">2</span>) * (b - a)</span><br><span class="line">        t_2 = a + ((math.sqrt(<span class="number">5</span>) - <span class="number">1</span>) / <span class="number">2</span>) * (b - a)</span><br><span class="line">        f_1 = f_t(x, p, t_1)</span><br><span class="line">        f_2 = f_t(x, p, t_2)</span><br><span class="line">        <span class="keyword">if</span> f_1 &gt; f_2:</span><br><span class="line">            <span class="keyword">if</span>(t_2 - a &lt;= eps):</span><br><span class="line">                <span class="keyword">return</span> t_1</span><br><span class="line">            a = t_1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span>(b - t_1 &lt;= eps):</span><br><span class="line">                <span class="keyword">return</span> t_2</span><br><span class="line">            b = t_2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_descent</span>(<span class="params">x, eps</span>):</span><br><span class="line">    turn = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(norm_2(x) &gt; eps):</span><br><span class="line">        turn = turn + <span class="number">1</span></span><br><span class="line">        grad = grad_f(x)</span><br><span class="line">        grad[<span class="number">0</span>] = -grad[<span class="number">0</span>]</span><br><span class="line">        grad[<span class="number">1</span>] = -grad[<span class="number">1</span>]</span><br><span class="line">        t = search(<span class="number">0</span>, INF, x, grad, <span class="number">1e-10</span>) <span class="comment"># 左端点，右端点，本轮迭代向量，负梯度向量，精度</span></span><br><span class="line">        x[<span class="number">0</span>] = x[<span class="number">0</span>] + t * grad[<span class="number">0</span>]</span><br><span class="line">        x[<span class="number">1</span>] = x[<span class="number">1</span>] + t * grad[<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;now turn: &#123;&#125;, x = [&#123;:.10f&#125;, &#123;:.10f&#125;]&quot;</span>.<span class="built_in">format</span>(turn, x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> x, turn</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">ans, turn = gradient_descent([<span class="number">2</span>,<span class="number">2</span>],<span class="number">1e-6</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;turn = &#123;&#125;, answer = [&#123;:.10f&#125;, &#123;:.10f&#125;]&quot;</span>.<span class="built_in">format</span>(turn, ans[<span class="number">0</span>], ans[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">now turn: <span class="number">1</span>, x = [<span class="number">1.9198771278</span>, -<span class="number">0.0030718038</span>]</span><br><span class="line">now turn: <span class="number">2</span>, x = [<span class="number">0.0708877878</span>, <span class="number">0.0708877800</span>]</span><br><span class="line">now turn: <span class="number">3</span>, x = [<span class="number">0.0680479212</span>, -<span class="number">0.0001088767</span>]</span><br><span class="line">now turn: <span class="number">4</span>, x = [<span class="number">0.0025125388</span>, <span class="number">0.0025125387</span>]</span><br><span class="line">now turn: <span class="number">5</span>, x = [<span class="number">0.0024118829</span>, -<span class="number">0.0000038590</span>]</span><br><span class="line">now turn: <span class="number">6</span>, x = [<span class="number">0.0000890545</span>, <span class="number">0.0000890543</span>]</span><br><span class="line">now turn: <span class="number">7</span>, x = [<span class="number">0.0000854869</span>, -<span class="number">0.0000001368</span>]</span><br><span class="line">now turn: <span class="number">8</span>, x = [<span class="number">0.0000031564</span>, <span class="number">0.0000031564</span>]</span><br><span class="line">now turn: <span class="number">9</span>, x = [<span class="number">0.0000030300</span>, -<span class="number">0.0000000048</span>]</span><br><span class="line">now turn: <span class="number">10</span>, x = [<span class="number">0.0000001119</span>, <span class="number">0.0000001119</span>]</span><br><span class="line">turn = <span class="number">10</span>, answer = [<span class="number">0.0000001119</span>, <span class="number">0.0000001119</span>]</span><br></pre></td></tr></table></figure>

<p>可以看到迭代10轮就收敛了到了一个离最优解$(0,0)^T$很接近的向量。</p>
<p>注记：这里因为只有两个变量，所以直接使用了列表list，如果是高维的话可以使考虑使用numpy</p>
]]></content>
      <categories>
        <category>运筹学</category>
        <category>非线性规划</category>
      </categories>
      <tags>
        <tag>运筹学</tag>
      </tags>
  </entry>
</search>
